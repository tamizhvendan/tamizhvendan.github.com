<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: suave | P3 Programmer]]></title>
  <link href="http://blog.tamizhvendan.in/blog/categories/suave/atom.xml" rel="self"/>
  <link href="http://blog.tamizhvendan.in/"/>
  <updated>2016-04-28T20:18:23+05:30</updated>
  <id>http://blog.tamizhvendan.in/</id>
  <author>
    <name><![CDATA[Tamizhvendan S]]></name>
    <email><![CDATA[tamizh88@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Implementing API Gateway in F# using Rx and Suave]]></title>
    <link href="http://blog.tamizhvendan.in/blog/2015/12/29/implementing-api-gateway-in-f-number-using-rx-and-suave/"/>
    <updated>2015-12-29T09:22:49+05:30</updated>
    <id>http://blog.tamizhvendan.in/blog/2015/12/29/implementing-api-gateway-in-f-number-using-rx-and-suave</id>
    <content type="html"><![CDATA[<p>One of the impressive aspects of functional programming is that it will enable you to write simple and expressive code to solve  complex problems. If you are wondering, how is it possible? Well, It is because, Functional Programming provides a lot of higher level abstractions to solve the problem in hand and avoids the need of writing lot of boilerplate &amp; plumbing code. As a developer, you will be more productive and deliver the solution faster.</p>

<p>In this blog post, we are going to see the application of the above statements by implementing an <a href="https://www.nginx.com/blog/building-microservices-using-an-api-gateway">API Gateway Pattern</a> in F# using <a href="http://reactivex.io/">Rx</a> and <a href="https://suave.io/">Suave</a>.  </p>

<blockquote>
  <p>This blog post is my contribution towards <a href="https://sergeytihon.wordpress.com/2015/10/25/f-advent-calendar-in-english-2015/">fsharp advent calendar 2015</a>. Do check out other great fsharp posts there</p>
</blockquote>

<h2 id="api-gateway-pattern">API Gateway Pattern</h2>
<p>Let’s assume that you are asked to build the backend for the below GitHub user profile screen.</p>

<p><img src="http://res.cloudinary.com/tamizhvendan/image/upload/v1450769741/Profile.png" alt="Github Profile" /></p>

<p>This profile screen has 3 components</p>

<ol>
  <li>
    <p>User - Username and Avatar</p>
  </li>
  <li>
    <p>Popular Repos - Top 3 Repos of the Given User (determined by the number of stars)</p>
  </li>
  <li>
    <p>Languages being used in the corresponding repos</p>
  </li>
</ol>

<p>Now as a developer, you have two options</p>

<ul>
  <li>
    <p>Build the Profile completely in client side by calling their corresponding GitHub APIs
<img src="http://res.cloudinary.com/tamizhvendan/image/upload/v1450769816/Profile_With_API_Calls.png" alt="Profile with URLs" /></p>

    <p>This approach makes the client side complex as it involves five HTTP requests to create the complete profile screen. It has a lot of drawbacks as mentioned in <a href="http://techblog.netflix.com/2013/01/optimizing-netflix-api.html">this blog post</a> by Netflix.</p>
  </li>
  <li>
    <p>Create a Facade API which takes care of the heavy lifting and hides the complexity of calling multiple services by  exposing a single endpoint which returns all the data required to create the profile screen in one API call
<img src="http://res.cloudinary.com/tamizhvendan/image/upload/v1450775641/API_Gateway.png" alt="API Gateway" /></p>

    <p>This approach is called API Gateway. It is one of the commonly used <a href="http://microservices.io/patterns/apigateway.html">patterns in the microservices</a> world.</p>
  </li>
</ul>

<h2 id="rx">Rx</h2>

<p>API Gateway is normally implemented using <a href="http://reactivex.io/">Rx</a>. Rx, an implementation of <a href="https://gist.github.com/staltz/868e7e9bc2a7b8c1f754">Functional Reactive Programming</a>, makes it easy to implement this kind of problems by enable us to think each asynchronous operation as streams (aka Observables). These streams offer a declarative API to work with the asynchronous operations.</p>

<p>In the implementation that we are going to see, we will be using <a href="http://fsprojects.github.io/FSharp.Control.Reactive/">FSharp.Control.Reactive</a>, an extension and wrapper for using the Reactive Extensions (Rx) with F#</p>

<h2 id="project-structure">Project Structure</h2>

<p>Create a new F# Console Application Project with the name <code>RxFsharp</code> and then create the files mentioned below in the given order</p>

<pre><code>RxFsharp
|--Http.fs --&gt; Abstraction to make http requests
|--GitHub.fs --&gt; Define data types, transforming &amp; parsing of responses from GitHub
|--ObservableExtensions.fs --&gt; Some Util methods over Rx Observable
|--Profile.fs --&gt; Implemention of API Gateway using Rx
|--ApiGateway.fs --&gt; Suave API
|--Program.fs --&gt; Entry Point
|--user.json --&gt; Sample response of GitHub user API
|--repos.json --&gt; Sample response of GitHub repos API
|--App.config
|--packages.config
</code></pre>

<p>Then install the following NuGet packages</p>

<ul>
  <li><a href="https://www.nuget.org/packages/FSharp.Control.Reactive">FSharp.Control.Reactive</a></li>
  <li><a href="https://www.nuget.org/packages/Http.fs">Http.fs</a></li>
  <li><a href="https://www.nuget.org/packages/Suave">Suave</a></li>
  <li><a href="https://www.nuget.org/packages/Newtonsoft.Json">Newtonsoft.Json</a></li>
  <li><a href="https://www.nuget.org/packages/FSharp.Data">FSharp.Data</a></li>
</ul>

<h2 id="modeling-http-request--response-as-stream">Modeling Http Request &amp; Response as Stream</h2>

<p>In Functional Reactive Programming(FRP) every action is treated as stream. So, first step in implementing an API Gateway is modeling each HTTP request&amp;response as stream.</p>

<p>Open <code>Http.fs</code> file and update it as below</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"> <a href="#n1" name="n1">1</a></span>module Http
<span class="line-numbers"> <a href="#n2" name="n2">2</a></span>
<span class="line-numbers"> <a href="#n3" name="n3">3</a></span>open HttpClient
<span class="line-numbers"> <a href="#n4" name="n4">4</a></span>open FSharp.Control.Reactive
<span class="line-numbers"> <a href="#n5" name="n5">5</a></span>
<span class="line-numbers"> <a href="#n6" name="n6">6</a></span>type HttpResponse =
<span class="line-numbers"> <a href="#n7" name="n7">7</a></span>| Ok of string
<span class="line-numbers"> <a href="#n8" name="n8">8</a></span>| Error of int
<span class="line-numbers"> <a href="#n9" name="n9">9</a></span>
<span class="line-numbers"><strong><a href="#n10" name="n10">10</a></strong></span>let getResponseAsync url =
<span class="line-numbers"><a href="#n11" name="n11">11</a></span>  async {
<span class="line-numbers"><a href="#n12" name="n12">12</a></span>    let! response =
<span class="line-numbers"><a href="#n13" name="n13">13</a></span>      createRequest Get url
<span class="line-numbers"><a href="#n14" name="n14">14</a></span>      |&gt; withHeader (UserAgent &quot;FsharpRx&quot;)
<span class="line-numbers"><a href="#n15" name="n15">15</a></span>      |&gt; HttpClient.getResponseAsync
<span class="line-numbers"><a href="#n16" name="n16">16</a></span>    let httpResponse =
<span class="line-numbers"><a href="#n17" name="n17">17</a></span>      match response.StatusCode with
<span class="line-numbers"><a href="#n18" name="n18">18</a></span>      | 200 -&gt; response.EntityBody.Value |&gt; Ok
<span class="line-numbers"><a href="#n19" name="n19">19</a></span>      | _ -&gt; response.StatusCode |&gt; Error
<span class="line-numbers"><strong><a href="#n20" name="n20">20</a></strong></span>    return httpResponse
<span class="line-numbers"><a href="#n21" name="n21">21</a></span>  }
<span class="line-numbers"><a href="#n22" name="n22">22</a></span>
<span class="line-numbers"><a href="#n23" name="n23">23</a></span>let asyncResponseToObservable = getResponseAsync &gt;&gt; Observable.ofAsync
</pre></div>
</div>
</div>

<p>The <code>getResponseAsync</code> function makes use of <a href="https://github.com/relentless/Http.fs">Http.fs</a>, an HTTP Client library for F#, to fire the HTTP GET request and returns the HTTP response asynchronously.</p>

<p>The HTTP response has been modeled as either <code>Ok</code> with the response content for all the responses with the status code <code>200</code> and everything else is treated as <code>Error</code> for simplicity.</p>

<p>In the final line, we create a stream (aka Observable) from asynchronous response using the function <code>Observable.ofAsync</code> from <a href="https://github.com/fsprojects/FSharp.Control.Reactive">FSharp.Control.Reactive</a></p>

<p>As all the GitHub API <a href="https://developer.github.com/v3/#user-agent-required">requests require user agent</a>, we are adding one before firing the request.</p>

<h2 id="parsing-and-transforming-github-api-responses">Parsing and Transforming GitHub API Responses</h2>

<p>Upon successful response from GitHub, the next step is parsing the JSON response and transforming the parsed response as per the Profile screen requirements.</p>

<p>To parse the response, we are going to leverage the powerful tool of FSharp called <a href="http://fsharp.github.io/FSharp.Data/library/JsonProvider.html">JsonTypeProvider</a></p>

<p>The JSON Type Provider provides statically typed access to JSON documents. It takes a sample document as an input. Here in our case, it is user.json and repos.json</p>

<p>Get the sample response from GitHub using its <a href="https://api.github.com/users/tamizhvendan">User API</a> and <a href="https://api.github.com/users/tamizhvendan/repos">Repos API</a> and save the response in user.json and repos.json respectively.</p>

<p>With the help of JsonTypeProvider, we can now easily parse the raw JSON response to its equivalent types in just a few lines of code in <code>GitHub.fs</code>!</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"> <a href="#n1" name="n1">1</a></span>module GitHub
<span class="line-numbers"> <a href="#n2" name="n2">2</a></span>
<span class="line-numbers"> <a href="#n3" name="n3">3</a></span>open Http
<span class="line-numbers"> <a href="#n4" name="n4">4</a></span>open FSharp.Data
<span class="line-numbers"> <a href="#n5" name="n5">5</a></span>
<span class="line-numbers"> <a href="#n6" name="n6">6</a></span>type GitHubUser = JsonProvider&lt;&quot;user.json&quot;&gt;
<span class="line-numbers"> <a href="#n7" name="n7">7</a></span>type GitHubUserRepos = JsonProvider&lt;&quot;repos.json&quot;&gt;
<span class="line-numbers"> <a href="#n8" name="n8">8</a></span>
<span class="line-numbers"> <a href="#n9" name="n9">9</a></span>let parseUser = GitHubUser.Parse
<span class="line-numbers"><strong><a href="#n10" name="n10">10</a></strong></span>let parseUserRepos = GitHubUserRepos.Parse
</pre></div>
</div>
</div>

<p>As <code>GitHub.fs</code> is an abstraction of GitHub let’s put their URLs also here in the same file</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"><a href="#n1" name="n1">1</a></span>let host = &quot;https://api.github.com&quot;
<span class="line-numbers"><a href="#n2" name="n2">2</a></span>let userUrl = sprintf &quot;%s/users/%s&quot; host
<span class="line-numbers"><a href="#n3" name="n3">3</a></span>let reposUrl = sprintf &quot;%s/users/%s/repos&quot; host
<span class="line-numbers"><a href="#n4" name="n4">4</a></span>let languagesUrl repoName userName = sprintf &quot;%s/repos/%s/%s/languages&quot; host userName repoName
</pre></div>
</div>
</div>
<p>We have used <a href="http://fsharpforfunandprofit.com/posts/partial-application">partial application</a> of function <code>sprintf</code> in the <code>userUrl</code> and <code>reposUrl</code> function here, so both of these functions take username as its parameter implicitly</p>

<p>The JSON response of <a href="https://api.github.com/repos/tamizhvendan/fsharp-phonecat/languages">languages</a> API is little tricky to parse as its keys are dynamic. The type provider will work only if the underlying response has a fixed schema. So, we can’t use the type provider directly to parse the response of languages API.</p>

<p>We are going to use the inbuilt <a href="http://fsharp.github.io/FSharp.Data/library/JsonValue.html">JSON Parser</a> available with JsonTypeProvider to parse the languages response</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"><a href="#n1" name="n1">1</a></span>let parseLanguages languagesJson =
<span class="line-numbers"><a href="#n2" name="n2">2</a></span>  languagesJson
<span class="line-numbers"><a href="#n3" name="n3">3</a></span>  |&gt; JsonValue.Parse
<span class="line-numbers"><a href="#n4" name="n4">4</a></span>  |&gt; JsonExtensions.Properties
<span class="line-numbers"><a href="#n5" name="n5">5</a></span>  |&gt; Array.map fst
</pre></div>
</div>
</div>

<p>The <code>JsonValue.Parse</code> parses the raw string JSON to a type called <code>JsonValue</code> and the <code>JsonExtensions.Properties</code> function takes a <code>JsonValue</code> and returns the key and value pairs of all the properties in the JSON as tuples. As we are interested only in the Keys here, we just pluck that value alone using the function <code>fst</code></p>

<p>Great! Now we are done with parsing the JSON response of all the three APIs and creating it’s equivalent types. The next step is doing some business transformation</p>

<p>One of the requirements of the Profile Screen is that we need to show only the top 3 popular repositories based on the stars received by the repository. Let’s implement it</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"> <a href="#n1" name="n1">1</a></span>let popularRepos (repos : GitHubUserRepos.Root []) =
<span class="line-numbers"> <a href="#n2" name="n2">2</a></span>  let ownRepos = repos |&gt; Array.filter (fun repo -&gt; not repo.Fork)
<span class="line-numbers"> <a href="#n3" name="n3">3</a></span>  let takeCount = if ownRepos.Length &gt; 3 then 3 else repos.Length
<span class="line-numbers"> <a href="#n4" name="n4">4</a></span>
<span class="line-numbers"> <a href="#n5" name="n5">5</a></span>  ownRepos
<span class="line-numbers"> <a href="#n6" name="n6">6</a></span>  |&gt; Array.sortBy (fun r -&gt; -r.StargazersCount)
<span class="line-numbers"> <a href="#n7" name="n7">7</a></span>  |&gt; Array.toSeq
<span class="line-numbers"> <a href="#n8" name="n8">8</a></span>  |&gt; Seq.take takeCount
<span class="line-numbers"> <a href="#n9" name="n9">9</a></span>  |&gt; Seq.toArray
</pre></div>
</div>
</div>

<p>In the <code>Http.fs</code> file, we defined how to get the raw JSON response using Stream as <code>HttpResponse</code> (<code>Ok</code> &amp; <code>Error</code>) and in this <code>GitHub.fs</code>, we have defined how to parse this raw JSON response and transform them its equivalent strongly types.</p>

<p>The final step is integrating both these logic and return the Output record type needed by the Profile Screen</p>

<p>let’s start by defining the Profile type</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"> <a href="#n1" name="n1">1</a></span>type Profile = {
<span class="line-numbers"> <a href="#n2" name="n2">2</a></span>  Name : string
<span class="line-numbers"> <a href="#n3" name="n3">3</a></span>  AvatarUrl : string
<span class="line-numbers"> <a href="#n4" name="n4">4</a></span>  PopularRepositories : Repository seq
<span class="line-numbers"> <a href="#n5" name="n5">5</a></span>} and Repository = {
<span class="line-numbers"> <a href="#n6" name="n6">6</a></span>  Name : string
<span class="line-numbers"> <a href="#n7" name="n7">7</a></span>  Stars : int
<span class="line-numbers"> <a href="#n8" name="n8">8</a></span>  Languages : string[]
<span class="line-numbers"> <a href="#n9" name="n9">9</a></span>}
</pre></div>
</div>
</div>
<p>Then write functions to get the value from <code>HttpResponse</code> and create this profile output.</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"> <a href="#n1" name="n1">1</a></span>let reposResponseToPopularRepos = function
<span class="line-numbers"> <a href="#n2" name="n2">2</a></span>  |Ok(r) -&gt; r |&gt; parseUserRepos |&gt; popularRepos
<span class="line-numbers"> <a href="#n3" name="n3">3</a></span>  |_ -&gt; [||]
<span class="line-numbers"> <a href="#n4" name="n4">4</a></span>
<span class="line-numbers"> <a href="#n5" name="n5">5</a></span>// Languages always associated with a repository
<span class="line-numbers"> <a href="#n6" name="n6">6</a></span>let languageResponseToRepoWithLanguages (repo : GitHubUserRepos.Root) = function
<span class="line-numbers"> <a href="#n7" name="n7">7</a></span>  |Ok(l) -&gt; {Name = repo.Name; Languages = (parseLanguages l); Stars = repo.StargazersCount}
<span class="line-numbers"> <a href="#n8" name="n8">8</a></span>  |_ -&gt; {Name = repo.Name; Languages = Array.empty; Stars = repo.StargazersCount}
<span class="line-numbers"> <a href="#n9" name="n9">9</a></span>
<span class="line-numbers"><strong><a href="#n10" name="n10">10</a></strong></span>let toProfile  = function
<span class="line-numbers"><a href="#n11" name="n11">11</a></span>  |Ok(u), repos -&gt;
<span class="line-numbers"><a href="#n12" name="n12">12</a></span>      let user = parseUser u
<span class="line-numbers"><a href="#n13" name="n13">13</a></span>      {Name = user.Name; PopularRepositories = repos; AvatarUrl = user.AvatarUrl} |&gt; Some
<span class="line-numbers"><a href="#n14" name="n14">14</a></span>  | _ -&gt; None
</pre></div>
</div>
</div>

<p>All the above functions except <code>toProfile</code> take <code>HttpResponse</code> as its last parameter implicitly.</p>

<p>In <code>reposResponseToPopularRepos</code> function, if the repos API request is successful, we parse the response to its equivalent type and then pick only three of them based on star count and in the case of an error we just return an empty array.</p>

<p>The <code>languageResponseToRepoWithLanguages</code> function handles the response from the Languages API request which takes its associated repository as its first parameter. If the response is successful, then it creates the <code>Repository</code> record with the returned languages else it just the <code>Repository</code> record with an empty array for languages.</p>

<p>The last function <code>toProfile</code> is a merge function which takes a tuple of <code>HttpResponse</code> (of User API request) and <code>Repository []</code> and creates a <code>Profile</code> record if the response is successful. In case of an error, it just returns <code>None</code></p>

<p><em>Note: To keep this blog post simple, I am handling the errors using empty arrays and None. It can be extended using <a href="http://fsharpforfunandprofit.com/rop/">ROP</a></em></p>

<h2 id="implementing-api-gateway">Implementing API Gateway</h2>

<p>Let me quickly summarize what we have done so far. We have created two abstractions.</p>

<ul>
  <li><code>Http</code> - Responsible for firing the HTTP GET request with the given URL and give the response as a Rx Stream</li>
</ul>

<pre><code>URL
  \
----------Response--|

</code></pre>

<ul>
  <li><code>GitHub</code> - Takes care of parsing the JSON response from GitHub API and does some business logic (finding top 3 popular repositories). Then returns the output in the format that the Client needs.</li>
</ul>

<p>With the help of these abstractions now we are going to build the API Gateway to get the profile object.</p>

<p>Open <code>Gateway.fs</code> and add the <code>getProfile</code> function</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"><a href="#n1" name="n1">1</a></span>//string -&gt; Async&lt;Profile&gt;
<span class="line-numbers"><a href="#n2" name="n2">2</a></span>let getProfile username =
<span class="line-numbers"><a href="#n3" name="n3">3</a></span>  async {
<span class="line-numbers"><a href="#n4" name="n4">4</a></span>    // TODO
<span class="line-numbers"><a href="#n5" name="n5">5</a></span>    return! profile
<span class="line-numbers"><a href="#n6" name="n6">6</a></span>  }
</pre></div>
</div>
</div>
<p>It is just a skeleton which just describes the what function does. Let’s start its implementation.</p>

<p>In Rx world, everything is a stream. So, the first step is converting GitHub User API request to stream</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"><a href="#n1" name="n1">1</a></span>let getProfile username =
<span class="line-numbers"><a href="#n2" name="n2">2</a></span>  // ...
<span class="line-numbers"><a href="#n3" name="n3">3</a></span>  let userStream = username |&gt; userUrl |&gt; asyncResponseToObservable
<span class="line-numbers"><a href="#n4" name="n4">4</a></span>  // ...
</pre></div>
</div>
</div>

<p>We have created the <code>userStream</code> using the <code>userUrl</code> and <code>asyncResponseToObservable</code> function defined earlier.</p>

<pre><code>userURL
  \
-----------UJ--|              // UJ - GitHub User Response in JSON format
</code></pre>

<p>Then we need top three popular repositories as a stream</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"><a href="#n1" name="n1">1</a></span>let getProfile username =
<span class="line-numbers"><a href="#n2" name="n2">2</a></span>  // ...
<span class="line-numbers"><a href="#n3" name="n3">3</a></span>  let popularReposStream =
<span class="line-numbers"><a href="#n4" name="n4">4</a></span>    username
<span class="line-numbers"><a href="#n5" name="n5">5</a></span>    |&gt; reposUrl
<span class="line-numbers"><a href="#n6" name="n6">6</a></span>    |&gt; asyncResponseToObservable
<span class="line-numbers"><a href="#n7" name="n7">7</a></span>    |&gt; Observable.map reposResponseToPopularRepos
<span class="line-numbers"><a href="#n8" name="n8">8</a></span>  // ...
</pre></div>
</div>
</div>

<p>Except the last line, everything is same as that of creating <code>userStream</code>. If you check <a href="https://api.github.com/users/tamizhvendan/repos">GitHub repos API</a> it just returns all the repos associated with the given username. But what we need is only top three of them based on the number of stars it has received.</p>

<p>We already have a function <code>reposResponseToPopularRepos</code> in <code>GitHub.fs</code> which does the job of picking the top three repos from the raw JSON. As the response is in the form Rx stream, we need to get the value from the stream and then we need to apply this function and that’s what the <code>Observable.map</code> does. It is very similar to <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/map">Array.map</a> and <a href="https://msdn.microsoft.com/en-us/library/system.linq.enumerable.select(v=vs.100).aspx">LINQ Select</a></p>

<pre><code>reposURL
  \
----------RJ---|                          // RJ - GitHub user repos in JSON format
          | MAP function (RJ -&gt; PR)       // PR - Popular Repos
          V
--------------PR---|
</code></pre>

<p>The next operation is a little complex. i.e. finding out the programming languages being used in these popular repositories. To get this GitHub API, we need to fire three separate requests to the <a href="https://developer.github.com/v3/repos/#list-languages">Languages API</a> for each repository and then merge the results back with the corresponding repository.</p>

<p>To implement this with the help of Rx streams, we need to understand the <code>flatMap</code> <a href="http://reactivex.io/documentation/operators/flatmap.html">function of Rx</a>.</p>

<p>It is similar to the <code>map</code> function that we have seen before with a difference that it takes a function that returns a new item stream instead of a new item.</p>

<h3 id="map">Map</h3>

<p><img src="http://reactivex.io/documentation/operators/images/map.c.png" alt="Map" /></p>

<p>The <code>map</code> function has the following signature</p>

<pre><code>('a -&gt; 'b) -&gt; IObservable&lt;'a&gt; -&gt; IObservable&lt;'b&gt;
</code></pre>

<h3 id="flatmap">FlatMap</h3>

<p><img src="http://reactivex.io/documentation/operators/images/flatMap.c.png" alt="FlatMap" /></p>

<p>The <code>flatMap</code> function has the following signature</p>

<pre><code>('a -&gt; IObservable&lt;'b&gt;) -&gt; IObservable&lt;'a&gt; -&gt; IObservable&lt;'b&gt;
</code></pre>

<p>This function is also called as <code>bind</code> function in the functional programming world. If you would like to know further on this topic, I strongly recommend <a href="http://fsharpforfunandprofit.com/posts/elevated-world">this blog series</a> by the fsharp great, <a href="https://twitter.com/ScottWlaschin">Scott Wlaschin</a></p>

<p>Back to the problem in hand, we need to fire three HTTP GET Requests to get back the languages associated with the each of the top three popular repos. In terms of the <code>flatMap</code> function, it boils down to three functions of the following syntax</p>

<pre><code>(GitHubUserRepos.Root -&gt; IObservable&lt;Repostiory&gt;)
  -&gt; IObservable&lt;GitHubUserRepos.Root&gt; -&gt; IObservable&lt;Repostiory&gt;
</code></pre>

<p>We can implement the solution using three <code>flatMap</code> functions using the above syntax. But, we can make it more granular by creating a new variant of <code>flatMap</code> function to achieve this in a more straightforward way.</p>

<p>The ideal function that we are looking for in this <code>flatMap</code> variant holds the following signature</p>

<pre><code>('a -&gt; IObservable&lt;'b&gt;) -&gt; IObservable&lt;'a []&gt; -&gt; IObservable&lt;'b []&gt;
</code></pre>
<p>i.e three <code>flatMap</code> can be rewritten as</p>

<pre><code>(GitHubUserRepos.Root -&gt; IObservable&lt;Repostiory&gt;)
  -&gt; IObservable&lt;GitHubUserRepos.Root []&gt; -&gt; IObservable&lt;Repostiory []&gt;
</code></pre>

<p>Let’s name it as <code>flatMap2</code> and add the implementation of it in the file <code>ObservableExtensions.fs</code></p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"><a href="#n1" name="n1">1</a></span>module ObservableExtensions
<span class="line-numbers"><a href="#n2" name="n2">2</a></span>open FSharp.Control.Reactive
<span class="line-numbers"><a href="#n3" name="n3">3</a></span>
<span class="line-numbers"><a href="#n4" name="n4">4</a></span>let flatmap2 f observable =
<span class="line-numbers"><a href="#n5" name="n5">5</a></span>  observable
<span class="line-numbers"><a href="#n6" name="n6">6</a></span>  |&gt; Observable.flatmap (Array.map f &gt;&gt; Observable.mergeArray)
<span class="line-numbers"><a href="#n7" name="n7">7</a></span>  |&gt; Observable.toArray
</pre></div>
</div>
</div>

<p>Here is the representation of what this function does</p>

<pre><code>-----X[n]--------------------------|-&gt;
      \   flatMap on each item in X which yield the stream of R
-------R1-------------------------|-&gt;
----------R2----------------------|-&gt;
          ......
-------------Rn-------------------|-&gt;
          ||  mergeArray -&gt; merge array of R streams into one stream
          VV
------R1-R2--Rn-------------------|-&gt;
              \ toArray -&gt; Creates an array from an observable sequence
-------------R[n]-----------------|-&gt;
</code></pre>

<p>It’s hard to get it right in a single shot. So, let’s see it in detail step by step by applying it to our use case here</p>

<ul>
  <li>We have the stream of three popular repos (i.e array of repos)</li>
</ul>

<pre><code>-----X[n]--------------------------|-&gt;
</code></pre>
<ul>
  <li>To get the languages associated with the each repo we need to call the languages API for every repo item in the above step</li>
</ul>

<pre><code>-----X[n]--------------------------|-&gt;
      \   flatMap on each item in X which yield the n streams of R
-------R1-------------------------|-&gt;
----------R2----------------------|-&gt;
          ......
-------------Rn-------------------|-&gt;
</code></pre>
<ul>
  <li>After we received the response from each languages API call, we need to merge them into one stream</li>
</ul>

<pre><code>-------R1-------------------------|-&gt;
----------R2----------------------|-&gt;
          ......
-------------Rn-------------------|-&gt;
          |  mergeArray -&gt; merge array of R streams into one stream
          V
------R1-R2--Rn-------------------|-&gt;
</code></pre>

<ul>
  <li>To integrate this with the expected application response, we need all the responses in a single go</li>
</ul>

<pre><code>------R1-R2--Rn-------------------|-&gt;
              \ toArray -&gt; Creates an array from an observable sequence
-------------R[n]-----------------|-&gt;
</code></pre>

<p>Great! You got it right!!</p>

<p>Let’s use this <code>flatMap2</code> function and complete the implementation of profile API gateway.</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"> <a href="#n1" name="n1">1</a></span>let getProfile username =
<span class="line-numbers"> <a href="#n2" name="n2">2</a></span>  // ...
<span class="line-numbers"> <a href="#n3" name="n3">3</a></span>  let toRepoWithLanguagesStream (repo : GitHubUserRepos.Root) =    
<span class="line-numbers"> <a href="#n4" name="n4">4</a></span>    username
<span class="line-numbers"> <a href="#n5" name="n5">5</a></span>    |&gt; languagesUrl repo.Name
<span class="line-numbers"> <a href="#n6" name="n6">6</a></span>    |&gt; asyncResponseToObservable
<span class="line-numbers"> <a href="#n7" name="n7">7</a></span>    |&gt; Observable.map (languageResponseToRepoWithLanguages repo)
<span class="line-numbers"> <a href="#n8" name="n8">8</a></span>
<span class="line-numbers"> <a href="#n9" name="n9">9</a></span>  let popularReposStream =
<span class="line-numbers"><strong><a href="#n10" name="n10">10</a></strong></span>    username
<span class="line-numbers"><a href="#n11" name="n11">11</a></span>    |&gt; reposUrl
<span class="line-numbers"><a href="#n12" name="n12">12</a></span>    |&gt; asyncResponseToObservable
<span class="line-numbers"><a href="#n13" name="n13">13</a></span>    |&gt; Observable.map reposResponseToPopularRepos
<span class="line-numbers"><a href="#n14" name="n14">14</a></span>    |&gt; flatmap2 toRepoWithLanguagesStream
<span class="line-numbers"><a href="#n15" name="n15">15</a></span>
<span class="line-numbers"><a href="#n16" name="n16">16</a></span>  // ...
</pre></div>
</div>
</div>

<p>The <code>flatmap2</code> function takes the function <code>toRepoWithLanguagesStream</code> which converts the <code>GitHubUserRepos.Root</code> type to <code>IObservable&lt;Repository&gt;</code> to find out the languages associated with the given popular repositories.</p>

<p>The <code>toRepoWithLanguagesStream</code> function does the following</p>

<pre><code>GitHubUserRepos.Root
  \ create a languages GitHub API stream using the repo name from the input
-------LR----------|              // LR - languages GitHub API response
        \ MAP function (GitHubUserRepos.Root -&gt; LR -&gt; R)
------------R------|              // R - Repository type that defined earlier
</code></pre>
<p>The <code>Observable.map</code> function takes only one input, but here we need to two inputs. So, With the help of <a href="http://fsharpforfunandprofit.com/posts/partial-application/">partial application</a>, we created an intermediate function by partially applying the first parameter alone</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"><a href="#n1" name="n1">1</a></span>Observable.map (languageResponseToRepoWithLanguages repo)
</pre></div>
</div>
</div>

<p>The <code>languageResponseToRepoWithLanguages</code> function has been already defined in the <code>GitHub.fs</code> file.</p>

<p>The last step of the <code>getProfile</code> function is combining this <code>popularReposStream</code> with the <code>userStream</code> created earlier and return the <code>Profile</code> type asynchronously.</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"> <a href="#n1" name="n1">1</a></span>let getProfile username =
<span class="line-numbers"> <a href="#n2" name="n2">2</a></span>  // ...
<span class="line-numbers"> <a href="#n3" name="n3">3</a></span>  async {
<span class="line-numbers"> <a href="#n4" name="n4">4</a></span>    return! popularReposStream
<span class="line-numbers"> <a href="#n5" name="n5">5</a></span>            |&gt; Observable.zip userStream
<span class="line-numbers"> <a href="#n6" name="n6">6</a></span>            |&gt; Observable.map toProfile
<span class="line-numbers"> <a href="#n7" name="n7">7</a></span>            |&gt; TaskObservableExtensions.ToTask
<span class="line-numbers"> <a href="#n8" name="n8">8</a></span>            |&gt; Async.AwaitTask
<span class="line-numbers"> <a href="#n9" name="n9">9</a></span>  }
<span class="line-numbers"><strong><a href="#n10" name="n10">10</a></strong></span>  // ...
</pre></div>
</div>
</div>

<p>The <code>Observable.zip</code> function takes two streams as its input, then merges the output of each stream and return the output as a tuple. From this tuple, we have used <code>Observable.map</code> function to map it a <code>Profile</code> type using the <code>toProfile</code> function created earlier in <code>GitHub.fs</code></p>

<pre><code>-----UR-------------|     // UR - GitHub User API Response
--------PR----------|     // PR - Popular Repos
        \ ZIP function (UR -&gt; PR -&gt; (UR,PR))   
---------(UR,PR)----|
          \ MAP ( (UR,PR) -&gt; P )  // P - Profile
----------P---------|
</code></pre>

<p>The last functions <code>TaskObservableExtensions.ToTask</code> and <code>Async.AwaitTask</code> does the conversion of <code>IObservable</code> to <code>async</code> by converting it to a <code>Task</code> first and then the <code>Task</code> to <code>async</code></p>

<p>The final <code>getProfile</code> function will be like</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"> <a href="#n1" name="n1">1</a></span>
<span class="line-numbers"> <a href="#n2" name="n2">2</a></span>let getProfile username =
<span class="line-numbers"> <a href="#n3" name="n3">3</a></span>
<span class="line-numbers"> <a href="#n4" name="n4">4</a></span>  let userStream = username |&gt; userUrl |&gt; asyncResponseToObservable
<span class="line-numbers"> <a href="#n5" name="n5">5</a></span>
<span class="line-numbers"> <a href="#n6" name="n6">6</a></span>  let toRepoWithLanguagesStream (repo : GitHubUserRepos.Root) =    
<span class="line-numbers"> <a href="#n7" name="n7">7</a></span>    username
<span class="line-numbers"> <a href="#n8" name="n8">8</a></span>    |&gt; languagesUrl repo.Name
<span class="line-numbers"> <a href="#n9" name="n9">9</a></span>    |&gt; asyncResponseToObservable
<span class="line-numbers"><strong><a href="#n10" name="n10">10</a></strong></span>    |&gt; Observable.map (languageResponseToRepoWithLanguages repo)
<span class="line-numbers"><a href="#n11" name="n11">11</a></span>
<span class="line-numbers"><a href="#n12" name="n12">12</a></span>  let popularReposStream =
<span class="line-numbers"><a href="#n13" name="n13">13</a></span>    username
<span class="line-numbers"><a href="#n14" name="n14">14</a></span>    |&gt; reposUrl
<span class="line-numbers"><a href="#n15" name="n15">15</a></span>    |&gt; asyncResponseToObservable
<span class="line-numbers"><a href="#n16" name="n16">16</a></span>    |&gt; Observable.map reposResponseToPopularRepos
<span class="line-numbers"><a href="#n17" name="n17">17</a></span>    |&gt; flatmap2 toRepoWithLanguagesStream
<span class="line-numbers"><a href="#n18" name="n18">18</a></span>
<span class="line-numbers"><a href="#n19" name="n19">19</a></span>  async {
<span class="line-numbers"><strong><a href="#n20" name="n20">20</a></strong></span>    return! popularReposStream
<span class="line-numbers"><a href="#n21" name="n21">21</a></span>            |&gt; Observable.zip userStream
<span class="line-numbers"><a href="#n22" name="n22">22</a></span>            |&gt; Observable.map toProfile
<span class="line-numbers"><a href="#n23" name="n23">23</a></span>            |&gt; TaskObservableExtensions.ToTask
<span class="line-numbers"><a href="#n24" name="n24">24</a></span>            |&gt; Async.AwaitTask
<span class="line-numbers"><a href="#n25" name="n25">25</a></span>  }
</pre></div>
</div>
</div>

<p>This function is a testimonial on <em>How functional programming helps to write less, robust, and readable code to solve a complex problem</em></p>

<p>We have handled all the five HTTP requests asynchronously, did some error handling (by returning empty types), and finally efficiently combined outputs of these five HTTP requests and created a type to send back to the client. Everything is asynchronous!</p>

<p>Pretty awesome isn’t it?</p>

<h2 id="exposing-the-api">Exposing the API</h2>

<p>The final step is exposing what we have done so far as an API to the outside world. We are going to implement this using <a href="https://suave.io/">Suave</a></p>

<p>Open <code>ApiGateway.fs</code> file and update it as below</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"> <a href="#n1" name="n1">1</a></span>let JSON v =  
<span class="line-numbers"> <a href="#n2" name="n2">2</a></span>  let jsonSerializerSettings = new JsonSerializerSettings()
<span class="line-numbers"> <a href="#n3" name="n3">3</a></span>  jsonSerializerSettings.ContractResolver &lt;- new CamelCasePropertyNamesContractResolver()
<span class="line-numbers"> <a href="#n4" name="n4">4</a></span>
<span class="line-numbers"> <a href="#n5" name="n5">5</a></span>  JsonConvert.SerializeObject(v, jsonSerializerSettings)
<span class="line-numbers"> <a href="#n6" name="n6">6</a></span>  |&gt; OK
<span class="line-numbers"> <a href="#n7" name="n7">7</a></span>  &gt;=&gt; Writers.setMimeType &quot;application/json; charset=utf-8&quot;
<span class="line-numbers"> <a href="#n8" name="n8">8</a></span>
<span class="line-numbers"> <a href="#n9" name="n9">9</a></span>let getProfile userName (httpContext : HttpContext) =
<span class="line-numbers"><strong><a href="#n10" name="n10">10</a></strong></span>   async {
<span class="line-numbers"><a href="#n11" name="n11">11</a></span>      let! profile = getProfile userName
<span class="line-numbers"><a href="#n12" name="n12">12</a></span>      match profile with
<span class="line-numbers"><a href="#n13" name="n13">13</a></span>      | Some p -&gt; return! JSON p httpContext
<span class="line-numbers"><a href="#n14" name="n14">14</a></span>      | None -&gt; return! NOT_FOUND (sprintf &quot;Username %s not found&quot; userName) httpContext
<span class="line-numbers"><a href="#n15" name="n15">15</a></span>   }
</pre></div>
</div>
</div>

<p>The <code>JSON</code> is a utility function (WebPart in the world of Suave) which takes any type, serialize it to JSON format and return it as JSON HTTP response.</p>

<p>The <code>getProfile</code> function is the API WebPart which calls our backend API gateway implementation and pass the received response to the <code>JSON</code> WebPart defined before.</p>

<p>In case if there is no profile available (Remember? we return empty types in case of errors), we just return <code>404</code> with the message that the given username is not found.</p>

<p>Then update the <code>Program.fs</code> to write the web server code</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"><a href="#n1" name="n1">1</a></span>[&lt;EntryPoint&gt;]
<span class="line-numbers"><a href="#n2" name="n2">2</a></span>let main argv =
<span class="line-numbers"><a href="#n3" name="n3">3</a></span>  let webpart = pathScan &quot;/api/profile/%s&quot; ApiGateway.getProfile
<span class="line-numbers"><a href="#n4" name="n4">4</a></span>  startWebServer defaultConfig webpart
<span class="line-numbers"><a href="#n5" name="n5">5</a></span>  0
</pre></div>
</div>
</div>

<p>Thanks to <code>Suave</code> for it’s lightweight and low-ceremony offerings in creating an API. We just exposed it in two lines!</p>

<p>Hit <code>F5</code> and access the API at <code>http://localhost:8083/api/profile/{github-username}</code> Bingo!!</p>

<h2 id="summary">Summary</h2>

<blockquote>
  <p>A language that doesn’t affect the way you think about programming is not worth knowing - Alan Perils</p>
</blockquote>

<p>The above quote summarizes the gist of this blog post. Functional Programming will help you think better. You can get the source code associated with the blog post in my <a href="https://github.com/tamizhvendan/blog-samples/tree/master/RxFsharp">blog-samples GitHub repository</a></p>

<p>Wish you a happy and prosperous new year</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Creating Mock API server in fsharp using Suave]]></title>
    <link href="http://blog.tamizhvendan.in/blog/2015/07/23/creating-mock-api-server-in-fsharp-using-suave/"/>
    <updated>2015-07-23T16:56:20+05:30</updated>
    <id>http://blog.tamizhvendan.in/blog/2015/07/23/creating-mock-api-server-in-fsharp-using-suave</id>
    <content type="html"><![CDATA[<p>As part of the current assignment in my day job, I am working in a web application which integrates with an another web application via web APIs. The backend calls the exposed web APIs and does some business logic. Due to some technical limitations, we are not able to setup a development environment of the Web APIs so we have decided to create a mock API server during the development and replace it with the real one in the production.</p>

<p>Since it’s just a mock API server, we don’t want to spend much time on it. Thanks to the awesome light-weight fsharp library <a href="http://suave.io/">Suave</a> we have made it in just 15 minutes!</p>

<p>In this blog post, I will be sharing how we have achieved it. As a sample, we will mock the <a href="https://developer.GitHub.com/v3/">GitHub API</a>.</p>

<h2 id="getting-started">Getting Started</h2>

<p>Create a new fsharp console application project “GitHubMockApiServer” in Visual Studio and install the <a href="https://www.nuget.org/packages/Suave/">suave</a> nuget package.</p>

<p>To keep it short we are going to mock only two GitHub APIs</p>

<ul>
  <li><a href="https://developer.GitHub.com/v3/users/#get-a-single-user">Get a single user</a> - <strong>/users/:username</strong></li>
  <li><a href="https://developer.GitHub.com/v3/repos/#list-user-repositories">List user repositories</a> - <strong>/users/:username/repos</strong></li>
</ul>

<h2 id="creating-the-mock-apis">Creating the mock APIs</h2>

<p>The first step is getting the sample response for these APIs and save them in separate JSON files. In this example, I’ve created these using my GitHub username and added to the project as below.</p>

<p><img class="center" src="/images/suave_mock_api/project.png"></p>

<p>After adding, change the “Copy to Output Directory” property of the both the files to “Copy always”</p>

<p>Open the <strong>Program.fs</strong> and update it as follows</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"> <a href="#n1" name="n1">1</a></span>open Suave
<span class="line-numbers"> <a href="#n2" name="n2">2</a></span>open Suave.Operators
<span class="line-numbers"> <a href="#n3" name="n3">3</a></span>open Suave.Successful
<span class="line-numbers"> <a href="#n4" name="n4">4</a></span>open Suave.Filters
<span class="line-numbers"> <a href="#n5" name="n5">5</a></span>open System.IO
<span class="line-numbers"> <a href="#n6" name="n6">6</a></span>
<span class="line-numbers"> <a href="#n7" name="n7">7</a></span>[&lt;EntryPoint&gt;]
<span class="line-numbers"> <a href="#n8" name="n8">8</a></span>let main argv =
<span class="line-numbers"> <a href="#n9" name="n9">9</a></span>  let json fileName =
<span class="line-numbers"><strong><a href="#n10" name="n10">10</a></strong></span>    let content = File.ReadAllText fileName  
<span class="line-numbers"><a href="#n11" name="n11">11</a></span>    content.Replace(&quot;\r&quot;, &quot;&quot;).Replace(&quot;\n&quot;,&quot;&quot;)
<span class="line-numbers"><a href="#n12" name="n12">12</a></span>    |&gt; OK &gt;=&gt; Writers.setMimeType &quot;application/json&quot;      
<span class="line-numbers"><a href="#n13" name="n13">13</a></span>
<span class="line-numbers"><a href="#n14" name="n14">14</a></span>  let user = pathScan &quot;/users/%s&quot; (fun _ -&gt; &quot;User.json&quot; |&gt; json)  
<span class="line-numbers"><a href="#n15" name="n15">15</a></span>  let repos = pathScan &quot;/users/%s/repos&quot; (fun _ -&gt; &quot;Repos.json&quot; |&gt; json)
<span class="line-numbers"><a href="#n16" name="n16">16</a></span>  let mockApi = choose [repos;user]
<span class="line-numbers"><a href="#n17" name="n17">17</a></span>
<span class="line-numbers"><a href="#n18" name="n18">18</a></span>  startWebServer defaultConfig mockApi          
<span class="line-numbers"><a href="#n19" name="n19">19</a></span>  0
</pre></div>
</div>
</div>

<p>Short and Sweet! Now you can hit this mock GitHub APIs without worrying about its <a href="https://developer.GitHub.com/v3/#rate-limiting">rate limits</a></p>

<p>The <code>json</code> function reads the sample JSON file, then removes the line breaks and return the HTTP 200 response with the content type as  “application/json”</p>

<p>The nice DSL in suave enabled us to configure the routes without giving much works to our hands :-)  </p>

<h2 id="mock-apis-in-action">Mock APIs in action</h2>

<p><img class="border center" src="/images/suave_mock_api/user_api.png"></p>

<p><img class="border center" src="/images/suave_mock_api/repos_api.png"></p>

<h2 id="summary">Summary</h2>

<p>This work is inspired by Scott Wlaschin’s blog post series on <a href="http://fsharpforfunandprofit.com/series/low-risk-ways-to-use-fsharp-at-work.html">Low-risk ways to use F# at work</a>. I am glad to find one more low-risk way to use F# at work and I believe it would help you in future. You can find the sample code in my <a href="https://github.com/tamizhvendan/blog-samples/tree/master/GithubMockApiServer">blog-samples GitHub repository</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Securing APIs in Suave using JSON Web Token]]></title>
    <link href="http://blog.tamizhvendan.in/blog/2015/07/15/securing-apis-in-suave-using-json-web-token/"/>
    <updated>2015-07-15T12:04:12+05:30</updated>
    <id>http://blog.tamizhvendan.in/blog/2015/07/15/securing-apis-in-suave-using-json-web-token</id>
    <content type="html"><![CDATA[<p>In the <a href="/blog/2015/06/11/building-rest-api-in-fsharp-using-suave/">last blog post</a>, we have seen how we can combine small functions to create a REST API in Suave and in this blog post we are going to see how can we secure the APIs using JSON web tokens(JWT).</p>

<p>This blog post is based on <a href="http://bitoftech.net/">Taiseer’s</a> blog post on <a href="http://bitoftech.net/2014/10/27/json-web-token-asp-net-web-api-2-jwt-owin-authorization-server/">JSON Web Token in ASP.NET Web API 2 using Owin</a> and I will be covering how to implement the same in <a href="http://suave.io">Suave</a>. If you are interested in the theoretical background of JWT, kindly read his blog post before reading this.</p>

<h2 id="workflow">Workflow</h2>

<p>The typical workflow of JWT based application would look like this</p>

<ol>
  <li>New Audience (Resource Server) gets registered with Authorization Server.</li>
  <li>Get the JWT access token from Authorization Server by passing Client Id of the resource server and login credentials</li>
  <li>Use the access token obtained above to get access to the secured resources in the resource server</li>
</ol>

<p>We are going to see how to implement all these three steps in this blog post</p>

<h2 id="project-setup">Project Setup</h2>

<p>Create an empty visual studio solution and add new projects with the following name</p>

<ul>
  <li>SuaveJwt - A fsharp library project which contains all the JWT related things</li>
  <li>SuaveJwt.AuthServerHost - A fsharp console application which is going to host the authorization server</li>
  <li>Audience1 - A fsharp console application representing the resource server 1   </li>
  <li>Audience2 - A fsharp console application representing the resource server 2   </li>
</ul>

<p>After creating, install the following NuGet packages</p>

<ul>
  <li><a href="https://www.nuget.org/packages/Suave/">Suave</a> in all the four projects</li>
  <li><a href="https://www.nuget.org/packages/Newtonsoft.Json/">Newtonsoft.Json</a> and <a href="https://www.nuget.org/packages/System.IdentityModel.Tokens.Jwt/">JSON Web Token Handler</a> in <em>SuaveJwt</em></li>
</ul>

<p>Then add reference the .NET framework library <strong>System.IdentityModel</strong> in all the four projects from GAC and then add a reference to the <strong>SuaveJwt</strong> project library in all the other three projects.</p>

<p><img class="center" src="/images/suave_jwt/project_structure.png"></p>

<h2 id="new-audience-registration">New Audience Registration</h2>

<p>As we have seen in the workflow, the first step is to enable an audience to register itself with the authorization server. Let’s begin by defining the business logic.</p>

<p>Add a new source file <em>JwtToken.fs</em> in the <strong>SuaveJwt</strong> project and update it as follows</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"> <a href="#n1" name="n1">1</a></span>type Audience = {
<span class="line-numbers"> <a href="#n2" name="n2">2</a></span>  ClientId : string
<span class="line-numbers"> <a href="#n3" name="n3">3</a></span>  Secret : Base64String
<span class="line-numbers"> <a href="#n4" name="n4">4</a></span>  Name : string
<span class="line-numbers"> <a href="#n5" name="n5">5</a></span>}
<span class="line-numbers"> <a href="#n6" name="n6">6</a></span>
<span class="line-numbers"> <a href="#n7" name="n7">7</a></span>// string -&gt; Audience
<span class="line-numbers"> <a href="#n8" name="n8">8</a></span>let createAudience audienceName =
<span class="line-numbers"> <a href="#n9" name="n9">9</a></span>  let clientId = Guid.NewGuid().ToString(&quot;N&quot;)
<span class="line-numbers"><strong><a href="#n10" name="n10">10</a></strong></span>  let data = Array.zeroCreate 32
<span class="line-numbers"><a href="#n11" name="n11">11</a></span>  RNGCryptoServiceProvider.Create().GetBytes(data)
<span class="line-numbers"><a href="#n12" name="n12">12</a></span>  let secret = data |&gt; Base64String.create
<span class="line-numbers"><a href="#n13" name="n13">13</a></span>  {ClientId = clientId; Secret = secret; Name =  audienceName}
</pre></div>
</div>
</div>

<p>The above snippet creates an audience record with a random client id and secret key. The secret key is of type <a href="https://en.wikipedia.org/wiki/Base64#URL_applications">base64 URL encoded</a> string. This type doesn’t exist, so let’s create it.</p>

<p>Add a new source file <em>Encodings.fs</em> in the <strong>SuaveJwt</strong> project and add this type</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"> <a href="#n1" name="n1">1</a></span>type Base64String = private Base64String of string with
<span class="line-numbers"> <a href="#n2" name="n2">2</a></span>
<span class="line-numbers"> <a href="#n3" name="n3">3</a></span>  static member decode (base64String : Base64String) =
<span class="line-numbers"> <a href="#n4" name="n4">4</a></span>    let (Base64String text) = base64String
<span class="line-numbers"> <a href="#n5" name="n5">5</a></span>    let pad text =
<span class="line-numbers"> <a href="#n6" name="n6">6</a></span>      let padding = 3 - ((String.length text + 3) % 4)
<span class="line-numbers"> <a href="#n7" name="n7">7</a></span>      if padding = 0 then text else (text + new String('=', padding))
<span class="line-numbers"> <a href="#n8" name="n8">8</a></span>
<span class="line-numbers"> <a href="#n9" name="n9">9</a></span>    Convert.FromBase64String(pad(text.Replace('-', '+').Replace('_', '/')))
<span class="line-numbers"><strong><a href="#n10" name="n10">10</a></strong></span>
<span class="line-numbers"><a href="#n11" name="n11">11</a></span>  static member create data =
<span class="line-numbers"><a href="#n12" name="n12">12</a></span>    Convert.ToBase64String(data)
<span class="line-numbers"><a href="#n13" name="n13">13</a></span>      .TrimEnd('=')
<span class="line-numbers"><a href="#n14" name="n14">14</a></span>      .Replace('+', '-')
<span class="line-numbers"><a href="#n15" name="n15">15</a></span>      .Replace('/', '_') |&gt; Base64String;
<span class="line-numbers"><a href="#n16" name="n16">16</a></span>
<span class="line-numbers"><a href="#n17" name="n17">17</a></span>
<span class="line-numbers"><a href="#n18" name="n18">18</a></span>  static member fromString = Base64String
<span class="line-numbers"><a href="#n19" name="n19">19</a></span>
<span class="line-numbers"><strong><a href="#n20" name="n20">20</a></strong></span>  override this.ToString() =
<span class="line-numbers"><a href="#n21" name="n21">21</a></span>    let (Base64String str) = this
<span class="line-numbers"><a href="#n22" name="n22">22</a></span>    str
</pre></div>
</div>
</div>

<p>To keep things simple, I haven’t added any validations here. The next step is to create a Suave <em>WebPart</em> to expose the audience create functionality.</p>

<p>Add a new source file <em>AuthServer.fs</em> in the <strong>SuaveJwt</strong> project and update it as below</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"> <a href="#n1" name="n1">1</a></span>type AudienceCreateRequest = {
<span class="line-numbers"> <a href="#n2" name="n2">2</a></span>  Name : string
<span class="line-numbers"> <a href="#n3" name="n3">3</a></span>}
<span class="line-numbers"> <a href="#n4" name="n4">4</a></span>
<span class="line-numbers"> <a href="#n5" name="n5">5</a></span>type AudienceCreateResponse = {
<span class="line-numbers"> <a href="#n6" name="n6">6</a></span>  ClientId : string
<span class="line-numbers"> <a href="#n7" name="n7">7</a></span>  Base64Secret : string
<span class="line-numbers"> <a href="#n8" name="n8">8</a></span>  Name : string
<span class="line-numbers"> <a href="#n9" name="n9">9</a></span>}
<span class="line-numbers"><strong><a href="#n10" name="n10">10</a></strong></span>
<span class="line-numbers"><a href="#n11" name="n11">11</a></span>type Config = {
<span class="line-numbers"><a href="#n12" name="n12">12</a></span>  AddAudienceUrlPath : string  
<span class="line-numbers"><a href="#n13" name="n13">13</a></span>  SaveAudience : Audience -&gt; Async&lt;Audience&gt;
<span class="line-numbers"><a href="#n14" name="n14">14</a></span>}
<span class="line-numbers"><a href="#n15" name="n15">15</a></span>
<span class="line-numbers"><a href="#n16" name="n16">16</a></span>let audienceWebPart config =
<span class="line-numbers"><a href="#n17" name="n17">17</a></span>
<span class="line-numbers"><a href="#n18" name="n18">18</a></span>  let toAudienceCreateResponse (audience : Audience) = {
<span class="line-numbers"><a href="#n19" name="n19">19</a></span>    Base64Secret = audience.Secret.ToString()
<span class="line-numbers"><strong><a href="#n20" name="n20">20</a></strong></span>    ClientId = audience.ClientId        
<span class="line-numbers"><a href="#n21" name="n21">21</a></span>    Name = audience.Name
<span class="line-numbers"><a href="#n22" name="n22">22</a></span>  }
<span class="line-numbers"><a href="#n23" name="n23">23</a></span>
<span class="line-numbers"><a href="#n24" name="n24">24</a></span>  let tryCreateAudience (ctx: HttpContext) =
<span class="line-numbers"><a href="#n25" name="n25">25</a></span>    match mapJsonPayload&lt;AudienceCreateRequest&gt; ctx.request with
<span class="line-numbers"><a href="#n26" name="n26">26</a></span>    | Some audienceCreateRequest -&gt;
<span class="line-numbers"><a href="#n27" name="n27">27</a></span>        async {
<span class="line-numbers"><a href="#n28" name="n28">28</a></span>          let! audience =
<span class="line-numbers"><a href="#n29" name="n29">29</a></span>            audienceCreateRequest.Name |&gt; createAudience |&gt; config.SaveAudience                     
<span class="line-numbers"><strong><a href="#n30" name="n30">30</a></strong></span>          let audienceCreateResponse = toAudienceCreateResponse audience
<span class="line-numbers"><a href="#n31" name="n31">31</a></span>          return! JSON audienceCreateResponse ctx
<span class="line-numbers"><a href="#n32" name="n32">32</a></span>        }
<span class="line-numbers"><a href="#n33" name="n33">33</a></span>    | None -&gt; BAD_REQUEST &quot;Invalid Audience Create Request&quot; ctx
<span class="line-numbers"><a href="#n34" name="n34">34</a></span>
<span class="line-numbers"><a href="#n35" name="n35">35</a></span>  path config.AddAudienceUrlPath &gt;=&gt; POST &gt;=&gt; tryCreateAudience
</pre></div>
</div>
</div>

<p>The <code>audienceWebPart</code> function retrieves the <code>AudienceCreateRequest</code> from the JSON request payload and creates a new audience.<br />
To make it independent of the host, we have externalized the hosting functionality using the <code>Config</code> record type.</p>

<p>The <code>mapJsonPayload</code> and <code>JSON</code> functions serialize and deserialize JSON objects across the wire respectively. These functions are not part of Suave, so let’s add them</p>

<p>Add a new source file <em>SuaveJson.fs</em> in the <strong>SuaveJwt</strong> project and add these functions</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"> <a href="#n1" name="n1">1</a></span>let JSON v =     
<span class="line-numbers"> <a href="#n2" name="n2">2</a></span>  let jsonSerializerSettings = new JsonSerializerSettings()
<span class="line-numbers"> <a href="#n3" name="n3">3</a></span>  jsonSerializerSettings.ContractResolver &lt;- new CamelCasePropertyNamesContractResolver()
<span class="line-numbers"> <a href="#n4" name="n4">4</a></span>
<span class="line-numbers"> <a href="#n5" name="n5">5</a></span>  JsonConvert.SerializeObject(v, jsonSerializerSettings)
<span class="line-numbers"> <a href="#n6" name="n6">6</a></span>  |&gt; OK
<span class="line-numbers"> <a href="#n7" name="n7">7</a></span>  &gt;=&gt; Writers.setMimeType &quot;application/json; charset=utf-8&quot;
<span class="line-numbers"> <a href="#n8" name="n8">8</a></span>
<span class="line-numbers"> <a href="#n9" name="n9">9</a></span>let mapJsonPayload&lt;'a&gt; (req : HttpRequest) =     
<span class="line-numbers"><strong><a href="#n10" name="n10">10</a></strong></span>  let fromJson json =
<span class="line-numbers"><a href="#n11" name="n11">11</a></span>    try
<span class="line-numbers"><a href="#n12" name="n12">12</a></span>      let obj = JsonConvert.DeserializeObject(json, typeof&lt;'a&gt;) :?&gt; 'a    
<span class="line-numbers"><a href="#n13" name="n13">13</a></span>      Some obj
<span class="line-numbers"><a href="#n14" name="n14">14</a></span>    with
<span class="line-numbers"><a href="#n15" name="n15">15</a></span>    | _ -&gt; None
<span class="line-numbers"><a href="#n16" name="n16">16</a></span>
<span class="line-numbers"><a href="#n17" name="n17">17</a></span>  let getString rawForm =
<span class="line-numbers"><a href="#n18" name="n18">18</a></span>    System.Text.Encoding.UTF8.GetString(rawForm)
<span class="line-numbers"><a href="#n19" name="n19">19</a></span>
<span class="line-numbers"><strong><a href="#n20" name="n20">20</a></strong></span>  req.rawForm |&gt; getString |&gt; fromJson
</pre></div>
</div>
</div>

<p>The next step is hosting this audience web part.</p>

<p>Open the <em>Program.fs</em> file in the <strong>SuaveJwt.AuthServerHost</strong> project and update it as below</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"><a href="#n1" name="n1">1</a></span>let authorizationServerConfig = {
<span class="line-numbers"><a href="#n2" name="n2">2</a></span>  AddAudienceUrlPath = &quot;/api/audience&quot;  
<span class="line-numbers"><a href="#n3" name="n3">3</a></span>  SaveAudience = AudienceStorage.saveAudience
<span class="line-numbers"><a href="#n4" name="n4">4</a></span>}
<span class="line-numbers"><a href="#n5" name="n5">5</a></span>let audienceWebPart' = audienceWebPart authorizationServerConfig
<span class="line-numbers"><a href="#n6" name="n6">6</a></span>startWebServer defaultConfig audienceWebPart'
<span class="line-numbers"><a href="#n7" name="n7">7</a></span>0 // return an integer exit code
</pre></div>
</div>
</div>

<p>It is a straight forward self-host suave server program which exposes the audience web part.</p>

<p>The <em>AudienceStorage</em> is responsible for storing the created audiences and to add it create a new source file <em>AudienceStorage.fs</em> in the <strong>SuaveJwt.AuthServerHost</strong> project and add these functions</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"><a href="#n1" name="n1">1</a></span>module AudienceStorage
<span class="line-numbers"><a href="#n2" name="n2">2</a></span>
<span class="line-numbers"><a href="#n3" name="n3">3</a></span>let private audienceStorage
<span class="line-numbers"><a href="#n4" name="n4">4</a></span>  = new Dictionary&lt;string, Audience&gt;()
<span class="line-numbers"><a href="#n5" name="n5">5</a></span>
<span class="line-numbers"><a href="#n6" name="n6">6</a></span>let saveAudience (audience : Audience) =      
<span class="line-numbers"><a href="#n7" name="n7">7</a></span>    audienceStorage.Add(audience.ClientId, audience)
<span class="line-numbers"><a href="#n8" name="n8">8</a></span>    audience |&gt; async.Return
</pre></div>
</div>
</div>
<p>To keep this simple, we are using in-memory dictionary here and it can be easily replaced with any data store</p>

<p>Now we have everything to create a new audience. So, let’s run the <strong>SuaveJwt.AuthServerHost</strong> application and verify</p>

<p><img class="center" src="/images/suave_jwt/audience_create.png"></p>

<p>Keep a note of this <em>clientId</em> and <em>base64Secret</em> as we will be using them while defining the resource server (“Audience1” in this case).</p>

<h2 id="generating-access-token">Generating Access Token</h2>

<p>After registering an audience with the authorization server, the next step is to get the access token to access the resources in the given resource server.</p>

<p>Let’s begin by defining the business logic to create an access token.</p>

<p><img class="center" src="/images/suave_jwt/createToken.png"></p>

<p>Open <em>JwtToken.fs</em> and add the following types</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"> <a href="#n1" name="n1">1</a></span>type TokenCreateRequest = {         
<span class="line-numbers"> <a href="#n2" name="n2">2</a></span>  Issuer : string        
<span class="line-numbers"> <a href="#n3" name="n3">3</a></span>  UserName : string
<span class="line-numbers"> <a href="#n4" name="n4">4</a></span>  Password : string        
<span class="line-numbers"> <a href="#n5" name="n5">5</a></span>  TokenTimeSpan : TimeSpan
<span class="line-numbers"> <a href="#n6" name="n6">6</a></span>}
<span class="line-numbers"> <a href="#n7" name="n7">7</a></span>
<span class="line-numbers"> <a href="#n8" name="n8">8</a></span>type IdentityStore = {
<span class="line-numbers"> <a href="#n9" name="n9">9</a></span>  getClaims : string -&gt; Async&lt;Claim seq&gt;
<span class="line-numbers"><strong><a href="#n10" name="n10">10</a></strong></span>  isValidCredentials : string -&gt; string -&gt; Async&lt;bool&gt;
<span class="line-numbers"><a href="#n11" name="n11">11</a></span>  getSecurityKey : Base64String -&gt; SecurityKey
<span class="line-numbers"><a href="#n12" name="n12">12</a></span>  getSigningCredentials : SecurityKey -&gt; SigningCredentials
<span class="line-numbers"><a href="#n13" name="n13">13</a></span>}
<span class="line-numbers"><a href="#n14" name="n14">14</a></span>
<span class="line-numbers"><a href="#n15" name="n15">15</a></span>type Token = {
<span class="line-numbers"><a href="#n16" name="n16">16</a></span>  AccessToken : string        
<span class="line-numbers"><a href="#n17" name="n17">17</a></span>  ExpiresIn : float        
<span class="line-numbers"><a href="#n18" name="n18">18</a></span>}
</pre></div>
</div>
</div>

<p>These types are generic abstractions which decouple the token creation part from the underlying host.</p>

<p>The <code>TokenCreateRequest</code> models the underlying issuer and token lifetime.</p>

<p>The <code>IdentityStore</code> represents a generic data store in which the identity information has been stored and it also provides the security key and the signing credentials to protect the access token from misuse.</p>

<p>With these types in place let’s add the <code>createToken</code> function in the <em>SuaveJwt.fs</em> file</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"> <a href="#n1" name="n1">1</a></span>let createToken tokenCreateRequest identityStore audience =
<span class="line-numbers"> <a href="#n2" name="n2">2</a></span>  async {
<span class="line-numbers"> <a href="#n3" name="n3">3</a></span>    let! isValidCredentials =
<span class="line-numbers"> <a href="#n4" name="n4">4</a></span>      identityStore.isValidCredentials tokenCreateRequest.UserName tokenCreateRequest.Password
<span class="line-numbers"> <a href="#n5" name="n5">5</a></span>    if isValidCredentials then                            
<span class="line-numbers"> <a href="#n6" name="n6">6</a></span>      let signingCredentials =
<span class="line-numbers"> <a href="#n7" name="n7">7</a></span>        (identityStore.getSecurityKey &gt;&gt; identityStore.getSigningCredentials) audience.Secret
<span class="line-numbers"> <a href="#n8" name="n8">8</a></span>      let issuedOn = Nullable DateTime.UtcNow
<span class="line-numbers"> <a href="#n9" name="n9">9</a></span>      let expiresBy = Nullable (DateTime.UtcNow.Add(tokenCreateRequest.TokenTimeSpan))       
<span class="line-numbers"><strong><a href="#n10" name="n10">10</a></strong></span>      let! claims =  identityStore.getClaims tokenCreateRequest.UserName
<span class="line-numbers"><a href="#n11" name="n11">11</a></span>      let jwtSecurityToken =
<span class="line-numbers"><a href="#n12" name="n12">12</a></span>        new JwtSecurityToken(tokenCreateRequest.Issuer, audience.ClientId, claims, issuedOn, expiresBy, signingCredentials)
<span class="line-numbers"><a href="#n13" name="n13">13</a></span>      let handler = new JwtSecurityTokenHandler()
<span class="line-numbers"><a href="#n14" name="n14">14</a></span>      let accessToken = handler.WriteToken(jwtSecurityToken)                
<span class="line-numbers"><a href="#n15" name="n15">15</a></span>      return Some {AccessToken = accessToken; ExpiresIn = tokenCreateRequest.TokenTimeSpan.TotalSeconds}
<span class="line-numbers"><a href="#n16" name="n16">16</a></span>    else return None
<span class="line-numbers"><a href="#n17" name="n17">17</a></span>  }
</pre></div>
</div>
</div>

<p>The <code>createToken</code> function checks the validness of the login credentials. If it is valid, then it get the claims associated with the given username and creates a <em>JwtToken</em> using the <a href="https://www.nuget.org/packages/System.IdentityModel.Tokens.Jwt/">JSON Web Token Handler</a> library, else it returns <code>None</code></p>

<p>Now we have got the backend business logic ready, let’s expose it as a suave <em>WebPart</em></p>

<p>Open <em>AuthServer.fs</em> and add a new record type for the incoming token create request and update <code>Config</code> and <code>audienceWebPart</code> as below</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"> <a href="#n1" name="n1">1</a></span>type TokenCreateCredentials = {
<span class="line-numbers"> <a href="#n2" name="n2">2</a></span>  UserName : string
<span class="line-numbers"> <a href="#n3" name="n3">3</a></span>  Password : string
<span class="line-numbers"> <a href="#n4" name="n4">4</a></span>  ClientId : string
<span class="line-numbers"> <a href="#n5" name="n5">5</a></span>}
<span class="line-numbers"> <a href="#n6" name="n6">6</a></span>
<span class="line-numbers"> <a href="#n7" name="n7">7</a></span>type Config = {
<span class="line-numbers"> <a href="#n8" name="n8">8</a></span>  // ... existing fields ...
<span class="line-numbers"> <a href="#n9" name="n9">9</a></span>  CreateTokenUrlPath : string  
<span class="line-numbers"><strong><a href="#n10" name="n10">10</a></strong></span>  GetAudience : string -&gt; Async&lt;Audience option&gt;
<span class="line-numbers"><a href="#n11" name="n11">11</a></span>  Issuer : string
<span class="line-numbers"><a href="#n12" name="n12">12</a></span>  TokenTimeSpan : TimeSpan
<span class="line-numbers"><a href="#n13" name="n13">13</a></span>}
<span class="line-numbers"><a href="#n14" name="n14">14</a></span>
<span class="line-numbers"><a href="#n15" name="n15">15</a></span>let audienceWebPart config identityStore =
<span class="line-numbers"><a href="#n16" name="n16">16</a></span>
<span class="line-numbers"><a href="#n17" name="n17">17</a></span>  // ... existing functions ...
<span class="line-numbers"><a href="#n18" name="n18">18</a></span>
<span class="line-numbers"><a href="#n19" name="n19">19</a></span>  let tryCreateToken (ctx: HttpContext) =
<span class="line-numbers"><strong><a href="#n20" name="n20">20</a></strong></span>    match mapJsonPayload&lt;TokenCreateCredentials&gt; ctx.request with
<span class="line-numbers"><a href="#n21" name="n21">21</a></span>    | Some tokenCreateCredentials -&gt;
<span class="line-numbers"><a href="#n22" name="n22">22</a></span>      async {
<span class="line-numbers"><a href="#n23" name="n23">23</a></span>        let! audience = config.GetAudience tokenCreateCredentials.ClientId
<span class="line-numbers"><a href="#n24" name="n24">24</a></span>        match audience with
<span class="line-numbers"><a href="#n25" name="n25">25</a></span>        | Some audience -&gt;
<span class="line-numbers"><a href="#n26" name="n26">26</a></span>            let tokenCreateRequest : TokenCreateRequest = {         
<span class="line-numbers"><a href="#n27" name="n27">27</a></span>              Issuer = config.Issuer        
<span class="line-numbers"><a href="#n28" name="n28">28</a></span>              UserName = tokenCreateCredentials.UserName
<span class="line-numbers"><a href="#n29" name="n29">29</a></span>              Password = tokenCreateCredentials.Password        
<span class="line-numbers"><strong><a href="#n30" name="n30">30</a></strong></span>              TokenTimeSpan = config.TokenTimeSpan
<span class="line-numbers"><a href="#n31" name="n31">31</a></span>            }            
<span class="line-numbers"><a href="#n32" name="n32">32</a></span>            let! token = createToken tokenCreateRequest identityStore audience
<span class="line-numbers"><a href="#n33" name="n33">33</a></span>            match token with
<span class="line-numbers"><a href="#n34" name="n34">34</a></span>            | Some token -&gt; return! JSON token ctx
<span class="line-numbers"><a href="#n35" name="n35">35</a></span>            | None -&gt; return! BAD_REQUEST &quot;Invalid Login Credentials&quot; ctx
<span class="line-numbers"><a href="#n36" name="n36">36</a></span>
<span class="line-numbers"><a href="#n37" name="n37">37</a></span>        | None -&gt; return! BAD_REQUEST &quot;Invalid Client Id&quot; ctx
<span class="line-numbers"><a href="#n38" name="n38">38</a></span>      }    
<span class="line-numbers"><a href="#n39" name="n39">39</a></span>    | None -&gt; BAD_REQUEST &quot;Invalid Token Create Request&quot; ctx
<span class="line-numbers"><strong><a href="#n40" name="n40">40</a></strong></span>
<span class="line-numbers"><a href="#n41" name="n41">41</a></span>  choose [
<span class="line-numbers"><a href="#n42" name="n42">42</a></span>    path config.AddAudienceUrlPath &gt;=&gt; POST &gt;=&gt; tryCreateAudience
<span class="line-numbers"><a href="#n43" name="n43">43</a></span>    path config.CreateTokenUrlPath &gt;=&gt; POST &gt;=&gt; tryCreateToken
<span class="line-numbers"><a href="#n44" name="n44">44</a></span>  ]
</pre></div>
</div>
</div>

<p>The <code>tryCreateToken</code> function checks whether the <code>ClientId</code> is a registered audience or not, if it exists, then this function creates a token using the <code>createToken</code> function defined above otherwise it returns the <code>BAD_REQUST</code> <em>WebPart</em> with the appropriate error message.</p>

<p>The final change is modifying the <em>Program.fs</em> and <em>AudienceStorage.fs</em> files in the <strong>SuaveJwt.AuthServerHost</strong> to expose this <em>WebPart</em>.</p>

<p><strong>Program.fs</strong></p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"> <a href="#n1" name="n1">1</a></span>let authorizationServerConfig = {
<span class="line-numbers"> <a href="#n2" name="n2">2</a></span>  AddAudienceUrlPath = &quot;/api/audience&quot;
<span class="line-numbers"> <a href="#n3" name="n3">3</a></span>  CreateTokenUrlPath = &quot;/oauth2/token&quot;
<span class="line-numbers"> <a href="#n4" name="n4">4</a></span>  SaveAudience = AudienceStorage.saveAudience
<span class="line-numbers"> <a href="#n5" name="n5">5</a></span>  GetAudience = AudienceStorage.getAudience
<span class="line-numbers"> <a href="#n6" name="n6">6</a></span>  Issuer = &quot;http://localhost:8083/suave&quot;
<span class="line-numbers"> <a href="#n7" name="n7">7</a></span>  TokenTimeSpan = TimeSpan.FromMinutes(1.)
<span class="line-numbers"> <a href="#n8" name="n8">8</a></span>}
<span class="line-numbers"> <a href="#n9" name="n9">9</a></span>
<span class="line-numbers"><strong><a href="#n10" name="n10">10</a></strong></span>let identityStore = {
<span class="line-numbers"><a href="#n11" name="n11">11</a></span>  getClaims = IdentityStore.getClaims
<span class="line-numbers"><a href="#n12" name="n12">12</a></span>  isValidCredentials = IdentityStore.isValidCredentials
<span class="line-numbers"><a href="#n13" name="n13">13</a></span>  getSecurityKey = KeyStore.securityKey
<span class="line-numbers"><a href="#n14" name="n14">14</a></span>  getSigningCredentials = KeyStore.hmacSha256
<span class="line-numbers"><a href="#n15" name="n15">15</a></span>}    
<span class="line-numbers"><a href="#n16" name="n16">16</a></span>
<span class="line-numbers"><a href="#n17" name="n17">17</a></span>let audienceWebPart' = audienceWebPart authorizationServerConfig identityStore   
<span class="line-numbers"><a href="#n18" name="n18">18</a></span>
<span class="line-numbers"><a href="#n19" name="n19">19</a></span>startWebServer defaultConfig audienceWebPart'
</pre></div>
</div>
</div>

<p><strong>AudienceStorage.fs</strong></p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"><a href="#n1" name="n1">1</a></span>let getAudience clientId =        
<span class="line-numbers"><a href="#n2" name="n2">2</a></span>  if audienceStorage.ContainsKey(clientId) then
<span class="line-numbers"><a href="#n3" name="n3">3</a></span>    Some audienceStorage.[clientId] |&gt; async.Return
<span class="line-numbers"><a href="#n4" name="n4">4</a></span>  else
<span class="line-numbers"><a href="#n5" name="n5">5</a></span>    None |&gt; async.Return
</pre></div>
</div>
</div>

<p>The <em>KeyStore</em> and <em>IdentityStore</em> do not exists, so let’s add them</p>

<p>Add <em>KeyStore.fs</em> in the <strong>SuaveJwt</strong> project and it provide the in-memory symmetric security key based on <a href="https://en.wikipedia.org/wiki/Hash-based_message_authentication_code">HMAC</a></p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"> <a href="#n1" name="n1">1</a></span>module KeyStore
<span class="line-numbers"> <a href="#n2" name="n2">2</a></span>open System.IdentityModel.Tokens
<span class="line-numbers"> <a href="#n3" name="n3">3</a></span>open Encodings
<span class="line-numbers"> <a href="#n4" name="n4">4</a></span>
<span class="line-numbers"> <a href="#n5" name="n5">5</a></span>let securityKey sharedKey : SecurityKey =
<span class="line-numbers"> <a href="#n6" name="n6">6</a></span>  let symmetricKey = sharedKey |&gt; Base64String.decode
<span class="line-numbers"> <a href="#n7" name="n7">7</a></span>  new InMemorySymmetricSecurityKey(symmetricKey) :&gt; SecurityKey
<span class="line-numbers"> <a href="#n8" name="n8">8</a></span>
<span class="line-numbers"> <a href="#n9" name="n9">9</a></span>let hmacSha256 secretKey =
<span class="line-numbers"><strong><a href="#n10" name="n10">10</a></strong></span>  new SigningCredentials(secretKey,SecurityAlgorithms.HmacSha256Signature, SecurityAlgorithms.Sha256Digest)
</pre></div>
</div>
</div>

<p>Then add <em>IdentityStore.fs</em> in the <strong>SuaveJwt.AuthServerHost</strong> project.</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"> <a href="#n1" name="n1">1</a></span>module IdentityStore
<span class="line-numbers"> <a href="#n2" name="n2">2</a></span>open System.Security.Claims       
<span class="line-numbers"> <a href="#n3" name="n3">3</a></span>
<span class="line-numbers"> <a href="#n4" name="n4">4</a></span>let getClaims userName =
<span class="line-numbers"> <a href="#n5" name="n5">5</a></span>  seq {
<span class="line-numbers"> <a href="#n6" name="n6">6</a></span>    yield (ClaimTypes.Name, userName)
<span class="line-numbers"> <a href="#n7" name="n7">7</a></span>    if (userName = &quot;Admin&quot;) then
<span class="line-numbers"> <a href="#n8" name="n8">8</a></span>      yield (ClaimTypes.Role, &quot;Admin&quot;)
<span class="line-numbers"> <a href="#n9" name="n9">9</a></span>    if (userName = &quot;Foo&quot;) then
<span class="line-numbers"><strong><a href="#n10" name="n10">10</a></strong></span>      yield (ClaimTypes.Role, &quot;SuperUser&quot;)            
<span class="line-numbers"><a href="#n11" name="n11">11</a></span>  } |&gt; Seq.map (fun x -&gt; new Claim(fst x, snd x)) |&gt; async.Return
<span class="line-numbers"><a href="#n12" name="n12">12</a></span>
<span class="line-numbers"><a href="#n13" name="n13">13</a></span>let isValidCredentials username password =
<span class="line-numbers"><a href="#n14" name="n14">14</a></span>  username = password |&gt; async.Return
</pre></div>
</div>
</div>

<p>To keep this simple, I am just hardcoding the credentials and claims here and it can be replaced with any backend. In this case, I am just going with accepting all the credentials as valid if the username and password are same.</p>

<p>Let’s run the <strong>SuaveJwt.AuthServerHost</strong> and verify the token</p>

<p><img class="center" src="/images/suave_jwt/audience_admin_token.png"></p>

<h2 id="securing-the-resources">Securing the resources</h2>

<p>Now we have come to the interesting part of securing the resources using the <em>access token</em> created in the above step</p>

<p>The first step to achieving this to validate the incoming access token. Let’s add this validation logic in the <em>JwtToken.fs</em> file.</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"> <a href="#n1" name="n1">1</a></span>type TokenValidationRequest = {
<span class="line-numbers"> <a href="#n2" name="n2">2</a></span>  Issuer : string
<span class="line-numbers"> <a href="#n3" name="n3">3</a></span>  SecurityKey : SecurityKey
<span class="line-numbers"> <a href="#n4" name="n4">4</a></span>  ClientId : string
<span class="line-numbers"> <a href="#n5" name="n5">5</a></span>  AccessToken : string
<span class="line-numbers"> <a href="#n6" name="n6">6</a></span>}
<span class="line-numbers"> <a href="#n7" name="n7">7</a></span>
<span class="line-numbers"> <a href="#n8" name="n8">8</a></span>let validate tokenValidationRequest =
<span class="line-numbers"> <a href="#n9" name="n9">9</a></span>  let tokenValidationParameters =
<span class="line-numbers"><strong><a href="#n10" name="n10">10</a></strong></span>    let validationParams = new TokenValidationParameters()
<span class="line-numbers"><a href="#n11" name="n11">11</a></span>    validationParams.ValidAudience &lt;- tokenValidationRequest.ClientId
<span class="line-numbers"><a href="#n12" name="n12">12</a></span>    validationParams.ValidIssuer &lt;- tokenValidationRequest.Issuer
<span class="line-numbers"><a href="#n13" name="n13">13</a></span>    validationParams.ValidateLifetime &lt;- true
<span class="line-numbers"><a href="#n14" name="n14">14</a></span>    validationParams.ValidateIssuerSigningKey &lt;- true
<span class="line-numbers"><a href="#n15" name="n15">15</a></span>    validationParams.IssuerSigningKey &lt;-  tokenValidationRequest.SecurityKey
<span class="line-numbers"><a href="#n16" name="n16">16</a></span>    validationParams
<span class="line-numbers"><a href="#n17" name="n17">17</a></span>  try
<span class="line-numbers"><a href="#n18" name="n18">18</a></span>    let handler = new JwtSecurityTokenHandler()
<span class="line-numbers"><a href="#n19" name="n19">19</a></span>    let principal =
<span class="line-numbers"><strong><a href="#n20" name="n20">20</a></strong></span>      handler.ValidateToken(tokenValidationRequest.AccessToken, tokenValidationParameters, ref null)
<span class="line-numbers"><a href="#n21" name="n21">21</a></span>    principal.Claims |&gt; Choice1Of2
<span class="line-numbers"><a href="#n22" name="n22">22</a></span>  with
<span class="line-numbers"><a href="#n23" name="n23">23</a></span>    | ex -&gt; ex.Message |&gt; Choice2Of2
</pre></div>
</div>
</div>

<p>The <code>validate</code> function returns a <code>Choice</code> type which contains either a sequence of <a href="https://msdn.microsoft.com/en-us/library/system.security.claims(v=vs.110).aspx">Claims</a> present in the token if the access token is valid or an error message describing what’s wrong with the access token</p>

<p>The next step is using this function to secure a Suave <em>WebPart</em></p>

<p>Create a new source file <em>Secure.fs</em> in the <strong>SuaveJwt</strong> project and add the following code</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"> <a href="#n1" name="n1">1</a></span>type JwtConfig = {
<span class="line-numbers"> <a href="#n2" name="n2">2</a></span>    Issuer : string    
<span class="line-numbers"> <a href="#n3" name="n3">3</a></span>    SecurityKey : SecurityKey
<span class="line-numbers"> <a href="#n4" name="n4">4</a></span>    ClientId : string    
<span class="line-numbers"> <a href="#n5" name="n5">5</a></span>}
<span class="line-numbers"> <a href="#n6" name="n6">6</a></span>
<span class="line-numbers"> <a href="#n7" name="n7">7</a></span>let jwtAuthenticate jwtConfig webpart (ctx: HttpContext) =
<span class="line-numbers"> <a href="#n8" name="n8">8</a></span>
<span class="line-numbers"> <a href="#n9" name="n9">9</a></span>  let updateContextWithClaims claims =
<span class="line-numbers"><strong><a href="#n10" name="n10">10</a></strong></span>    { ctx with userState = ctx.userState.Remove(&quot;Claims&quot;).Add(&quot;Claims&quot;, claims) }    
<span class="line-numbers"><a href="#n11" name="n11">11</a></span>
<span class="line-numbers"><a href="#n12" name="n12">12</a></span>  match ctx.request.header &quot;token&quot; with
<span class="line-numbers"><a href="#n13" name="n13">13</a></span>  | Choice1Of2 accessToken -&gt;
<span class="line-numbers"><a href="#n14" name="n14">14</a></span>      let tokenValidationRequest =  {
<span class="line-numbers"><a href="#n15" name="n15">15</a></span>        Issuer = jwtConfig.Issuer
<span class="line-numbers"><a href="#n16" name="n16">16</a></span>        SecurityKey = jwtConfig.SecurityKey
<span class="line-numbers"><a href="#n17" name="n17">17</a></span>        ClientId = jwtConfig.ClientId
<span class="line-numbers"><a href="#n18" name="n18">18</a></span>        AccessToken = accessToken
<span class="line-numbers"><a href="#n19" name="n19">19</a></span>      }
<span class="line-numbers"><strong><a href="#n20" name="n20">20</a></strong></span>      let validationResult = validate tokenValidationRequest
<span class="line-numbers"><a href="#n21" name="n21">21</a></span>      match validationResult with
<span class="line-numbers"><a href="#n22" name="n22">22</a></span>      | Choice1Of2 claims -&gt; webpart (updateContextWithClaims claims)
<span class="line-numbers"><a href="#n23" name="n23">23</a></span>      | Choice2Of2 err -&gt; FORBIDDEN err ctx                         
<span class="line-numbers"><a href="#n24" name="n24">24</a></span>
<span class="line-numbers"><a href="#n25" name="n25">25</a></span>  | _ -&gt; BAD_REQUEST &quot;Invalid Request. Provide both clientid and token&quot; ctx  
</pre></div>
</div>
</div>

<p>The <code>jwtAuthenticate</code> function validates the access token present in the request header and invokes the given <em>WebPart</em> if it is valid. In case of invalid or absence of access token, it returns an HTTP error response instead of executing the <em>WebPart</em>.</p>

<p>Upon successful access token validation, the <code>jwtAuthenticate</code> function puts the claims in the <code>userState</code> map of incoming <code>HttpContext</code> so that subsequent <em>WebPart</em>s in the pipeline can use it.</p>

<p>The <code>JwtConfig</code> record abstracts the underlying audience from the validation logic so that it can be reused across multiple audiences.</p>

<p>Now we have a functionality secure a web part. Let’s create an audience and leverage this</p>

<p>Update the <em>Program.fs</em> file in the <strong>Audience1</strong> project as mentioned below</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"> <a href="#n1" name="n1">1</a></span>[&lt;EntryPoint&gt;]
<span class="line-numbers"> <a href="#n2" name="n2">2</a></span>let main argv =
<span class="line-numbers"> <a href="#n3" name="n3">3</a></span>
<span class="line-numbers"> <a href="#n4" name="n4">4</a></span>  let jwtConfig = {
<span class="line-numbers"> <a href="#n5" name="n5">5</a></span>    Issuer = &quot;http://localhost:8083/suave&quot;
<span class="line-numbers"> <a href="#n6" name="n6">6</a></span>    ClientId = &quot;7ff79ba3305c4e4f9d0ececeae70c78f&quot;
<span class="line-numbers"> <a href="#n7" name="n7">7</a></span>    SecurityKey = KeyStore.securityKey (Base64String.fromString &quot;Op5EqjC70aLS2dx3gI0zADPIZGX2As6UEwjA4oyBjMo&quot;)       
<span class="line-numbers"> <a href="#n8" name="n8">8</a></span>  }
<span class="line-numbers"> <a href="#n9" name="n9">9</a></span>
<span class="line-numbers"><strong><a href="#n10" name="n10">10</a></strong></span>  let sample1 = path &quot;/audience1/sample1&quot; &gt;=&gt; jwtAuthenticate jwtConfig (OK &quot;Sample 1&quot;)
<span class="line-numbers"><a href="#n11" name="n11">11</a></span>  let config = { defaultConfig with bindings = [HttpBinding.mkSimple HTTP &quot;127.0.0.1&quot; 8084] }
<span class="line-numbers"><a href="#n12" name="n12">12</a></span>
<span class="line-numbers"><a href="#n13" name="n13">13</a></span>  startWebServer config sample1
<span class="line-numbers"><a href="#n14" name="n14">14</a></span>  0
</pre></div>
</div>
</div>

<p>I’ve asked you to keep a note of the <em>clientId</em> and the <em>securityKey</em> while doing the registration of <strong>Audience1</strong>. We are using them here in the <code>jwtConfig</code> record.</p>

<p>Let’s see it in action</p>

<p><img class="center" src="/images/suave_jwt/audience_sample1_success.png"></p>

<p>Hurray! We have made it. “/audience1/sample1” is a secured API now!</p>

<p>What will happen if we mess with the access token? Well, we will get an HTTP error. Let’s change the character <code>Q</code> in the access token from upper case to lower case and here is the result of it.</p>

<p><img class="center" src="/images/suave_jwt/audience_sample1_error.png"></p>

<p>Cool, Isn’t it?</p>

<p>Let’s add authorization based on the claims that we have obtained from the JWT token</p>

<p>Open <em>Secure.fs</em> and update the authorization functionality</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"> <a href="#n1" name="n1">1</a></span>type AuthorizationResult =
<span class="line-numbers"> <a href="#n2" name="n2">2</a></span>  | Authorized
<span class="line-numbers"> <a href="#n3" name="n3">3</a></span>  | UnAuthorized of string
<span class="line-numbers"> <a href="#n4" name="n4">4</a></span>
<span class="line-numbers"> <a href="#n5" name="n5">5</a></span>let jwtAuthorize jwtConfig authorizeUser webpart  =
<span class="line-numbers"> <a href="#n6" name="n6">6</a></span>
<span class="line-numbers"> <a href="#n7" name="n7">7</a></span>  let getClaims (ctx: HttpContext) =
<span class="line-numbers"> <a href="#n8" name="n8">8</a></span>    let userState = ctx.userState
<span class="line-numbers"> <a href="#n9" name="n9">9</a></span>    if userState.ContainsKey(&quot;Claims&quot;) then
<span class="line-numbers"><strong><a href="#n10" name="n10">10</a></strong></span>      match userState.Item &quot;Claims&quot; with
<span class="line-numbers"><a href="#n11" name="n11">11</a></span>      | :? (Claim seq) as claims -&gt; Some claims             
<span class="line-numbers"><a href="#n12" name="n12">12</a></span>      | _ -&gt; None
<span class="line-numbers"><a href="#n13" name="n13">13</a></span>    else
<span class="line-numbers"><a href="#n14" name="n14">14</a></span>        None
<span class="line-numbers"><a href="#n15" name="n15">15</a></span>
<span class="line-numbers"><a href="#n16" name="n16">16</a></span>  let authorize httpContext =
<span class="line-numbers"><a href="#n17" name="n17">17</a></span>    match getClaims httpContext with
<span class="line-numbers"><a href="#n18" name="n18">18</a></span>    | Some claims -&gt;
<span class="line-numbers"><a href="#n19" name="n19">19</a></span>        async {
<span class="line-numbers"><strong><a href="#n20" name="n20">20</a></strong></span>          let! authorizationResult = authorizeUser claims          
<span class="line-numbers"><a href="#n21" name="n21">21</a></span>          match authorizationResult with
<span class="line-numbers"><a href="#n22" name="n22">22</a></span>          | Authorized -&gt; return! webpart httpContext
<span class="line-numbers"><a href="#n23" name="n23">23</a></span>          | UnAuthorized err -&gt; return! FORBIDDEN err httpContext
<span class="line-numbers"><a href="#n24" name="n24">24</a></span>        }
<span class="line-numbers"><a href="#n25" name="n25">25</a></span>    | None -&gt; FORBIDDEN &quot;Claims not found&quot; httpContext
<span class="line-numbers"><a href="#n26" name="n26">26</a></span>
<span class="line-numbers"><a href="#n27" name="n27">27</a></span>  jwtAuthenticate jwtConfig authorize
</pre></div>
</div>
</div>

<p>The <code>jwtConfig</code> function is very similar to the <code>jwtAuthenticate</code> function which provides authorization in addition to the authentication.</p>

<p>The key here is the parameter <code>authorizeUser</code> which is a function that takes a sequence of claims and returns an <code>AuthorizationResult</code>.</p>

<p>Like <code>jwtAuthenticate`` function, the</code>jwtConfig``` function is also abstracted from the underlying <em>Audience</em> so we can use it across multiple <em>Audience</em>s.</p>

<p>Let’s use this in the <strong>Audience1</strong>.</p>

<p><strong>Program.fs</strong></p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"> <a href="#n1" name="n1">1</a></span>[&lt;EntryPoint&gt;]
<span class="line-numbers"> <a href="#n2" name="n2">2</a></span>let main argv =
<span class="line-numbers"> <a href="#n3" name="n3">3</a></span>
<span class="line-numbers"> <a href="#n4" name="n4">4</a></span>  // ... existing code ...
<span class="line-numbers"> <a href="#n5" name="n5">5</a></span>
<span class="line-numbers"> <a href="#n6" name="n6">6</a></span>  // Claim Seq -&gt; Async&lt;AuthorizationResult&gt;
<span class="line-numbers"> <a href="#n7" name="n7">7</a></span>  let authorizeAdmin (claims : Claim seq) =
<span class="line-numbers"> <a href="#n8" name="n8">8</a></span>    match claims |&gt; Seq.tryFind (fun c -&gt; c.Type = ClaimTypes.Role &amp;&amp; c.Value = &quot;Admin&quot;) with
<span class="line-numbers"> <a href="#n9" name="n9">9</a></span>    | Some _ -&gt; Authorized |&gt; async.Return
<span class="line-numbers"><strong><a href="#n10" name="n10">10</a></strong></span>    | None -&gt; UnAuthorized &quot;User is not an admin&quot; |&gt; async.Return
<span class="line-numbers"><a href="#n11" name="n11">11</a></span>
<span class="line-numbers"><a href="#n12" name="n12">12</a></span>  let sample2 = path &quot;/audience1/sample2&quot; &gt;=&gt; jwtAuthorize jwtConfig authorizeAdmin (OK &quot;Sample 2&quot;)
<span class="line-numbers"><a href="#n13" name="n13">13</a></span>  let app = choose [sample1;sample2]
<span class="line-numbers"><a href="#n14" name="n14">14</a></span>
<span class="line-numbers"><a href="#n15" name="n15">15</a></span>  startWebServer config app
<span class="line-numbers"><a href="#n16" name="n16">16</a></span>  0  
</pre></div>
</div>
</div>

<p>The <code>jwtAuthroize</code> function in action</p>

<p><img class="center" src="/images/suave_jwt/audience1_sample2_error.png"></p>

<p><em>Note: I’ve generated a new access token here to exercise this use case.</em></p>

<p>That’s it we have successfully completed all the three steps mentioned at the beginning of this blog post.</p>

<h2 id="a-supplement">A Supplement</h2>

<p>One cool thing about the design of the <strong>SuaveJwt</strong> library is, it doesn’t have any assumption about the <em>Authorization Server</em> and the <em>Resource Server</em>. Because of it, we can easily extend it.</p>

<p>Let’s prove it by updating the <em>Program.fs</em> file in the <strong>Audience2</strong> project.</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"> <a href="#n1" name="n1">1</a></span>[&lt;EntryPoint&gt;]
<span class="line-numbers"> <a href="#n2" name="n2">2</a></span>let main argv =
<span class="line-numbers"> <a href="#n3" name="n3">3</a></span>  let jwtConfig = {
<span class="line-numbers"> <a href="#n4" name="n4">4</a></span>    Issuer = &quot;http://localhost:8083/suave&quot;
<span class="line-numbers"> <a href="#n5" name="n5">5</a></span>    ClientId = &quot;ada9263885c440869fb484fe354de13d&quot;
<span class="line-numbers"> <a href="#n6" name="n6">6</a></span>    SecurityKey = KeyStore.securityKey (Base64String.fromString &quot;0RWyzyttDmJtiaYkG9rph5cqxCTI8YAOsR7stq-P_5o&quot;)       
<span class="line-numbers"> <a href="#n7" name="n7">7</a></span>  }
<span class="line-numbers"> <a href="#n8" name="n8">8</a></span>
<span class="line-numbers"> <a href="#n9" name="n9">9</a></span>  let authorizeSuperUser (claims : Claim seq) =
<span class="line-numbers"><strong><a href="#n10" name="n10">10</a></strong></span>    match claims |&gt; Seq.tryFind (fun c -&gt; c.Type = ClaimTypes.Role &amp;&amp; c.Value = &quot;SuperUser&quot;) with
<span class="line-numbers"><a href="#n11" name="n11">11</a></span>    | Some _ -&gt; Authorized |&gt; async.Return
<span class="line-numbers"><a href="#n12" name="n12">12</a></span>    | None -&gt; UnAuthorized &quot;User is not a Super User&quot; |&gt; async.Return
<span class="line-numbers"><a href="#n13" name="n13">13</a></span>
<span class="line-numbers"><a href="#n14" name="n14">14</a></span>  let authorize = jwtAuthorize jwtConfig
<span class="line-numbers"><a href="#n15" name="n15">15</a></span>  let sample1 = path &quot;/audience2/sample1&quot; &gt;=&gt; OK &quot;Sample 1&quot;
<span class="line-numbers"><a href="#n16" name="n16">16</a></span>  let sample2 = path &quot;/audience2/sample2&quot; &gt;=&gt; authorize authorizeSuperUser (OK &quot;Sample 2&quot;)      
<span class="line-numbers"><a href="#n17" name="n17">17</a></span>  let config = { defaultConfig with bindings = [HttpBinding.mkSimple HTTP &quot;127.0.0.1&quot; 8085] }    
<span class="line-numbers"><a href="#n18" name="n18">18</a></span>  let app = choose [sample1;sample2]
<span class="line-numbers"><a href="#n19" name="n19">19</a></span>
<span class="line-numbers"><strong><a href="#n20" name="n20">20</a></strong></span>  startWebServer config app
<span class="line-numbers"><a href="#n21" name="n21">21</a></span>  0
</pre></div>
</div>
</div>

<p>Note that the <code>jwtConfig</code> values are different from that of <strong>Audience1</strong> and it is obtained from calling the <strong>AuthorizationServer</strong>’s audience registration API for <strong>Audience2</strong>.</p>

<h2 id="summary">Summary</h2>

<p>Suave provides a simple and elegant way of extending its core functionality. In this blog post, we have seen how to bend it to support JWT based authorization and I believe we can do a lot of other cool things too!</p>

<p>You can find the complete source code of the sample application used in this blog post in my <a href="https://github.com/tamizhvendan/blog-samples/tree/master/SuaveJwtSampleApplication">blog-samples</a> GitHub repository.    </p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Building REST Api in fsharp using Suave]]></title>
    <link href="http://blog.tamizhvendan.in/blog/2015/06/11/building-rest-api-in-fsharp-using-suave/"/>
    <updated>2015-06-11T10:48:20+05:30</updated>
    <id>http://blog.tamizhvendan.in/blog/2015/06/11/building-rest-api-in-fsharp-using-suave</id>
    <content type="html"><![CDATA[<p>In the last one month lot of great things happening in fsharp world around <a href="suave.io">suave</a>, a simple web development fsharp library. Scott Hanselman <a href="http://www.hanselman.com/blog/RunningSuaveioAndFWithFAKEInAzureWebAppsWithGitAndTheDeployButton.aspx">blogged</a> about it, <a href="https://twitter.com/tomaspetricek">Tomas Petricek</a> kick-started an awesome <a href="https://skillsmatter.com/skillscasts/6381-suave-hands-on-with-tomas-petricek">hands on session</a> and followed up with a <a href="http://channel9.msdn.com/Blogs/Seth-Juarez/Deploying-an-F-Web-Application-with-Suave">great talk</a> on Channel 9. Last but not the least, <a href="https://twitter.com/theimowski">Tomasz Heimowski</a> authored a clear and crisp <a href="http://theimowski.gitbooks.io/suave-music-store/content/">book on Suave</a></p>

<p>I got super excited after learning suave from these resources and started playing with it. One of the great things about the fsharp community is, if you want to improve any existing library all you need is just send a pull request with the feature you would like to have. Yes, it’s as simple as that! It <a href="https://github.com/SuaveIO/suave/pull/259">worked</a> for me and I am sure for you too, if you wish.</p>

<p>In this blog post, you are going to learn how to build a REST api using suave. The REST api that we are going to create here follows the standard being used in the <a href="http://docs.strongloop.com/display/public/LB/Use+API+Explorer">StrongLoop</a>, a node.js REST api library. To keep things simple, we are not going to see validation and error handling as part of this post and I will be covering that in an another post.</p>

<p>Let’s get started</p>

<h2 id="setting-up-the-project">Setting up the project</h2>

<p>Create a new “F# Console Application” project in Visual Studio with the name <code>SuaveRestApi</code> and rename <code>Program.fs</code> to <code>App.fs</code>. This file is going to contain the application bootstrap logic. Add two more files <code>Db.fs</code> and <code>RestFul.fs</code> which would contain database access and restful api implementation code respectively. Ensure these files are in the order as shown in below.</p>

<p><img class="center" src="/images/sauve_rest_api/proj_structure.png"></p>

<p>After creating, install the following nuget packages</p>

<ul>
  <li><a href="https://www.nuget.org/packages/suave">Suave</a></li>
  <li><a href="">Newtonsoft.Json</a></li>
</ul>

<h2 id="webpart">WebPart</h2>

<p>The basic building block of Suave is <a href="http://theimowski.gitbooks.io/suave-music-store/content/webpart.html">WebPart</a>. It is an alias of function type <code>HttpContext -&gt; Async&lt;HttpContext option&gt;</code>. This simple function type actually model whole set of Request and Response model of Http protocol. From the Tomasz Heimowski’s book here is the definition of the <code>WebPart</code></p>

<blockquote>
  <p>Based on the http context, we give you a promise (async) of optional resulting http context, where the resulting context is likely to have its response set with regards to the logic of the WebPart itself</p>
</blockquote>

<p>A <code>WebPart</code> represents a http request and response. Since it is a function, we can combine multiple <code>WebPart</code>s together and build a complex web application which handles multiple requests and responses. This is the beauty of functional programming. You just think in terms of one function at a time and make it work. Once you are done, all you need to do is just gluing them together. Solving problems using this functional abstraction will make things much easier and help you to write less code compare to its Object Oriented version.</p>

<p>The <code>OK</code> webpart is a very simple one in Suave which takes a <code>string</code> and returns a http response with the status code <code>200</code> and the given string. Add the following code in the <code>App.fs</code> and run the console app.</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"><a href="#n1" name="n1">1</a></span>open Suave.Web
<span class="line-numbers"><a href="#n2" name="n2">2</a></span>open Suave.Successful
<span class="line-numbers"><a href="#n3" name="n3">3</a></span>
<span class="line-numbers"><a href="#n4" name="n4">4</a></span>[&lt;EntryPoint&gt;]
<span class="line-numbers"><a href="#n5" name="n5">5</a></span>let main argv =
<span class="line-numbers"><a href="#n6" name="n6">6</a></span>  startWebServer defaultConfig (OK &quot;Hello, Suave!&quot;)
<span class="line-numbers"><a href="#n7" name="n7">7</a></span>  0
</pre></div>
</div>
</div>
<p>The is the simplest Suave application that greets all visitors with the string “Hello, Suave!”. The <code>startWebServer</code> is a blocking function that takes a configuration (port number, ssl, etc.,) and starts a http web server in the port 8083 upon calling.</p>

<p><img class="center border" src="/images/sauve_rest_api/hello_suave.png"></p>

<p>The Rest Api that we are going to design here is a <code>WebPart</code> which will be replacing this <code>OK</code> webpart.</p>

<h2 id="http-get">HTTP GET</h2>

<p>Let’s begin by defining a record type representing a <em>restful</em> resource. Open <code>Restful.fs</code> and update it as below</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"><a href="#n1" name="n1">1</a></span>namespace SuaveRestApi.Rest
<span class="line-numbers"><a href="#n2" name="n2">2</a></span>[&lt;AutoOpen&gt;]
<span class="line-numbers"><a href="#n3" name="n3">3</a></span>module RestFul =  
<span class="line-numbers"><a href="#n4" name="n4">4</a></span>  type RestResource&lt;'a&gt; = {
<span class="line-numbers"><a href="#n5" name="n5">5</a></span>    GetAll : unit -&gt; 'a seq        
<span class="line-numbers"><a href="#n6" name="n6">6</a></span>  }
</pre></div>
</div>
</div>

<p>This <code>RestResource</code> is a container representing all the operations on a restful  resource. This record type abstracts the actual resource from the rest api web part. This enables the reuse of rest api web part across multiple resources.</p>

<p>Let’s create a function in <code>RestFul.fs</code> which takes a resource name and this <code>RestResource</code> and returns a web part representing the restful api.</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"><a href="#n1" name="n1">1</a></span>// string -&gt; RestResource&lt;'a&gt; -&gt; WebPart
<span class="line-numbers"><a href="#n2" name="n2">2</a></span>let rest resourceName resource =
<span class="line-numbers"><a href="#n3" name="n3">3</a></span>  // TODO
</pre></div>
</div>
</div>

<p>We are going to use the following building blocks of the suave library to implement the <code>rest</code> function.</p>

<ul>
  <li>
    <p>The <code>path</code> is a function of type: <code>string -&gt; WebPart</code>. It means that if we give it a string it will return <code>WebPart</code>. Under the hood, the function looks at the incoming request and returns <code>Some</code> if the paths match, and <code>None</code> otherwise.</p>
  </li>
  <li>
    <p>The <code>GET</code> is a static inbuilt <code>WebPart</code> which matches the HTTP GET requests.</p>
  </li>
  <li>
    <p>The <code>&gt;=&gt;</code> operator composes two WebParts into one by first evaluating the <code>WebPart</code> on the left, and applying the WebPart on the right only if the first one returned <code>Some</code>.</p>
  </li>
</ul>

<p>To return a json response we need to change the mime type to “application/json” of the response. There is an <a href="https://github.com/SuaveIO/suave/blob/master/src/Suave/Json.fs">inbuilt function</a> in suave to do this but it is using .Net’s <code>DataContractJsonSerializer</code>. I feel it’s not ideal to use as we need to write decorator attribute <code>DataMember</code> to serialize the types.</p>

<p>As <a href="http://james.newtonking.com/archive/2014/04/30/json-net-6-0-release-3-serialize-all-the-f">Newtonsoft.Json</a> provides serialization support for fsharp types without any need of decorating attributes, we will be using them there.</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"><a href="#n1" name="n1">1</a></span>// 'a -&gt; WebPart
<span class="line-numbers"><a href="#n2" name="n2">2</a></span>let JSON v =     
<span class="line-numbers"><a href="#n3" name="n3">3</a></span>  let jsonSerializerSettings = new JsonSerializerSettings()
<span class="line-numbers"><a href="#n4" name="n4">4</a></span>  jsonSerializerSettings.ContractResolver &lt;- new CamelCasePropertyNamesContractResolver()
<span class="line-numbers"><a href="#n5" name="n5">5</a></span>
<span class="line-numbers"><a href="#n6" name="n6">6</a></span>  JsonConvert.SerializeObject(v, jsonSerializerSettings)
<span class="line-numbers"><a href="#n7" name="n7">7</a></span>  |&gt; OK
<span class="line-numbers"><a href="#n8" name="n8">8</a></span>  &gt;=&gt; Writers.setMimeType &quot;application/json; charset=utf-8&quot;
</pre></div>
</div>
</div>
<p>As the signature indicates <code>JSON</code> function takes a generic type, serialize it using <em>Newtonsoft.Json</em> and return the json response. <code>Writers.setMimeType</code> takes a mime type and a web part returns the web part with the given mime type.</p>

<p>Now we have everything to implement the HTTP GET request</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"><a href="#n1" name="n1">1</a></span>let rest resourceName resource =
<span class="line-numbers"><a href="#n2" name="n2">2</a></span>  let resourcePath = &quot;/&quot; + resourceName
<span class="line-numbers"><a href="#n3" name="n3">3</a></span>  let gellAll = resource.GetAll () |&gt; JSON
<span class="line-numbers"><a href="#n4" name="n4">4</a></span>  path resourcePath &gt;=&gt; GET &gt;=&gt; getAll
</pre></div>
</div>
</div>

<p>The one caveat here is the path resolution of Suave library. Based on the webpart given, the <code>startWebServer</code> function configures it’s internal routing table during the application startup and it is static after the application has been started. So, the <code>getAll</code> webpart will be created only during application startup. To avoid this, we need to wrap the <code>getAll</code> webpart with a <code>warbler</code> function which ensures that it is called only when the incoming request matches the given resource path.</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"><a href="#n1" name="n1">1</a></span>let rest resourceName resource =
<span class="line-numbers"><a href="#n2" name="n2">2</a></span>  let resourcePath = &quot;/&quot; + resourceName
<span class="line-numbers"><a href="#n3" name="n3">3</a></span>  let gellAll = warbler (fun _ -&gt; resource.GetAll () |&gt; JSON)
<span class="line-numbers"><a href="#n4" name="n4">4</a></span>  path resourcePath &gt;=&gt; GET &gt;=&gt; getAll
</pre></div>
</div>
</div>

<p>Now we have the middleware to create a web part. Let’s create other things and glue them together.</p>

<p>Open <code>Db.fs</code> file and add the following code</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"> <a href="#n1" name="n1">1</a></span>namespace SuaveRestApi.Db
<span class="line-numbers"> <a href="#n2" name="n2">2</a></span>open System.Collections.Generic
<span class="line-numbers"> <a href="#n3" name="n3">3</a></span>type Person = {
<span class="line-numbers"> <a href="#n4" name="n4">4</a></span>  Id : int
<span class="line-numbers"> <a href="#n5" name="n5">5</a></span>  Name : string
<span class="line-numbers"> <a href="#n6" name="n6">6</a></span>  Age : int
<span class="line-numbers"> <a href="#n7" name="n7">7</a></span>  Email : string
<span class="line-numbers"> <a href="#n8" name="n8">8</a></span>}
<span class="line-numbers"> <a href="#n9" name="n9">9</a></span>module Db =        
<span class="line-numbers"><strong><a href="#n10" name="n10">10</a></strong></span>  let private peopleStorage = new Dictionary&lt;int, Person&gt;()
<span class="line-numbers"><a href="#n11" name="n11">11</a></span>  let getPeople () =
<span class="line-numbers"><a href="#n12" name="n12">12</a></span>    peopleStorage.Values |&gt; Seq.map (fun p -&gt; p)
</pre></div>
</div>
</div>

<p>Since it’s a sample application, I am just using an in memory dictionary to store the details of people. You can easily replace this with any data source. The <code>Person</code> type represents the <code>People</code> resource of the rest api.</p>

<p>The next step is wiring the Restful web part with the application. Open <code>App.fs</code> and update it as below</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"> <a href="#n1" name="n1">1</a></span>open SuaveRestApi.Rest
<span class="line-numbers"> <a href="#n2" name="n2">2</a></span>open SuaveRestApi.Db
<span class="line-numbers"> <a href="#n3" name="n3">3</a></span>open Suave.Web
<span class="line-numbers"> <a href="#n4" name="n4">4</a></span>open Suave.Http.Successful
<span class="line-numbers"> <a href="#n5" name="n5">5</a></span>
<span class="line-numbers"> <a href="#n6" name="n6">6</a></span>[&lt;EntryPoint&gt;]
<span class="line-numbers"> <a href="#n7" name="n7">7</a></span>let main argv =
<span class="line-numbers"> <a href="#n8" name="n8">8</a></span>  let personWebPart = rest &quot;people&quot; {
<span class="line-numbers"> <a href="#n9" name="n9">9</a></span>    GetAll = Db.getPeople
<span class="line-numbers"><strong><a href="#n10" name="n10">10</a></strong></span>  }
<span class="line-numbers"><a href="#n11" name="n11">11</a></span>  startWebServer defaultConfig personWebPart
<span class="line-numbers"><a href="#n12" name="n12">12</a></span>  0
</pre></div>
</div>
</div>

<p>That’s it! Now we have the HTTP GET Request up and running</p>

<p><img class="center border" src="/images/sauve_rest_api/http_get.png"></p>

<p>Since we are having no people in our in-memory dictionary, we are getting an empty result here. Let’s add a new person using HTTP POST</p>

<h2 id="http-post">HTTP POST</h2>

<p>HTTP POST uses the same workflow as HTTP GET. To implement this, we are going to use the following features in Suave.</p>

<ul>
  <li>
    <p>The <code>choose</code> function takes a list of WebParts, and chooses the first one that applies (i.e which returns <code>Some</code>), or if none WebPart applies, then choose will  return <code>None</code></p>
  </li>
  <li>
    <p>The <code>request</code> function takes a function of type <code>HttpRequest -&gt; WebPart</code> and returns the <code>WebPart</code>. We will use this <code>HttpRequest</code> to get the POST content.</p>
  </li>
  <li>
    <p>The <code>POST</code> is a static in-built <code>WebPart</code> which matches the HTTP POST requests.</p>
  </li>
</ul>

<p>The first step in implementing POST request is updating the <code>RestResource</code>.</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"><a href="#n1" name="n1">1</a></span>type RestResource&lt;'a&gt; = {
<span class="line-numbers"><a href="#n2" name="n2">2</a></span>  GetAll : unit -&gt; 'a seq
<span class="line-numbers"><a href="#n3" name="n3">3</a></span>  Create : 'a -&gt; 'a        
<span class="line-numbers"><a href="#n4" name="n4">4</a></span>}
</pre></div>
</div>
</div>

<p>Then add the following utility functions in <code>Restful.fs</code> to get the resource from the HttpRequest</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"><a href="#n1" name="n1">1</a></span>let fromJson&lt;'a&gt; json =
<span class="line-numbers"><a href="#n2" name="n2">2</a></span>  JsonConvert.DeserializeObject(json, typeof&lt;'a&gt;) :?&gt; 'a    
<span class="line-numbers"><a href="#n3" name="n3">3</a></span>
<span class="line-numbers"><a href="#n4" name="n4">4</a></span>let getResourceFromReq&lt;'a&gt; (req : HttpRequest) =
<span class="line-numbers"><a href="#n5" name="n5">5</a></span>  let getString rawForm =
<span class="line-numbers"><a href="#n6" name="n6">6</a></span>    System.Text.Encoding.UTF8.GetString(rawForm)
<span class="line-numbers"><a href="#n7" name="n7">7</a></span>  req.rawForm |&gt; getString |&gt; fromJson&lt;'a&gt;
</pre></div>
</div>
</div>

<p>The <code>rawForm</code> field in the <code>HttpRequest</code> has the POST content as a byte array, we are just deserializing to a fsharp type.</p>

<p>The next step is updating the <code>rest</code> function to support POST</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"><a href="#n1" name="n1">1</a></span>let rest resourceName resource =
<span class="line-numbers"><a href="#n2" name="n2">2</a></span>  let resourcePath = &quot;/&quot; + resourceName
<span class="line-numbers"><a href="#n3" name="n3">3</a></span>  let gellAll = warbler (fun _ -&gt; resource.GetAll () |&gt; JSON)
<span class="line-numbers"><a href="#n4" name="n4">4</a></span>  path resourcePath &gt;=&gt; choose [
<span class="line-numbers"><a href="#n5" name="n5">5</a></span>    GET &gt;=&gt; getAll
<span class="line-numbers"><a href="#n6" name="n6">6</a></span>    POST &gt;=&gt; request (getResourceFromReq &gt;&gt; resource.Create &gt;&gt; JSON)
<span class="line-numbers"><a href="#n7" name="n7">7</a></span>  ]
</pre></div>
</div>
</div>
<p>Thanks to the awesome function composition feature, we have combined all these tiny functions and implemented a new request and response.  </p>

<p>Then update <code>Db.fs</code> and <code>App.fs</code> respectively as follows</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"> <a href="#n1" name="n1">1</a></span>module Db =
<span class="line-numbers"> <a href="#n2" name="n2">2</a></span>  let createPerson person =
<span class="line-numbers"> <a href="#n3" name="n3">3</a></span>    let id = peopleStorage.Values.Count + 1
<span class="line-numbers"> <a href="#n4" name="n4">4</a></span>    let newPerson = {
<span class="line-numbers"> <a href="#n5" name="n5">5</a></span>        Id = id
<span class="line-numbers"> <a href="#n6" name="n6">6</a></span>        Name = person.Name
<span class="line-numbers"> <a href="#n7" name="n7">7</a></span>        Age = person.Age
<span class="line-numbers"> <a href="#n8" name="n8">8</a></span>        Email = person.Email
<span class="line-numbers"> <a href="#n9" name="n9">9</a></span>    }
<span class="line-numbers"><strong><a href="#n10" name="n10">10</a></strong></span>    peopleStorage.Add(id, newPerson)
<span class="line-numbers"><a href="#n11" name="n11">11</a></span>    newPerson
</pre></div>
</div>
</div>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"><a href="#n1" name="n1">1</a></span>let personWebPart = rest &quot;people&quot; {
<span class="line-numbers"><a href="#n2" name="n2">2</a></span>  GetAll = Db.getPeople
<span class="line-numbers"><a href="#n3" name="n3">3</a></span>  Create = Db.createPerson
<span class="line-numbers"><a href="#n4" name="n4">4</a></span>}
</pre></div>
</div>
</div>

<p>The HTTP POST function in action</p>

<p><img class="center border" src="/images/sauve_rest_api/http_post.png"></p>

<h2 id="http-put">HTTP PUT</h2>

<p>As we did for GET &amp; POST we will be starting by updating the <code>RestResource</code></p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"><a href="#n1" name="n1">1</a></span>type RestResource&lt;'a&gt; = {
<span class="line-numbers"><a href="#n2" name="n2">2</a></span>  GetAll : unit -&gt; 'a seq
<span class="line-numbers"><a href="#n3" name="n3">3</a></span>  Create : 'a -&gt; 'a
<span class="line-numbers"><a href="#n4" name="n4">4</a></span>  Update : 'a -&gt; 'a option       
<span class="line-numbers"><a href="#n5" name="n5">5</a></span>}
</pre></div>
</div>
</div>
<p>We have added a bit of error handling here. This <code>Update</code> function tries to update a resource and returns the updated resource if the resource exists. If it didn’t it returns <code>None</code></p>

<p>To support HTTP PUT we will be using the following from suave library</p>

<ul>
  <li>
    <p>The <code>BAD_REQUEST</code> function takes a string and returns a WebPart representing HTTP status code 400 response with given string as it response.</p>
  </li>
  <li>
    <p>The <code>PUT</code> is a static in-built <code>WebPart</code> which matches the HTTP PUT requests.</p>
  </li>
</ul>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"> <a href="#n1" name="n1">1</a></span>let rest resourceName resource =
<span class="line-numbers"> <a href="#n2" name="n2">2</a></span>  let resourcePath = &quot;/&quot; + resourceName
<span class="line-numbers"> <a href="#n3" name="n3">3</a></span>  let badRequest = BAD_REQUEST &quot;Resource not found&quot;
<span class="line-numbers"> <a href="#n4" name="n4">4</a></span>
<span class="line-numbers"> <a href="#n5" name="n5">5</a></span>  let gellAll = warbler (fun _ -&gt; resource.GetAll () |&gt; JSON)
<span class="line-numbers"> <a href="#n6" name="n6">6</a></span>  let handleResource requestError = function
<span class="line-numbers"> <a href="#n7" name="n7">7</a></span>    | Some r -&gt; r |&gt; JSON
<span class="line-numbers"> <a href="#n8" name="n8">8</a></span>    | _ -&gt; requestError
<span class="line-numbers"> <a href="#n9" name="n9">9</a></span>
<span class="line-numbers"><strong><a href="#n10" name="n10">10</a></strong></span>  path resourcePath &gt;=&gt;
<span class="line-numbers"><a href="#n11" name="n11">11</a></span>    choose [
<span class="line-numbers"><a href="#n12" name="n12">12</a></span>      GET &gt;=&gt; getAll
<span class="line-numbers"><a href="#n13" name="n13">13</a></span>      POST &gt;=&gt;
<span class="line-numbers"><a href="#n14" name="n14">14</a></span>        request (getResourceFromReq &gt;&gt; resource.Create &gt;&gt; JSON)
<span class="line-numbers"><a href="#n15" name="n15">15</a></span>      PUT &gt;=&gt;
<span class="line-numbers"><a href="#n16" name="n16">16</a></span>        request (getResourceFromReq &gt;&gt; resource.Update &gt;&gt; handleResource badRequest)
<span class="line-numbers"><a href="#n17" name="n17">17</a></span>    ]
</pre></div>
</div>
</div>
<p>Then update <code>Db.fs</code> and <code>App.fs</code> as usual</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"> <a href="#n1" name="n1">1</a></span>module Db =   
<span class="line-numbers"> <a href="#n2" name="n2">2</a></span>  let updatePersonById personId personToBeUpdated =
<span class="line-numbers"> <a href="#n3" name="n3">3</a></span>    if peopleStorage.ContainsKey(personId) then
<span class="line-numbers"> <a href="#n4" name="n4">4</a></span>      let updatedPerson = {
<span class="line-numbers"> <a href="#n5" name="n5">5</a></span>        Id = personId
<span class="line-numbers"> <a href="#n6" name="n6">6</a></span>        Name = personToBeUpdated.Name
<span class="line-numbers"> <a href="#n7" name="n7">7</a></span>        Age = personToBeUpdated.Age
<span class="line-numbers"> <a href="#n8" name="n8">8</a></span>        Email = personToBeUpdated.Email
<span class="line-numbers"> <a href="#n9" name="n9">9</a></span>      }
<span class="line-numbers"><strong><a href="#n10" name="n10">10</a></strong></span>      peopleStorage.[personId] &lt;- updatedPerson            
<span class="line-numbers"><a href="#n11" name="n11">11</a></span>      Some updatedPerson
<span class="line-numbers"><a href="#n12" name="n12">12</a></span>    else
<span class="line-numbers"><a href="#n13" name="n13">13</a></span>      None
<span class="line-numbers"><a href="#n14" name="n14">14</a></span>  let updatePerson personToBeUpdated =
<span class="line-numbers"><a href="#n15" name="n15">15</a></span>    updatePersonById personToBeUpdated.Id personToBeUpdated
</pre></div>
</div>
</div>
<p>We have created one more function here <code>updatePersonById</code> which will be used later.</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"><a href="#n1" name="n1">1</a></span>let personWebPart = rest &quot;people&quot; {
<span class="line-numbers"><a href="#n2" name="n2">2</a></span>  GetAll = Db.getPeople
<span class="line-numbers"><a href="#n3" name="n3">3</a></span>  Create = Db.createPerson
<span class="line-numbers"><a href="#n4" name="n4">4</a></span>  Update = Db.updatePerson
<span class="line-numbers"><a href="#n5" name="n5">5</a></span>}
</pre></div>
</div>
</div>

<p><strong>Updating an existing resource</strong></p>

<p><img class="center border" src="/images/sauve_rest_api/http_put.png"></p>

<p><strong>Updating a non-existing resource</strong></p>

<p><img class="center border" src="/images/sauve_rest_api/http_put_error.png"></p>

<h2 id="http-delete">HTTP DELETE</h2>

<p>Let’s begin by updating the <code>RestResource</code></p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"><a href="#n1" name="n1">1</a></span>type RestResource&lt;'a&gt; = {
<span class="line-numbers"><a href="#n2" name="n2">2</a></span>  GetAll : unit -&gt; 'a seq
<span class="line-numbers"><a href="#n3" name="n3">3</a></span>  Create : 'a -&gt; 'a
<span class="line-numbers"><a href="#n4" name="n4">4</a></span>  Update : 'a -&gt; 'a option
<span class="line-numbers"><a href="#n5" name="n5">5</a></span>  Delete : int -&gt; unit    
<span class="line-numbers"><a href="#n6" name="n6">6</a></span>}
</pre></div>
</div>
</div>
<p>HTTP DELETE is little different from the other implemented requests as we will be retrieving the id of the resource to be deleted from the URL.</p>

<p>For example, <strong>DELETE /people/1</strong> will delete a person with the id 1.  </p>

<p>To retrieve the id from the url, we will be using the <code>pathScan</code> function in Suave. This function similar to <code>printf</code> which takes a <a href="">PrintfFormat</a> and a function which takes the output of the printfformat and returns the WebPart. You can get more details about it from the <a href="http://theimowski.gitbooks.io/suave-music-store/content/url_parameters.html">suave-music-store book</a>.</p>

<p>In addition to this, we will be using the following from suave</p>

<ul>
  <li>The <code>NO_CONTENT</code> is a static <code>WebPart</code> represents the HTTP Response with the status code 204</li>
  <li>The <code>DELETE</code> matches the HTTP request of type DELETE</li>
</ul>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"> <a href="#n1" name="n1">1</a></span>let rest resourceName resource =
<span class="line-numbers"> <a href="#n2" name="n2">2</a></span>
<span class="line-numbers"> <a href="#n3" name="n3">3</a></span>  let resourcePath = &quot;/&quot; + resourceName
<span class="line-numbers"> <a href="#n4" name="n4">4</a></span>  let resourceIdPath =
<span class="line-numbers"> <a href="#n5" name="n5">5</a></span>    new PrintfFormat&lt;(int -&gt; string),unit,string,string,int&gt;(resourcePath + &quot;/%d&quot;)
<span class="line-numbers"> <a href="#n6" name="n6">6</a></span>
<span class="line-numbers"> <a href="#n7" name="n7">7</a></span>  let badRequest = BAD_REQUEST &quot;Resource not found&quot;
<span class="line-numbers"> <a href="#n8" name="n8">8</a></span>
<span class="line-numbers"> <a href="#n9" name="n9">9</a></span>  let gellAll = warbler (fun _ -&gt; resource.GetAll () |&gt; JSON)
<span class="line-numbers"><strong><a href="#n10" name="n10">10</a></strong></span>  let handleResource requestError = function
<span class="line-numbers"><a href="#n11" name="n11">11</a></span>    | Some r -&gt; r |&gt; JSON
<span class="line-numbers"><a href="#n12" name="n12">12</a></span>    | _ -&gt; requestError
<span class="line-numbers"><a href="#n13" name="n13">13</a></span>  let deleteResourceById id =
<span class="line-numbers"><a href="#n14" name="n14">14</a></span>    resource.Delete id
<span class="line-numbers"><a href="#n15" name="n15">15</a></span>    NO_CONTENT
<span class="line-numbers"><a href="#n16" name="n16">16</a></span>
<span class="line-numbers"><a href="#n17" name="n17">17</a></span>  choose [
<span class="line-numbers"><a href="#n18" name="n18">18</a></span>    path resourcePath &gt;=&gt; choose [
<span class="line-numbers"><a href="#n19" name="n19">19</a></span>      GET &gt;=&gt; getAll
<span class="line-numbers"><strong><a href="#n20" name="n20">20</a></strong></span>      POST &gt;=&gt;
<span class="line-numbers"><a href="#n21" name="n21">21</a></span>        request (getResourceFromReq &gt;&gt; resource.Create &gt;&gt; JSON)
<span class="line-numbers"><a href="#n22" name="n22">22</a></span>      PUT &gt;=&gt;
<span class="line-numbers"><a href="#n23" name="n23">23</a></span>        request (getResourceFromReq &gt;&gt; resource.Update &gt;&gt; handleResource badRequest)
<span class="line-numbers"><a href="#n24" name="n24">24</a></span>    ]
<span class="line-numbers"><a href="#n25" name="n25">25</a></span>    DELETE &gt;=&gt; pathScan resourceIdPath deleteResourceById
<span class="line-numbers"><a href="#n26" name="n26">26</a></span>  ]
</pre></div>
</div>
</div>

<p>One thing to notice here is we have wrapped the existing <code>choose</code> function with an another <code>choose</code> function. It may be little complex to understand but if you understand what each thing mean, it is easier. Here the inner <code>choose</code> function represents the handler functions for GET, POST &amp; PUT requests having the url “/{resourceName}” and the <code>DELETE</code> webpart represents the HTTP DELETE handler for the url “/{resourceName}/{resourceId}”.</p>

<p>The outer <code>choose</code> function chooses one of these based on the incoming request.</p>

<p><strong>Db.fs</strong></p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"><a href="#n1" name="n1">1</a></span>let deletePerson personId =
<span class="line-numbers"><a href="#n2" name="n2">2</a></span>  peopleStorage.Remove(personId) |&gt; ignore
</pre></div>
</div>
</div>

<p><strong>App.fs</strong></p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"><a href="#n1" name="n1">1</a></span>let personWebPart = rest &quot;people&quot; {
<span class="line-numbers"><a href="#n2" name="n2">2</a></span>  GetAll = Db.getPeople
<span class="line-numbers"><a href="#n3" name="n3">3</a></span>  Create = Db.createPerson
<span class="line-numbers"><a href="#n4" name="n4">4</a></span>  Update = Db.updatePerson
<span class="line-numbers"><a href="#n5" name="n5">5</a></span>  Delete = Db.deletePerson
<span class="line-numbers"><a href="#n6" name="n6">6</a></span>}
</pre></div>
</div>
</div>
<p><img class="center border" src="/images/sauve_rest_api/http_delete.png"></p>

<h2 id="http-get--http-put-by-id">HTTP GET &amp; HTTP PUT by id</h2>

<p>I hope by this time you know how to wire things up in Suave to create an API. Let’s add features for getting and updating resource by id.</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"><a href="#n1" name="n1">1</a></span>type RestResource&lt;'a&gt; = {
<span class="line-numbers"><a href="#n2" name="n2">2</a></span>  GetAll : unit -&gt; 'a seq
<span class="line-numbers"><a href="#n3" name="n3">3</a></span>  Create : 'a -&gt; 'a
<span class="line-numbers"><a href="#n4" name="n4">4</a></span>  Update : 'a -&gt; 'a option
<span class="line-numbers"><a href="#n5" name="n5">5</a></span>  Delete : int -&gt; unit
<span class="line-numbers"><a href="#n6" name="n6">6</a></span>  GetById : int -&gt; 'a option
<span class="line-numbers"><a href="#n7" name="n7">7</a></span>  UpdateById : int -&gt; 'a -&gt; 'a option   
<span class="line-numbers"><a href="#n8" name="n8">8</a></span>}
</pre></div>
</div>
</div>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"> <a href="#n1" name="n1">1</a></span>let rest resourceName resource =
<span class="line-numbers"> <a href="#n2" name="n2">2</a></span>
<span class="line-numbers"> <a href="#n3" name="n3">3</a></span>  // .. Existing code ...
<span class="line-numbers"> <a href="#n4" name="n4">4</a></span>  let getResourceById =
<span class="line-numbers"> <a href="#n5" name="n5">5</a></span>    resource.GetById &gt;&gt; handleResource (NOT_FOUND &quot;Resource not found&quot;)
<span class="line-numbers"> <a href="#n6" name="n6">6</a></span>  let updateResourceById id =
<span class="line-numbers"> <a href="#n7" name="n7">7</a></span>    request (getResourceFromReq &gt;&gt; (resource.UpdateById id) &gt;&gt; handleResource badRequest)
<span class="line-numbers"> <a href="#n8" name="n8">8</a></span>
<span class="line-numbers"> <a href="#n9" name="n9">9</a></span>  choose [
<span class="line-numbers"><strong><a href="#n10" name="n10">10</a></strong></span>    path resourcePath &gt;=&gt; choose [
<span class="line-numbers"><a href="#n11" name="n11">11</a></span>      GET &gt;=&gt; getAll
<span class="line-numbers"><a href="#n12" name="n12">12</a></span>      POST &gt;=&gt;
<span class="line-numbers"><a href="#n13" name="n13">13</a></span>        request (getResourceFromReq &gt;&gt; resource.Create &gt;&gt; JSON)
<span class="line-numbers"><a href="#n14" name="n14">14</a></span>      PUT &gt;=&gt;
<span class="line-numbers"><a href="#n15" name="n15">15</a></span>        request (getResourceFromReq &gt;&gt; resource.Update &gt;&gt; handleResource badRequest)
<span class="line-numbers"><a href="#n16" name="n16">16</a></span>    ]
<span class="line-numbers"><a href="#n17" name="n17">17</a></span>    DELETE &gt;=&gt; pathScan resourceIdPath deleteResourceById
<span class="line-numbers"><a href="#n18" name="n18">18</a></span>    GET &gt;=&gt; pathScan resourceIdPath getResourceById
<span class="line-numbers"><a href="#n19" name="n19">19</a></span>    PUT &gt;=&gt; pathScan resourceIdPath updateResourceById
<span class="line-numbers"><strong><a href="#n20" name="n20">20</a></strong></span>  ]
</pre></div>
</div>
</div>

<p><strong>Db.fs</strong></p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"><a href="#n1" name="n1">1</a></span>let getPerson id =
<span class="line-numbers"><a href="#n2" name="n2">2</a></span>  if peopleStorage.ContainsKey(id) then
<span class="line-numbers"><a href="#n3" name="n3">3</a></span>    Some peopleStorage.[id]
<span class="line-numbers"><a href="#n4" name="n4">4</a></span>  else
<span class="line-numbers"><a href="#n5" name="n5">5</a></span>    None
</pre></div>
</div>
</div>

<p><strong>App.fs</strong></p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"><a href="#n1" name="n1">1</a></span>let personWebPart = rest &quot;people&quot; {
<span class="line-numbers"><a href="#n2" name="n2">2</a></span>  GetAll = Db.getPeople
<span class="line-numbers"><a href="#n3" name="n3">3</a></span>  Create = Db.createPerson
<span class="line-numbers"><a href="#n4" name="n4">4</a></span>  Update = Db.updatePerson
<span class="line-numbers"><a href="#n5" name="n5">5</a></span>  Delete = Db.deletePerson
<span class="line-numbers"><a href="#n6" name="n6">6</a></span>  GetById = Db.getPerson
<span class="line-numbers"><a href="#n7" name="n7">7</a></span>  UpdateById = Db.updatePersonById
<span class="line-numbers"><a href="#n8" name="n8">8</a></span>}
</pre></div>
</div>
</div>

<p><img class="center border" src="/images/sauve_rest_api/http_get_id.png"><br />
<img class="center border" src="/images/sauve_rest_api/http_put_id.png"></p>

<h2 id="http-head">HTTP HEAD</h2>

<p>Http HEAD request checks whether the request with the given id is there or not. Its implementation is straight forward.</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"> <a href="#n1" name="n1">1</a></span>type RestResource&lt;'a&gt; = {
<span class="line-numbers"> <a href="#n2" name="n2">2</a></span>  GetAll : unit -&gt; 'a seq
<span class="line-numbers"> <a href="#n3" name="n3">3</a></span>  Create : 'a -&gt; 'a
<span class="line-numbers"> <a href="#n4" name="n4">4</a></span>  Update : 'a -&gt; 'a option
<span class="line-numbers"> <a href="#n5" name="n5">5</a></span>  Delete : int -&gt; unit
<span class="line-numbers"> <a href="#n6" name="n6">6</a></span>  GetById : int -&gt; 'a option
<span class="line-numbers"> <a href="#n7" name="n7">7</a></span>  UpdateById : int -&gt; 'a -&gt; 'a option
<span class="line-numbers"> <a href="#n8" name="n8">8</a></span>  IsExists : int -&gt; bool
<span class="line-numbers"> <a href="#n9" name="n9">9</a></span>}
<span class="line-numbers"><strong><a href="#n10" name="n10">10</a></strong></span>
<span class="line-numbers"><a href="#n11" name="n11">11</a></span>let rest resourceName resource =
<span class="line-numbers"><a href="#n12" name="n12">12</a></span>
<span class="line-numbers"><a href="#n13" name="n13">13</a></span>  // .. Existing code ...
<span class="line-numbers"><a href="#n14" name="n14">14</a></span>  let isResourceExists id =
<span class="line-numbers"><a href="#n15" name="n15">15</a></span>    if resource.IsExists id then OK &quot;&quot; else NOT_FOUND &quot;&quot;
<span class="line-numbers"><a href="#n16" name="n16">16</a></span>
<span class="line-numbers"><a href="#n17" name="n17">17</a></span>  choose [
<span class="line-numbers"><a href="#n18" name="n18">18</a></span>    path resourcePath &gt;=&gt; choose [
<span class="line-numbers"><a href="#n19" name="n19">19</a></span>      GET &gt;=&gt; getAll
<span class="line-numbers"><strong><a href="#n20" name="n20">20</a></strong></span>      POST &gt;=&gt;
<span class="line-numbers"><a href="#n21" name="n21">21</a></span>        request (getResourceFromReq &gt;&gt; resource.Create &gt;&gt; JSON)
<span class="line-numbers"><a href="#n22" name="n22">22</a></span>      PUT &gt;=&gt;
<span class="line-numbers"><a href="#n23" name="n23">23</a></span>        request (getResourceFromReq &gt;&gt; resource.Update &gt;&gt; handleResource badRequest)
<span class="line-numbers"><a href="#n24" name="n24">24</a></span>    ]
<span class="line-numbers"><a href="#n25" name="n25">25</a></span>    DELETE &gt;=&gt; pathScan resourceIdPath deleteResourceById
<span class="line-numbers"><a href="#n26" name="n26">26</a></span>    GET &gt;=&gt; pathScan resourceIdPath getResourceById
<span class="line-numbers"><a href="#n27" name="n27">27</a></span>    PUT &gt;=&gt; pathScan resourceIdPath updateResourceById
<span class="line-numbers"><a href="#n28" name="n28">28</a></span>    HEAD &gt;=&gt; pathScan resourceIdPath isResourceExists
<span class="line-numbers"><a href="#n29" name="n29">29</a></span>  ]
</pre></div>
</div>
</div>
<p><strong>Db.fs</strong></p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"><a href="#n1" name="n1">1</a></span>let isPersonExists = peopleStorage.ContainsKey
</pre></div>
</div>
</div>

<p><strong>App.fs</strong></p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"> <a href="#n1" name="n1">1</a></span>let personWebPart = rest &quot;people&quot; {
<span class="line-numbers"> <a href="#n2" name="n2">2</a></span>  GetAll = Db.getPeople
<span class="line-numbers"> <a href="#n3" name="n3">3</a></span>  GetById = Db.getPerson
<span class="line-numbers"> <a href="#n4" name="n4">4</a></span>  Create = Db.createPerson
<span class="line-numbers"> <a href="#n5" name="n5">5</a></span>  Update = Db.updatePerson
<span class="line-numbers"> <a href="#n6" name="n6">6</a></span>  UpdateById = Db.updatePersonById
<span class="line-numbers"> <a href="#n7" name="n7">7</a></span>  Delete = Db.deletePerson
<span class="line-numbers"> <a href="#n8" name="n8">8</a></span>  IsExists = Db.isPersonExists
<span class="line-numbers"> <a href="#n9" name="n9">9</a></span>}
</pre></div>
</div>
</div>
<p><img class="center border" src="/images/sauve_rest_api/head.png"></p>

<p>That’s all.. We have successfully implemented a REST API using Suave</p>

<h2 id="extending-with-a-new-resource">Extending with a new Resource</h2>

<p>The beautiful aspect of this functional REST API design we can easily extend it to support other resources.</p>

<p>Here is the rest API implementation of the <code>albums</code> resource in the <a href="http://theimowski.gitbooks.io/suave-music-store/content/database.html">music-store</a> application. You can find the source code of MusicStoreDb <a href="https://github.com/tamizhvendan/blog-samples/blob/master/SuaveRestApi/SuaveRestApi/MusicStoreDb.fs">here</a>.</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"> <a href="#n1" name="n1">1</a></span>[&lt;EntryPoint&gt;]
<span class="line-numbers"> <a href="#n2" name="n2">2</a></span>let main argv =    
<span class="line-numbers"> <a href="#n3" name="n3">3</a></span>
<span class="line-numbers"> <a href="#n4" name="n4">4</a></span>  let personWebPart = rest &quot;people&quot; {
<span class="line-numbers"> <a href="#n5" name="n5">5</a></span>    GetAll = Db.getPeople
<span class="line-numbers"> <a href="#n6" name="n6">6</a></span>    GetById = Db.getPerson
<span class="line-numbers"> <a href="#n7" name="n7">7</a></span>    Create = Db.createPerson
<span class="line-numbers"> <a href="#n8" name="n8">8</a></span>    Update = Db.updatePerson
<span class="line-numbers"> <a href="#n9" name="n9">9</a></span>    UpdateById = Db.updatePersonById
<span class="line-numbers"><strong><a href="#n10" name="n10">10</a></strong></span>    Delete = Db.deletePerson
<span class="line-numbers"><a href="#n11" name="n11">11</a></span>    IsExists = Db.isPersonExists
<span class="line-numbers"><a href="#n12" name="n12">12</a></span>  }
<span class="line-numbers"><a href="#n13" name="n13">13</a></span>
<span class="line-numbers"><a href="#n14" name="n14">14</a></span>  let albumWebPart = rest &quot;albums&quot; {
<span class="line-numbers"><a href="#n15" name="n15">15</a></span>    GetAll = MusicStoreDb.getAlbums
<span class="line-numbers"><a href="#n16" name="n16">16</a></span>    GetById = MusicStoreDb.getAlbumById
<span class="line-numbers"><a href="#n17" name="n17">17</a></span>    Create = MusicStoreDb.createAlbum
<span class="line-numbers"><a href="#n18" name="n18">18</a></span>    Update = MusicStoreDb.updateAlbum
<span class="line-numbers"><a href="#n19" name="n19">19</a></span>    UpdateById = MusicStoreDb.updateAlbumById
<span class="line-numbers"><strong><a href="#n20" name="n20">20</a></strong></span>    Delete = MusicStoreDb.deleteAlbum
<span class="line-numbers"><a href="#n21" name="n21">21</a></span>    IsExists = MusicStoreDb.isAlbumExists
<span class="line-numbers"><a href="#n22" name="n22">22</a></span>  }
<span class="line-numbers"><a href="#n23" name="n23">23</a></span>
<span class="line-numbers"><a href="#n24" name="n24">24</a></span>  startWebServer defaultConfig (choose [personWebPart;albumWebPart])
<span class="line-numbers"><a href="#n25" name="n25">25</a></span>  0
</pre></div>
</div>
</div>

<p><img class="center border" src="/images/sauve_rest_api/get_album_id.png"></p>

<h2 id="conclusion">Conclusion</h2>

<p>In the amazing presentation on <a href="https://skillsmatter.com/skillscasts/6120-functional-programming-design-patterns-with-scott-wlaschin">Functional Programming Design Patterns</a>, Scott Wlaschin had this slide</p>

<p><img class="center border" src="/images/sauve_rest_api/fp_design_patterns_slide.png"></p>

<p>I wondered how this can be applied in real-time. By creating a rest API using suave I’ve understood this.</p>

<blockquote>
  <p>Just create functions and combine it to build a bigger system.</p>
</blockquote>

<p>What a nice way to develop a system!</p>

<p>You can get the source code associated with this blog post in <a href="https://github.com/tamizhvendan/blog-samples/tree/master/SuaveRestApi">my GitHub repository</a>.</p>
]]></content>
  </entry>
  
</feed>
