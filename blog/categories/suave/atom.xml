<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: suave | P3 Programmer]]></title>
  <link href="http://blog.tamizhvendan.in/blog/categories/suave/atom.xml" rel="self"/>
  <link href="http://blog.tamizhvendan.in/"/>
  <updated>2017-07-08T17:28:35+05:30</updated>
  <id>http://blog.tamizhvendan.in/</id>
  <author>
    <name><![CDATA[Tamizhvendan S]]></name>
    <email><![CDATA[tamizh88@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Implementing Two-Factor Authentication in Suave]]></title>
    <link href="http://blog.tamizhvendan.in/blog/2016/12/26/implementing-two-factor-authentication-in-suave/"/>
    <updated>2016-12-26T18:34:27+05:30</updated>
    <id>http://blog.tamizhvendan.in/blog/2016/12/26/implementing-two-factor-authentication-in-suave</id>
    <content type="html"><![CDATA[<p>Two-factor authentication is a type of <a href="https://en.wikipedia.org/wiki/Multi-factor_authentication">Multi-factor authentication</a> which adds an extra layer of security to the applications.</p>

<p><a href="https://en.wikipedia.org/wiki/Google_Authenticator">Google Authenticator</a> is one of the popular application that implements two-factor authentication services. In this blog post, we are going to learn how to implement Two-factor authentication in web applications developed using <a href="https://suave.io">suave</a></p>

<p>The idea presented here is a naive implementation of Two-factor authentication. The objective here is to demonstrate how to implement it in a functional programming language, F#. Things like TLS/HTTPS, preventing CSRF and other attacks are ignored for brevity. </p>

<blockquote>
  <p>This blog post is a part of <a href="https://sergeytihon.wordpress.com/2016/10/23/f-advent-calendar-in-english-2016/">fsharp advent calendar 2016</a>. </p>
</blockquote>

<h2 id="prerequisite">Prerequisite</h2>

<p>This blog post assumes that you are familiar with the concept of Two-factor authentication and Google Authenticator. </p>

<p>If you would like to know more about these, check out the below resources to get a picture of what it is all about.</p>

<ul>
  <li><a href="https://www.google.com/landing/2step">Two-step verification</a> by Google </li>
  <li><a href="https://garbagecollected.org/2014/09/14/how-google-authenticator-works/">How Google Authenticator works</a></li>
  <li><a href="https://security.stackexchange.com/questions/35157/how-does-google-authenticator-work">A Stack-Overflow Question</a></li>
</ul>

<p>We are going to use <a href="https://en.wikipedia.org/wiki/Time-based_One-time_Password_Algorithm">Time-based One-time Password(TOTP)</a> algorithm in this blog post</p>

<h2 id="what-we-will-be-building">What we will be building</h2>

<p>We are going to build a tiny web appliaction that has an inbuilt user account with the username <code>foo</code> and the password <code>bar</code></p>

<p><img class="center border" src="/images/suave_two_factor/Login.png" width="300" height="200"></p>

<p>After successful login, the user redirected to the <strong>Profile</strong> page where the user sees his name with a couple of buttons. One to enable <em>Two-factor authentication</em> and another one to <em>log out</em></p>

<p><img class="center border" src="/images/suave_two_factor/Profile.png" width="350" height="200"></p>

<p>Upon clicking the <em>Enable Two Factor Authentication</em> button, the user redirected to the <strong>Enable Two Factor Authentication</strong> page where the user has to scan the QR Code with the Google Authenticator App (For <a href="https://play.google.com/store/apps/details?id=com.google.android.apps.authenticator2&amp;hl=en">Android</a> or <a href="https://itunes.apple.com/in/app/google-authenticator/id388497605?mt=8">iPhone</a>). Then he needs to enter the verification code to enable Two-factor authentication for his account. </p>

<p><img class="center border" src="/images/suave_two_factor/Enable_Two_Factor.png" width="450" height="250"></p>

<p><em>Google Authenticator App</em></p>

<p><img class="center border" src="/images/suave_two_factor/Google_Authenticator.png" width="200" height="400"></p>

<p>If the verification code matches, the updated <strong>Profile</strong> page will look like </p>

<p><img class="center border" src="/images/suave_two_factor/Profile_After_Two_Factor.png" width="350" height="200"></p>

<p>Now if the user logout and login again, he will be prompted to enter the verification code </p>

<p><img class="center border" src="/images/suave_two_factor/Auth_Code_Prompt.png" width="250" height="150"></p>

<p>After entering the verification code from the Google Authenticator, the user will be redirected to his <strong>Profile</strong> page. </p>

<h2 id="getting-started">Getting Started</h2>

<p>Create a new <strong>F# Console Project</strong> with the name <em>Suave.TwoFactorAuth</em> and use Paket to install the following dependencies. </p>

<p><em>paket.dependencies</em></p>

<pre><code>nuget FSharp.Core
nuget Suave
nuget DotLiquid
nuget Suave.DotLiquid
nuget OtpSharp
</code></pre>

<p>Then reference them in the <em>Suave.TwoFactorAuth</em> project.</p>

<p><em>Suave.TwoFactorAuth/paket.references</em></p>

<pre><code>FSharp.Core
Suave
DotLiquid
Suave.DotLiquid
OtpSharp
</code></pre>

<p>The <a href="https://www.nuget.org/packages/OtpSharp/">OtpSharp</a> is an .NET library that we will be using to generate keys and to verify the verification code from Google Authenticator app using the <a href="https://en.wikipedia.org/wiki/Time-based_One-time_Password_Algorithm">TOTP</a> algorithm.</p>

<p>The reference to <a href="https://www.nuget.org/packages/DotLiquid/">DotLiquid</a> library is required to render the templates using <a href="https://www.nuget.org/packages/Suave.DotLiquid/">Suave.DotLiquid</a></p>

<h2 id="initializing-dotliquid">Initializing DotLiquid</h2>

<p>To use <a href="https://github.com/Shopify/liquid/wiki/Liquid-for-Designers">DotLiquid</a> to render the views in Suave, we need to set the templates directory explicitly. </p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"> <a href="#n1" name="n1">1</a></span>// Suave.TwoFactorAuth/Suave.TwoFactorAuth.fs
<span class="line-numbers"> <a href="#n2" name="n2">2</a></span>module Suave.TwoFactorAuth.Main
<span class="line-numbers"> <a href="#n3" name="n3">3</a></span>
<span class="line-numbers"> <a href="#n4" name="n4">4</a></span>open Suave
<span class="line-numbers"> <a href="#n5" name="n5">5</a></span>open System.IO
<span class="line-numbers"> <a href="#n6" name="n6">6</a></span>open System.Reflection
<span class="line-numbers"> <a href="#n7" name="n7">7</a></span>open Suave.DotLiquid
<span class="line-numbers"> <a href="#n8" name="n8">8</a></span>
<span class="line-numbers"> <a href="#n9" name="n9">9</a></span>let initializeDotLiquid () =
<span class="line-numbers"><strong><a href="#n10" name="n10">10</a></strong></span>  let currentDirectory =
<span class="line-numbers"><a href="#n11" name="n11">11</a></span>    let mainExeFileInfo = 
<span class="line-numbers"><a href="#n12" name="n12">12</a></span>      new FileInfo(Assembly.GetEntryAssembly().Location)
<span class="line-numbers"><a href="#n13" name="n13">13</a></span>    mainExeFileInfo.Directory
<span class="line-numbers"><a href="#n14" name="n14">14</a></span>  Path.Combine(currentDirectory.FullName, &quot;views&quot;) 
<span class="line-numbers"><a href="#n15" name="n15">15</a></span>  |&gt; setTemplatesDir
<span class="line-numbers"><a href="#n16" name="n16">16</a></span>
<span class="line-numbers"><a href="#n17" name="n17">17</a></span>[&lt;EntryPoint&gt;]
<span class="line-numbers"><a href="#n18" name="n18">18</a></span>let main argv =  
<span class="line-numbers"><a href="#n19" name="n19">19</a></span>  initializeDotLiquid ()
<span class="line-numbers"><strong><a href="#n20" name="n20">20</a></strong></span>  0
</pre></div>
</div>
</div>

<p>In this sample application we are going to create a directory <em>views</em>. This <em>views</em> directory will contain the liquid templates of our appliaction</p>

<h2 id="serving-the-login-page">Serving the Login Page</h2>

<p>Let’s start by serving the Login page. </p>

<p>Create a new directory with the name <em>views</em> in the <em>Suave.TwoFactorAuth</em> project and add a new liquid template <em>page.liquid</em>. This <em>page.liquid</em> is the master template for our application</p>

<p><img class="center border" src="/images/suave_two_factor/page.png" width="300" height="300"></p>

<p>After creating, change the ‘Copy to output’ property of the <em>page.liquid</em> file to ‘Copy if newer’ so that the view files copied to the build output directory. </p>

<p>This step is applicable for all the other view templates that we will be creating later</p>

<blockquote>
  <p>If you are using VS Code or atom editor, you need to do this property change manually by opening the <em>Suave.TwoFactorAuth.fsproj</em> file </p>
</blockquote>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"> <a href="#n1" name="n1">1</a></span><span class="comment">&lt;!-- .... --&gt;</span>
<span class="line-numbers"> <a href="#n2" name="n2">2</a></span><span class="tag">&lt;ItemGroup&gt;</span>
<span class="line-numbers"> <a href="#n3" name="n3">3</a></span>  <span class="tag">&lt;Folder</span> <span class="attribute-name">Include</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">views\</span><span class="delimiter">&quot;</span></span> <span class="tag">/&gt;</span>
<span class="line-numbers"> <a href="#n4" name="n4">4</a></span><span class="tag">&lt;/ItemGroup&gt;</span>
<span class="line-numbers"> <a href="#n5" name="n5">5</a></span><span class="tag">&lt;ItemGroup&gt;</span>
<span class="line-numbers"> <a href="#n6" name="n6">6</a></span>  <span class="tag">&lt;None</span> <span class="attribute-name">Include</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">views\page.liquid</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
<span class="line-numbers"> <a href="#n7" name="n7">7</a></span>    <span class="tag">&lt;CopyToOutputDirectory&gt;</span>PreserveNewest<span class="tag">&lt;/CopyToOutputDirectory&gt;</span>
<span class="line-numbers"> <a href="#n8" name="n8">8</a></span>  <span class="tag">&lt;/None&gt;</span>
<span class="line-numbers"> <a href="#n9" name="n9">9</a></span><span class="tag">&lt;/ItemGroup&gt;</span>
<span class="line-numbers"><strong><a href="#n10" name="n10">10</a></strong></span><span class="comment">&lt;!-- .... --&gt;</span>
</pre></div>
</div>
</div>

<p>Then create a new template file <em>login.liquid</em> in the <em>views</em> directory </p>

<p><img class="center border" src="/images/suave_two_factor/login_view.png" width="500" height="300"></p>

<p>The <em>login.liquid</em> view extends the <em>page.liquid</em> view and fill the placeholders for <code>head</code> and <code>content</code>.</p>

<p>To display the error messages like <em>Password didn’t match</em>, <em>login.liquid</em> view bounded to the model of type <code>string</code>. </p>

<p>Now we have the view template for the login page ready and the next step is to render it upon receiving an HTTP request.</p>

<p>Create a new fsharp source file <em>Login.fs</em> and update it as below</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"> <a href="#n1" name="n1">1</a></span>module Suave.TwoFactorAuth.Login
<span class="line-numbers"> <a href="#n2" name="n2">2</a></span>
<span class="line-numbers"> <a href="#n3" name="n3">3</a></span>open Suave
<span class="line-numbers"> <a href="#n4" name="n4">4</a></span>open Suave.DotLiquid
<span class="line-numbers"> <a href="#n5" name="n5">5</a></span>open Suave.Filters
<span class="line-numbers"> <a href="#n6" name="n6">6</a></span>open Suave.Operators
<span class="line-numbers"> <a href="#n7" name="n7">7</a></span>
<span class="line-numbers"> <a href="#n8" name="n8">8</a></span>let loginPath = &quot;/login&quot;
<span class="line-numbers"> <a href="#n9" name="n9">9</a></span>
<span class="line-numbers"><strong><a href="#n10" name="n10">10</a></strong></span>let renderLoginView (request : HttpRequest) =
<span class="line-numbers"><a href="#n11" name="n11">11</a></span>  let errMsg =
<span class="line-numbers"><a href="#n12" name="n12">12</a></span>    match request.[&quot;err&quot;] with
<span class="line-numbers"><a href="#n13" name="n13">13</a></span>    | Some msg -&gt; msg
<span class="line-numbers"><a href="#n14" name="n14">14</a></span>    | _ -&gt; &quot;&quot;
<span class="line-numbers"><a href="#n15" name="n15">15</a></span>  page &quot;login.liquid&quot; errMsg
<span class="line-numbers"><a href="#n16" name="n16">16</a></span>
<span class="line-numbers"><a href="#n17" name="n17">17</a></span>let loginWebPart =
<span class="line-numbers"><a href="#n18" name="n18">18</a></span>  path loginPath &gt;=&gt; choose [
<span class="line-numbers"><a href="#n19" name="n19">19</a></span>      GET &gt;=&gt; request renderLoginView]
</pre></div>
</div>
</div>

<p>As a good practice let’s create a new module <code>Web</code> which will be containing all the WebParts of the application</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"><a href="#n1" name="n1">1</a></span>// Suave.TwoFactorAuth/Suave.Web.fs
<span class="line-numbers"><a href="#n2" name="n2">2</a></span>open Suave
<span class="line-numbers"><a href="#n3" name="n3">3</a></span>open Login
<span class="line-numbers"><a href="#n4" name="n4">4</a></span>
<span class="line-numbers"><a href="#n5" name="n5">5</a></span>let app =   
<span class="line-numbers"><a href="#n6" name="n6">6</a></span>  choose [
<span class="line-numbers"><a href="#n7" name="n7">7</a></span>    loginWebPart]
</pre></div>
</div>
</div>

<p>Then start the Web Server</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"><a href="#n1" name="n1">1</a></span>// Suave.TwoFactorAuth/Suave.TwoFactorAuth.fs
<span class="line-numbers"><a href="#n2" name="n2">2</a></span>// ...
<span class="line-numbers"><a href="#n3" name="n3">3</a></span>open Web
<span class="line-numbers"><a href="#n4" name="n4">4</a></span>// ...
<span class="line-numbers"><a href="#n5" name="n5">5</a></span>let main argv =  
<span class="line-numbers"><a href="#n6" name="n6">6</a></span>  // ...
<span class="line-numbers"><a href="#n7" name="n7">7</a></span>  startWebServer defaultConfig app
<span class="line-numbers"><a href="#n8" name="n8">8</a></span>  0 
</pre></div>
</div>
</div>

<blockquote>
  <p>Keeping all the Suave WebParts in a single place like we did in the <code>Web.fs</code> file, enable us to host Suave in <a href="https://www.nuget.org/packages/Suave.Azure.Functions">Azure Functions</a> or <a href="https://dusted.codes/running-suave-in-aspnet-core-and-on-top-of-kestrel">Asp.Net Core</a> without doing any significant changes. </p>
</blockquote>

<h2 id="handling-user-login">Handling User Login</h2>

<p>To handle the login request from the user, we need to have some users in the application. Let’s hardcode a user account. </p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"> <a href="#n1" name="n1">1</a></span>// Suave.TwoFactorAuth/Suave.TwoFactorAuth.fs
<span class="line-numbers"> <a href="#n2" name="n2">2</a></span>module Suave.TwoFactorAuth.User
<span class="line-numbers"> <a href="#n3" name="n3">3</a></span>
<span class="line-numbers"> <a href="#n4" name="n4">4</a></span>open System.Collections.Generic
<span class="line-numbers"> <a href="#n5" name="n5">5</a></span>
<span class="line-numbers"> <a href="#n6" name="n6">6</a></span>type User = {
<span class="line-numbers"> <a href="#n7" name="n7">7</a></span>  Username : string
<span class="line-numbers"> <a href="#n8" name="n8">8</a></span>  Password : string
<span class="line-numbers"> <a href="#n9" name="n9">9</a></span>}
<span class="line-numbers"><strong><a href="#n10" name="n10">10</a></strong></span>
<span class="line-numbers"><a href="#n11" name="n11">11</a></span>let private users = new Dictionary&lt;string, User&gt;()
<span class="line-numbers"><a href="#n12" name="n12">12</a></span>
<span class="line-numbers"><a href="#n13" name="n13">13</a></span>users.Add(&quot;foo&quot;, {Username = &quot;foo&quot;; Password = &quot;bar&quot;})
<span class="line-numbers"><a href="#n14" name="n14">14</a></span>
<span class="line-numbers"><a href="#n15" name="n15">15</a></span>let getUser username = 
<span class="line-numbers"><a href="#n16" name="n16">16</a></span>  match users.TryGetValue username with
<span class="line-numbers"><a href="#n17" name="n17">17</a></span>  | true, user -&gt; Some user
<span class="line-numbers"><a href="#n18" name="n18">18</a></span>  | _ -&gt; None
</pre></div>
</div>
</div>

<p>Post successful login, to serve the subsequent requests we need to identify the user who logged in. We can achieve it Suave using <code>statefulForSession</code>, which initializes a user state for a browsing session. </p>

<p>Let’s create some helper functions to do this. </p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"> <a href="#n1" name="n1">1</a></span>// Suave.TwoFactorAuth/Combinators.fs
<span class="line-numbers"> <a href="#n2" name="n2">2</a></span>module Suave.TwoFactorAuth.Combinators
<span class="line-numbers"> <a href="#n3" name="n3">3</a></span>
<span class="line-numbers"> <a href="#n4" name="n4">4</a></span>open Suave.State.CookieStateStore
<span class="line-numbers"> <a href="#n5" name="n5">5</a></span>open Suave.Cookie
<span class="line-numbers"> <a href="#n6" name="n6">6</a></span>open Suave
<span class="line-numbers"> <a href="#n7" name="n7">7</a></span>open Suave.Operators
<span class="line-numbers"> <a href="#n8" name="n8">8</a></span>open Suave.Authentication
<span class="line-numbers"> <a href="#n9" name="n9">9</a></span>
<span class="line-numbers"><strong><a href="#n10" name="n10">10</a></strong></span>let sessionSet failureF key value = 
<span class="line-numbers"><a href="#n11" name="n11">11</a></span>  statefulForSession
<span class="line-numbers"><a href="#n12" name="n12">12</a></span>  &gt;=&gt; context (fun ctx -&gt;
<span class="line-numbers"><a href="#n13" name="n13">13</a></span>                match HttpContext.state ctx with
<span class="line-numbers"><a href="#n14" name="n14">14</a></span>                | Some state -&gt; state.set key value
<span class="line-numbers"><a href="#n15" name="n15">15</a></span>                | _ -&gt; failureF
<span class="line-numbers"><a href="#n16" name="n16">16</a></span>              )
<span class="line-numbers"><a href="#n17" name="n17">17</a></span>
<span class="line-numbers"><a href="#n18" name="n18">18</a></span>let sessionGet failureF key successF = 
<span class="line-numbers"><a href="#n19" name="n19">19</a></span>  statefulForSession 
<span class="line-numbers"><strong><a href="#n20" name="n20">20</a></strong></span>  &gt;=&gt; context (fun ctx -&gt;
<span class="line-numbers"><a href="#n21" name="n21">21</a></span>                match HttpContext.state ctx with
<span class="line-numbers"><a href="#n22" name="n22">22</a></span>                | Some store -&gt; 
<span class="line-numbers"><a href="#n23" name="n23">23</a></span>                  match store.get key with
<span class="line-numbers"><a href="#n24" name="n24">24</a></span>                  | Some value -&gt; successF value
<span class="line-numbers"><a href="#n25" name="n25">25</a></span>                  | _ -&gt; failureF
<span class="line-numbers"><a href="#n26" name="n26">26</a></span>                | _ -&gt; failureF
<span class="line-numbers"><a href="#n27" name="n27">27</a></span>  )
<span class="line-numbers"><a href="#n28" name="n28">28</a></span>
<span class="line-numbers"><a href="#n29" name="n29">29</a></span>let clearSession = 
<span class="line-numbers"><strong><a href="#n30" name="n30">30</a></strong></span>  unsetPair SessionAuthCookie
<span class="line-numbers"><a href="#n31" name="n31">31</a></span>    &gt;=&gt; unsetPair StateCookie
<span class="line-numbers"><a href="#n32" name="n32">32</a></span>
</pre></div>
</div>
</div>

<p>The <code>sessionSet</code> function takes a WebPart and a key value pair and tries to persist the value in the session state with the given key. If it fails, it calls the WebPart. </p>

<p>The <code>sessionGet</code> function takes a success WebPart Combinator, a failure WebPart, and a key. If retrieving the value from session state is successful it calls the success WebPart combinator with the retrieved value. In case of retrieval failure it calls the failure WebPart</p>

<p>The <code>clearSession</code> function clears the state. We will be using it while implementing <em>log out</em></p>

<p>Now we have all the building blocks for handling user login request, and it’s time to start its implementation</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"> <a href="#n1" name="n1">1</a></span>// Suave.TwoFactorAuth/Login.fs
<span class="line-numbers"> <a href="#n2" name="n2">2</a></span>// ...
<span class="line-numbers"> <a href="#n3" name="n3">3</a></span>open Suave.Redirection
<span class="line-numbers"> <a href="#n4" name="n4">4</a></span>open Suave.Authentication
<span class="line-numbers"> <a href="#n5" name="n5">5</a></span>open Suave.Cookie
<span class="line-numbers"> <a href="#n6" name="n6">6</a></span>
<span class="line-numbers"> <a href="#n7" name="n7">7</a></span>open Combinators
<span class="line-numbers"> <a href="#n8" name="n8">8</a></span>open User
<span class="line-numbers"> <a href="#n9" name="n9">9</a></span>// ...
<span class="line-numbers"><strong><a href="#n10" name="n10">10</a></strong></span>let userSessionKey = &quot;loggedUser&quot;
<span class="line-numbers"><a href="#n11" name="n11">11</a></span>
<span class="line-numbers"><a href="#n12" name="n12">12</a></span>let redirectToLogin = function
<span class="line-numbers"><a href="#n13" name="n13">13</a></span>  | Some errMsg -&gt; FOUND (sprintf &quot;%s?err=%s&quot; loginPath errMsg)
<span class="line-numbers"><a href="#n14" name="n14">14</a></span>  | None -&gt; FOUND loginPath
<span class="line-numbers"><a href="#n15" name="n15">15</a></span>
<span class="line-numbers"><a href="#n16" name="n16">16</a></span>let loginSucess failureW redirectPath username =
<span class="line-numbers"><a href="#n17" name="n17">17</a></span>  authenticated Cookie.CookieLife.Session false      
<span class="line-numbers"><a href="#n18" name="n18">18</a></span>    &gt;=&gt; sessionSet failureW userSessionKey username
<span class="line-numbers"><a href="#n19" name="n19">19</a></span>    &gt;=&gt; FOUND redirectPath
<span class="line-numbers"><strong><a href="#n20" name="n20">20</a></strong></span>
<span class="line-numbers"><a href="#n21" name="n21">21</a></span>let onLogin redirectPath (request : HttpRequest) = 
<span class="line-numbers"><a href="#n22" name="n22">22</a></span>  match request.[&quot;Username&quot;], request.[&quot;Password&quot;] with
<span class="line-numbers"><a href="#n23" name="n23">23</a></span>  | Some username, Some password -&gt; 
<span class="line-numbers"><a href="#n24" name="n24">24</a></span>    match getUser username with
<span class="line-numbers"><a href="#n25" name="n25">25</a></span>    | Some user -&gt; 
<span class="line-numbers"><a href="#n26" name="n26">26</a></span>      match user.Password = password with
<span class="line-numbers"><a href="#n27" name="n27">27</a></span>      | true -&gt; loginSucess never redirectPath username
<span class="line-numbers"><a href="#n28" name="n28">28</a></span>      | _ -&gt; redirectToLogin (Some &quot;Password didn't match&quot;)
<span class="line-numbers"><a href="#n29" name="n29">29</a></span>    | _ -&gt; redirectToLogin (Some &quot;Invalid username&quot;)   
<span class="line-numbers"><strong><a href="#n30" name="n30">30</a></strong></span>  | _ -&gt; redirectToLogin (Some &quot;Invalid request&quot;)
<span class="line-numbers"><a href="#n31" name="n31">31</a></span>
<span class="line-numbers"><a href="#n32" name="n32">32</a></span>let secured webpart = 
<span class="line-numbers"><a href="#n33" name="n33">33</a></span>  let onFail = redirectToLogin (Some &quot;sign-in to access&quot;)
<span class="line-numbers"><a href="#n34" name="n34">34</a></span>  sessionGet onFail userSessionKey webpart
<span class="line-numbers"><a href="#n35" name="n35">35</a></span>
<span class="line-numbers"><a href="#n36" name="n36">36</a></span>let loginWebPart redirectPath =
<span class="line-numbers"><a href="#n37" name="n37">37</a></span>  path loginPath &gt;=&gt; choose [
<span class="line-numbers"><a href="#n38" name="n38">38</a></span>      // ...
<span class="line-numbers"><a href="#n39" name="n39">39</a></span>      POST &gt;=&gt; request (onLogin redirectPath)]
<span class="line-numbers"><strong><a href="#n40" name="n40">40</a></strong></span>
</pre></div>
</div>
</div>

<p>The key function to note here is <code>secured</code> that takes a WebPart. It calls this WebPart only if the user has logged in. If he didn’t the user will be redirected to the Login page</p>

<p>After successful login, we need to redirect the user to his profile page. Let’s create a <code>profile.liquid</code> a view template for the Profile page</p>

<p><img class="center border" src="/images/suave_two_factor/profile_view.png" width="600" height="450"></p>

<p>To render this profile page let’s add some code </p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"> <a href="#n1" name="n1">1</a></span>// Suave.TwoFactorAuth/Profile.fs
<span class="line-numbers"> <a href="#n2" name="n2">2</a></span>module Suave.TwoFactorAuth.Profile
<span class="line-numbers"> <a href="#n3" name="n3">3</a></span>
<span class="line-numbers"> <a href="#n4" name="n4">4</a></span>open Suave.DotLiquid
<span class="line-numbers"> <a href="#n5" name="n5">5</a></span>open Suave.Redirection
<span class="line-numbers"> <a href="#n6" name="n6">6</a></span>open Suave.Filters
<span class="line-numbers"> <a href="#n7" name="n7">7</a></span>open Suave.Operators
<span class="line-numbers"> <a href="#n8" name="n8">8</a></span>
<span class="line-numbers"> <a href="#n9" name="n9">9</a></span>open User
<span class="line-numbers"><strong><a href="#n10" name="n10">10</a></strong></span>open Login
<span class="line-numbers"><a href="#n11" name="n11">11</a></span>
<span class="line-numbers"><a href="#n12" name="n12">12</a></span>type ProfileViewModel = {
<span class="line-numbers"><a href="#n13" name="n13">13</a></span>  Username: string
<span class="line-numbers"><a href="#n14" name="n14">14</a></span>  SecretKey : string
<span class="line-numbers"><a href="#n15" name="n15">15</a></span>  IsTwoFactorAuthEnabled : bool
<span class="line-numbers"><a href="#n16" name="n16">16</a></span>}
<span class="line-numbers"><a href="#n17" name="n17">17</a></span>with static member FromUser user =          
<span class="line-numbers"><a href="#n18" name="n18">18</a></span>        {
<span class="line-numbers"><a href="#n19" name="n19">19</a></span>          SecretKey = &quot;&quot;
<span class="line-numbers"><strong><a href="#n20" name="n20">20</a></strong></span>          IsTwoFactorAuthEnabled = false
<span class="line-numbers"><a href="#n21" name="n21">21</a></span>          Username = user.Username
<span class="line-numbers"><a href="#n22" name="n22">22</a></span>        }
<span class="line-numbers"><a href="#n23" name="n23">23</a></span>
<span class="line-numbers"><a href="#n24" name="n24">24</a></span>let profilePath = &quot;/profile&quot;
<span class="line-numbers"><a href="#n25" name="n25">25</a></span>
<span class="line-numbers"><a href="#n26" name="n26">26</a></span>let renderProfile notFoundPath username =
<span class="line-numbers"><a href="#n27" name="n27">27</a></span>  match getUser username with
<span class="line-numbers"><a href="#n28" name="n28">28</a></span>  | Some user -&gt; 
<span class="line-numbers"><a href="#n29" name="n29">29</a></span>    user    
<span class="line-numbers"><strong><a href="#n30" name="n30">30</a></strong></span>    |&gt; ProfileViewModel.FromUser
<span class="line-numbers"><a href="#n31" name="n31">31</a></span>    |&gt; page &quot;profile.liquid&quot;
<span class="line-numbers"><a href="#n32" name="n32">32</a></span>  | _ -&gt; FOUND notFoundPath
<span class="line-numbers"><a href="#n33" name="n33">33</a></span>
<span class="line-numbers"><a href="#n34" name="n34">34</a></span>let profileWebPart notFoundPath = 
<span class="line-numbers"><a href="#n35" name="n35">35</a></span>  path profilePath &gt;=&gt; secured (renderProfile notFoundPath)
</pre></div>
</div>
</div>

<p>The labels <code>IsTwoFactorAuthEnabled</code>, <code>SecretKey</code> are just blank right now, and we will be seeing them in action while adding two-factor authentication</p>

<p>The <code>notfound.liquid</code> page that is going to our fancy <code>404</code> page</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"><a href="#n1" name="n1">1</a></span><span class="comment">&lt;!-- Suave.TwoFactorAuth/views/not_found.liquid --&gt;</span>
<span class="line-numbers"><a href="#n2" name="n2">2</a></span>Not Found :(
</pre></div>
</div>
</div>

<p>The final step is to put these WebParts together</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"> <a href="#n1" name="n1">1</a></span>// Suave.TwoFactorAuth/Web.fs
<span class="line-numbers"> <a href="#n2" name="n2">2</a></span>// ...
<span class="line-numbers"> <a href="#n3" name="n3">3</a></span>open Profile
<span class="line-numbers"> <a href="#n4" name="n4">4</a></span>open Suave.DotLiquid
<span class="line-numbers"> <a href="#n5" name="n5">5</a></span>open Suave.Filters
<span class="line-numbers"> <a href="#n6" name="n6">6</a></span>open Suave.Operators
<span class="line-numbers"> <a href="#n7" name="n7">7</a></span>
<span class="line-numbers"> <a href="#n8" name="n8">8</a></span>let notFoundPath = &quot;/notfound&quot;
<span class="line-numbers"> <a href="#n9" name="n9">9</a></span>
<span class="line-numbers"><strong><a href="#n10" name="n10">10</a></strong></span>let app =   
<span class="line-numbers"><a href="#n11" name="n11">11</a></span>  choose [
<span class="line-numbers"><a href="#n12" name="n12">12</a></span>    loginWebPart profilePath
<span class="line-numbers"><a href="#n13" name="n13">13</a></span>    profileWebPart notFoundPath
<span class="line-numbers"><a href="#n14" name="n14">14</a></span>    path notFoundPath &gt;=&gt; page &quot;not_found.liquid&quot; &quot;&quot;    
<span class="line-numbers"><a href="#n15" name="n15">15</a></span>  ]
</pre></div>
</div>
</div>

<h2 id="handling-logout">Handling Logout</h2>

<p>Handling logout is a simpler task as we have all the infrastructure already in place. </p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"> <a href="#n1" name="n1">1</a></span>// Suave.TwoFactorAuth/Web.fs
<span class="line-numbers"> <a href="#n2" name="n2">2</a></span>// ...
<span class="line-numbers"> <a href="#n3" name="n3">3</a></span>open Combinators
<span class="line-numbers"> <a href="#n4" name="n4">4</a></span>open Login 
<span class="line-numbers"> <a href="#n5" name="n5">5</a></span>// ...
<span class="line-numbers"> <a href="#n6" name="n6">6</a></span>
<span class="line-numbers"> <a href="#n7" name="n7">7</a></span>let app =   
<span class="line-numbers"> <a href="#n8" name="n8">8</a></span>  choose [
<span class="line-numbers"> <a href="#n9" name="n9">9</a></span>    // ...
<span class="line-numbers"><strong><a href="#n10" name="n10">10</a></strong></span>    path &quot;/logout&quot; &gt;=&gt; clearSession &gt;=&gt; redirectToLogin None  
<span class="line-numbers"><a href="#n11" name="n11">11</a></span>  ]
</pre></div>
</div>
</div>

<h2 id="enabling-two-factor-authentication">Enabling Two-factor Authentication</h2>

<p>To enable Two-factor authentication, we need to change our <code>User</code> domain model first. </p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"> <a href="#n1" name="n1">1</a></span>// Suave.TwoFactorAuth/User.fs
<span class="line-numbers"> <a href="#n2" name="n2">2</a></span>// ...
<span class="line-numbers"> <a href="#n3" name="n3">3</a></span>type TwoFactorAuthentication =
<span class="line-numbers"> <a href="#n4" name="n4">4</a></span>| Enabled of SecretKey:string
<span class="line-numbers"> <a href="#n5" name="n5">5</a></span>| Disabled
<span class="line-numbers"> <a href="#n6" name="n6">6</a></span>
<span class="line-numbers"> <a href="#n7" name="n7">7</a></span>type User = {
<span class="line-numbers"> <a href="#n8" name="n8">8</a></span>  // ...
<span class="line-numbers"> <a href="#n9" name="n9">9</a></span>  TwoFactorAuthentication : TwoFactorAuthentication
<span class="line-numbers"><strong><a href="#n10" name="n10">10</a></strong></span>}
<span class="line-numbers"><a href="#n11" name="n11">11</a></span>// ... 
<span class="line-numbers"><a href="#n12" name="n12">12</a></span>// Let's assume TwoFactorAuthentication is disabled by default 
<span class="line-numbers"><a href="#n13" name="n13">13</a></span>users.Add(&quot;foo&quot;, {Username = &quot;foo&quot;; Password = &quot;bar&quot;; TwoFactorAuthentication = Disabled})
<span class="line-numbers"><a href="#n14" name="n14">14</a></span>// ...
<span class="line-numbers"><a href="#n15" name="n15">15</a></span>let enableTwoFactorAuth username key =
<span class="line-numbers"><a href="#n16" name="n16">16</a></span>  match getUser username with
<span class="line-numbers"><a href="#n17" name="n17">17</a></span>  | Some user -&gt;
<span class="line-numbers"><a href="#n18" name="n18">18</a></span>    users.[username] &lt;- {user with TwoFactorAuthentication = Enabled key}
<span class="line-numbers"><a href="#n19" name="n19">19</a></span>  | _ -&gt; ()
</pre></div>
</div>
</div>

<p>The next step is to define a liquid view template for the <code>enable_two_factor</code> page.</p>

<p><img class="center border" src="/images/suave_two_factor/enable_two_factor_view.png" width="600" height="450"></p>

<p>While enabling the Two-factor authentication, we need to generate a secret key for the user that will be required for both, one-time verification code generation as well as its verification.</p>

<p>So, in the <em>enable_two_factor.liquid</em> template we pass the generated <code>SecretKey</code> as a <code>hidden</code> input which will then be used for the verification of the code. </p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"><a href="#n1" name="n1">1</a></span><span class="tag">&lt;input</span> <span class="attribute-name">type</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">hidden</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">SecretKey</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content"></span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
</pre></div>
</div>
</div>

<p>Now we need to render the <code>enable_two_factor</code> page in response to the <em>HTTP GET</em> request <code>/enable_two_factor</code></p>

<p><img class="center border" src="/images/suave_two_factor/Enable_Two_Factor.png" width="450" height="250"></p>

<p>Let’s create a new module <code>GoogleAuthenticator</code> to put the Two-factor authentication related functions together</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"> <a href="#n1" name="n1">1</a></span>// Suave.TwoFactorAuth/GoogleAuthenticator.fs
<span class="line-numbers"> <a href="#n2" name="n2">2</a></span>module Suave.TwoFactorAuth.GoogleAuthenticator
<span class="line-numbers"> <a href="#n3" name="n3">3</a></span>
<span class="line-numbers"> <a href="#n4" name="n4">4</a></span>open Suave
<span class="line-numbers"> <a href="#n5" name="n5">5</a></span>open Suave.Filters
<span class="line-numbers"> <a href="#n6" name="n6">6</a></span>open Suave.Operators
<span class="line-numbers"> <a href="#n7" name="n7">7</a></span>open Suave.DotLiquid
<span class="line-numbers"> <a href="#n8" name="n8">8</a></span>open Suave.Redirection
<span class="line-numbers"> <a href="#n9" name="n9">9</a></span>open OtpSharp
<span class="line-numbers"><strong><a href="#n10" name="n10">10</a></strong></span>open Base32
<span class="line-numbers"><a href="#n11" name="n11">11</a></span>
<span class="line-numbers"><a href="#n12" name="n12">12</a></span>open Login
<span class="line-numbers"><a href="#n13" name="n13">13</a></span>open User
<span class="line-numbers"><a href="#n14" name="n14">14</a></span>
<span class="line-numbers"><a href="#n15" name="n15">15</a></span>let enableTwoFactorAuthPath = &quot;/enable_two_factor&quot;
<span class="line-numbers"><a href="#n16" name="n16">16</a></span>
<span class="line-numbers"><a href="#n17" name="n17">17</a></span>type EnableTwoFactorViewModel = {
<span class="line-numbers"><a href="#n18" name="n18">18</a></span>  Key : string
<span class="line-numbers"><a href="#n19" name="n19">19</a></span>  Url : string
<span class="line-numbers"><strong><a href="#n20" name="n20">20</a></strong></span>  Err : string
<span class="line-numbers"><a href="#n21" name="n21">21</a></span>}
<span class="line-numbers"><a href="#n22" name="n22">22</a></span>with static member From username err =
<span class="line-numbers"><a href="#n23" name="n23">23</a></span>      let secretKey = KeyGeneration.GenerateRandomKey(20)
<span class="line-numbers"><a href="#n24" name="n24">24</a></span>      let appName = &quot;SuaveRocks&quot;
<span class="line-numbers"><a href="#n25" name="n25">25</a></span>      let label = sprintf &quot;%s (%s.com/%s)&quot; appName appName username
<span class="line-numbers"><a href="#n26" name="n26">26</a></span>      let keyUrl = KeyUrl.GetTotpUrl(secretKey, label)
<span class="line-numbers"><a href="#n27" name="n27">27</a></span>      { Url = sprintf &quot;https://qrcode.kaywa.com/img.php?s=4&amp;d=%s&amp;issuer=%s&quot; keyUrl appName 
<span class="line-numbers"><a href="#n28" name="n28">28</a></span>        Key = Base32Encoder.Encode(secretKey)
<span class="line-numbers"><a href="#n29" name="n29">29</a></span>        Err = err}
<span class="line-numbers"><strong><a href="#n30" name="n30">30</a></strong></span>
<span class="line-numbers"><a href="#n31" name="n31">31</a></span>let renderEnableTwoFactorAuthView notFoundPath username ctx = async {
<span class="line-numbers"><a href="#n32" name="n32">32</a></span>  match getUser username with
<span class="line-numbers"><a href="#n33" name="n33">33</a></span>  | Some user -&gt; 
<span class="line-numbers"><a href="#n34" name="n34">34</a></span>    let err =
<span class="line-numbers"><a href="#n35" name="n35">35</a></span>      match ctx.request.[&quot;err&quot;] with
<span class="line-numbers"><a href="#n36" name="n36">36</a></span>      | Some err -&gt; err 
<span class="line-numbers"><a href="#n37" name="n37">37</a></span>      | _ -&gt; &quot;&quot;
<span class="line-numbers"><a href="#n38" name="n38">38</a></span>    let vm = EnableTwoFactorViewModel.From username err
<span class="line-numbers"><a href="#n39" name="n39">39</a></span>    return! page &quot;enable_two_factor.liquid&quot; vm ctx
<span class="line-numbers"><strong><a href="#n40" name="n40">40</a></strong></span>  | _ -&gt; return! redirect notFoundPath ctx
<span class="line-numbers"><a href="#n41" name="n41">41</a></span>}
<span class="line-numbers"><a href="#n42" name="n42">42</a></span>
<span class="line-numbers"><a href="#n43" name="n43">43</a></span>let googleAuthenticatorWebPart notFoundPath = 
<span class="line-numbers"><a href="#n44" name="n44">44</a></span>  choose [
<span class="line-numbers"><a href="#n45" name="n45">45</a></span>    path enableTwoFactorAuthPath &gt;=&gt; choose [
<span class="line-numbers"><a href="#n46" name="n46">46</a></span>      GET &gt;=&gt; secured (renderEnableTwoFactorAuthView notFoundPath)
<span class="line-numbers"><a href="#n47" name="n47">47</a></span>    ]]
</pre></div>
</div>
</div>

<p>As we did in the login page, we are using the <code>err</code> query string in the request to pass the verification code mismatch errors. </p>

<p>We are leveraging the <code>OtpSharp</code> library to generate the URL that is in turn represented as a QR Code. </p>

<blockquote>
  <p>If you would like to how Google Authenticator interprets the generated key and the issuer name from the URL embedded in the QR Code, check out the <a href="https://github.com/google/google-authenticator/wiki/Key-Uri-Format">UriFormat</a> documentation. </p>
</blockquote>

<p>The last step in rendering this page is adding the <code>googleAuthenticatorWebPart</code> in the <code>Web</code> module where we are putting all the WebParts together</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"> <a href="#n1" name="n1">1</a></span>// Suave.TwoFactorAuth/Web.fs
<span class="line-numbers"> <a href="#n2" name="n2">2</a></span>// ...
<span class="line-numbers"> <a href="#n3" name="n3">3</a></span>open GoogleAuthenticator
<span class="line-numbers"> <a href="#n4" name="n4">4</a></span>
<span class="line-numbers"> <a href="#n5" name="n5">5</a></span>let app =   
<span class="line-numbers"> <a href="#n6" name="n6">6</a></span>  choose [
<span class="line-numbers"> <a href="#n7" name="n7">7</a></span>    // ...
<span class="line-numbers"> <a href="#n8" name="n8">8</a></span>    googleAuthenticatorWebPart notFoundPath       
<span class="line-numbers"> <a href="#n9" name="n9">9</a></span>  ]
</pre></div>
</div>
</div>

<p>While enabling Two-factor authentication, the user has to scan the QR-Code from his <em>Google Authenticator</em> app and he will be getting a one-time verification code like this upon adding</p>

<p><img class="center border" src="/images/suave_two_factor/Google_Authenticator.png" width="200" height="400"></p>

<p>Then he will be entering this in the <code>enable_two_factor</code> page and click <code>Enable</code>.</p>

<p>Let’s handle this <em>POST</em> request. </p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"> <a href="#n1" name="n1">1</a></span>// Suave.TwoFactorAuth/GoogleAuthenticator.fs
<span class="line-numbers"> <a href="#n2" name="n2">2</a></span>// ...
<span class="line-numbers"> <a href="#n3" name="n3">3</a></span>let verifyOtp secretKey code =
<span class="line-numbers"> <a href="#n4" name="n4">4</a></span>  let otp = new Totp(Base32Encoder.Decode secretKey)
<span class="line-numbers"> <a href="#n5" name="n5">5</a></span>  otp.VerifyTotp(code, ref 0L, new VerificationWindow(2, 2))
<span class="line-numbers"> <a href="#n6" name="n6">6</a></span>
<span class="line-numbers"> <a href="#n7" name="n7">7</a></span>let enableTwoFactorAuth redirectPath notFoundPath username ctx = async {
<span class="line-numbers"> <a href="#n8" name="n8">8</a></span>  match ctx.request.[&quot;SecretKey&quot;], ctx.request.[&quot;Code&quot;] with
<span class="line-numbers"> <a href="#n9" name="n9">9</a></span>  | Some secretKey, Some code -&gt;     
<span class="line-numbers"><strong><a href="#n10" name="n10">10</a></strong></span>    match verifyOtp secretKey code with
<span class="line-numbers"><a href="#n11" name="n11">11</a></span>    | true -&gt;
<span class="line-numbers"><a href="#n12" name="n12">12</a></span>      enableTwoFactorAuth username secretKey
<span class="line-numbers"><a href="#n13" name="n13">13</a></span>      return! redirect redirectPath ctx
<span class="line-numbers"><a href="#n14" name="n14">14</a></span>    | _ -&gt; 
<span class="line-numbers"><a href="#n15" name="n15">15</a></span>      let redirectTo =
<span class="line-numbers"><a href="#n16" name="n16">16</a></span>        sprintf &quot;%s?err=code validation failed&quot; enableTwoFactorAuthPath 
<span class="line-numbers"><a href="#n17" name="n17">17</a></span>      return! redirect redirectTo ctx
<span class="line-numbers"><a href="#n18" name="n18">18</a></span>  | _ -&gt; return! redirect notFoundPath ctx
<span class="line-numbers"><a href="#n19" name="n19">19</a></span>}
<span class="line-numbers"><strong><a href="#n20" name="n20">20</a></strong></span>
<span class="line-numbers"><a href="#n21" name="n21">21</a></span>let googleAuthenticatorWebPart redirectPath notFoundPath = 
<span class="line-numbers"><a href="#n22" name="n22">22</a></span>  choose [
<span class="line-numbers"><a href="#n23" name="n23">23</a></span>    path enableTwoFactorAuthPath &gt;=&gt; choose [
<span class="line-numbers"><a href="#n24" name="n24">24</a></span>      // ...
<span class="line-numbers"><a href="#n25" name="n25">25</a></span>      POST &gt;=&gt; secured (enableTwoFactorAuth redirectPath notFoundPath)
<span class="line-numbers"><a href="#n26" name="n26">26</a></span>    ]]
</pre></div>
</div>
</div>

<p>Thanks to the <em>OtpSharp</em> library for making our job simpler here. We just need to get the <code>SecretKey</code>, and the <code>Code</code> from the POST request and get it verified using <em>OtpSharp’s</em> <a href="https://bitbucket.org/devinmartin/otp-sharp/wiki/TOTP">VerifyTotp</a> function. </p>

<p>If the verification is successful, we will be enabling the Two-factor authentication for the user in our in-memory backend using the <code>enableTwoFactorAuth</code> function and then redirect to the redirect path which in this case the <em>Profile</em> page.</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"><a href="#n1" name="n1">1</a></span>// Suave.TwoFactorAuth/Web.fs
<span class="line-numbers"><a href="#n2" name="n2">2</a></span>// ...
<span class="line-numbers"><a href="#n3" name="n3">3</a></span>
<span class="line-numbers"><a href="#n4" name="n4">4</a></span>let app =   
<span class="line-numbers"><a href="#n5" name="n5">5</a></span>  choose [
<span class="line-numbers"><a href="#n6" name="n6">6</a></span>    // ...
<span class="line-numbers"><a href="#n7" name="n7">7</a></span>    googleAuthenticatorWebPart profilePath notFoundPath       
<span class="line-numbers"><a href="#n8" name="n8">8</a></span>  ]
</pre></div>
</div>
</div>

<h2 id="login-with-two-factor-authentication">Login With Two-factor Authentication</h2>

<p>The last step is to prompt for the verification code whenever the Two-factor Authentication enabled user tries to log in and verify the one-time verification code before granting the access. </p>

<p>Let’s start by defining the liquid view template <code>auth_code.liquid</code> for getting the one-time verification code.</p>

<p><img class="center border" src="/images/suave_two_factor/auth_code_view.png" width="450" height="350"></p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"><a href="#n1" name="n1">1</a></span>// Suave.TwoFactorAuth/GoogleAuthenticator.fs
<span class="line-numbers"><a href="#n2" name="n2">2</a></span>// ...
<span class="line-numbers"><a href="#n3" name="n3">3</a></span>let authCodePath = &quot;/authcode&quot;
<span class="line-numbers"><a href="#n4" name="n4">4</a></span>
<span class="line-numbers"><a href="#n5" name="n5">5</a></span>let googleAuthenticatorWebPart redirectPath notFoundPath = 
<span class="line-numbers"><a href="#n6" name="n6">6</a></span>  choose [
<span class="line-numbers"><a href="#n7" name="n7">7</a></span>    // ...
<span class="line-numbers"><a href="#n8" name="n8">8</a></span>    path authCodePath &gt;=&gt; page &quot;auth_code.liquid&quot; &quot;&quot;]
</pre></div>
</div>
</div>

<p>After username and password verification, the user has to be redirected the <em>auth_code</em> page</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"> <a href="#n1" name="n1">1</a></span>// Suave.TwoFactorAuth/Login.fs
<span class="line-numbers"> <a href="#n2" name="n2">2</a></span>// ...
<span class="line-numbers"> <a href="#n3" name="n3">3</a></span>let authCodeSessionKey = &quot;loginUser&quot;
<span class="line-numbers"> <a href="#n4" name="n4">4</a></span>
<span class="line-numbers"> <a href="#n5" name="n5">5</a></span>let onLogin redirectPath authCodePath (request : HttpRequest) = 
<span class="line-numbers"> <a href="#n6" name="n6">6</a></span>  match request.[&quot;Username&quot;], request.[&quot;Password&quot;] with
<span class="line-numbers"> <a href="#n7" name="n7">7</a></span>  | Some username, Some password -&gt; 
<span class="line-numbers"> <a href="#n8" name="n8">8</a></span>    match getUser username with
<span class="line-numbers"> <a href="#n9" name="n9">9</a></span>    | Some user -&gt; 
<span class="line-numbers"><strong><a href="#n10" name="n10">10</a></strong></span>      match user.Password = password, user.TwoFactorAuthentication with
<span class="line-numbers"><a href="#n11" name="n11">11</a></span>      | true, Disabled -&gt; loginSucess never redirectPath username
<span class="line-numbers"><a href="#n12" name="n12">12</a></span>      | true, Enabled _ -&gt; 
<span class="line-numbers"><a href="#n13" name="n13">13</a></span>          sessionSet never authCodeSessionKey username  
<span class="line-numbers"><a href="#n14" name="n14">14</a></span>            &gt;=&gt; FOUND authCodePath
<span class="line-numbers"><a href="#n15" name="n15">15</a></span>      // ...
<span class="line-numbers"><a href="#n16" name="n16">16</a></span>
<span class="line-numbers"><a href="#n17" name="n17">17</a></span>// ...
<span class="line-numbers"><a href="#n18" name="n18">18</a></span>
<span class="line-numbers"><a href="#n19" name="n19">19</a></span>let loginWebPart redirectPath authCodePath =
<span class="line-numbers"><strong><a href="#n20" name="n20">20</a></strong></span>  path loginPath &gt;=&gt; choose [
<span class="line-numbers"><a href="#n21" name="n21">21</a></span>      // ...
<span class="line-numbers"><a href="#n22" name="n22">22</a></span>      POST &gt;=&gt; request (onLogin redirectPath authCodePath)]
</pre></div>
</div>
</div>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"><a href="#n1" name="n1">1</a></span>// Suave.TwoFactorAuth/Web.fs
<span class="line-numbers"><a href="#n2" name="n2">2</a></span>// ...
<span class="line-numbers"><a href="#n3" name="n3">3</a></span>let app =   
<span class="line-numbers"><a href="#n4" name="n4">4</a></span>  choose [
<span class="line-numbers"><a href="#n5" name="n5">5</a></span>    loginWebPart profilePath authCodePath
<span class="line-numbers"><a href="#n6" name="n6">6</a></span>    // ...
<span class="line-numbers"><a href="#n7" name="n7">7</a></span>  ]
</pre></div>
</div>
</div>

<p>We are using a separate session key <code>authCodeSessionKey</code> to hold the username of the user. </p>

<p>The final step is verifying the one-time verification code (from the Google Authenticator app) entered by the user. </p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"> <a href="#n1" name="n1">1</a></span>// Suave.TwoFactorAuth/GoogleAuthenticator.fs
<span class="line-numbers"> <a href="#n2" name="n2">2</a></span>// ...
<span class="line-numbers"> <a href="#n3" name="n3">3</a></span>open Combinators
<span class="line-numbers"> <a href="#n4" name="n4">4</a></span>// ...
<span class="line-numbers"> <a href="#n5" name="n5">5</a></span>let onAuthCodeVerification redirectPath (request : HttpRequest) username = 
<span class="line-numbers"> <a href="#n6" name="n6">6</a></span>  match request.[&quot;Code&quot;], getUser username with
<span class="line-numbers"> <a href="#n7" name="n7">7</a></span>  | Some code, Some user -&gt;
<span class="line-numbers"> <a href="#n8" name="n8">8</a></span>    match user.TwoFactorAuthentication with
<span class="line-numbers"> <a href="#n9" name="n9">9</a></span>    | Enabled secretKey -&gt; 
<span class="line-numbers"><strong><a href="#n10" name="n10">10</a></strong></span>      match verifyOtp secretKey code with
<span class="line-numbers"><a href="#n11" name="n11">11</a></span>      | true -&gt; loginSucess never redirectPath user.Username
<span class="line-numbers"><a href="#n12" name="n12">12</a></span>      | _ -&gt; redirectToLogin (Some &quot;invalid otp&quot;) 
<span class="line-numbers"><a href="#n13" name="n13">13</a></span>    | _ -&gt; redirectToLogin (Some &quot;invalid request&quot;) 
<span class="line-numbers"><a href="#n14" name="n14">14</a></span>  | _ -&gt; redirectToLogin (Some &quot;invalid request&quot;)
<span class="line-numbers"><a href="#n15" name="n15">15</a></span>
<span class="line-numbers"><a href="#n16" name="n16">16</a></span>let onVerifyAuthCode redirectPath httpRequest =
<span class="line-numbers"><a href="#n17" name="n17">17</a></span>  let onFail = redirectToLogin (Some &quot;invalid request&quot;)
<span class="line-numbers"><a href="#n18" name="n18">18</a></span>  let onAuthCodeVerification = 
<span class="line-numbers"><a href="#n19" name="n19">19</a></span>    onAuthCodeVerification redirectPath httpRequest
<span class="line-numbers"><strong><a href="#n20" name="n20">20</a></strong></span>  sessionGet onFail authCodeSessionKey onAuthCodeVerification
<span class="line-numbers"><a href="#n21" name="n21">21</a></span>
<span class="line-numbers"><a href="#n22" name="n22">22</a></span>let googleAuthenticatorWebPart redirectPath notFoundPath = 
<span class="line-numbers"><a href="#n23" name="n23">23</a></span>  choose [
<span class="line-numbers"><a href="#n24" name="n24">24</a></span>    // ...
<span class="line-numbers"><a href="#n25" name="n25">25</a></span>    path &quot;/verify_auth_code&quot; &gt;=&gt; request (onVerifyAuthCode redirectPath)]
</pre></div>
</div>
</div>

<p>That’s it! We have successfully implemented Two-factor authentication. </p>

<p>The complete source code is available in <a href="https://github.com/tamizhvendan/blog-samples/tree/master/SuaveTwoFactorAuth">my GitHub repository</a></p>

<h3 id="related-posts">Related Post(s)</h3>

<ul>
  <li><a href="/blog/2015/07/15/securing-apis-in-suave-using-json-web-token/">Securing APIs in Suave using JSON Web Token</a></li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Scale Up Azure Functions in F# using Suave]]></title>
    <link href="http://blog.tamizhvendan.in/blog/2016/09/19/scale-up-azure-functions-in-f-number-using-suave/"/>
    <updated>2016-09-19T15:55:45+05:30</updated>
    <id>http://blog.tamizhvendan.in/blog/2016/09/19/scale-up-azure-functions-in-f-number-using-suave</id>
    <content type="html"><![CDATA[<p>Recently Microsoft Azure has made <a href="https://blogs.msdn.microsoft.com/appserviceteam/2016/09/01/azure-functions-0-5-release-august-portal-update/">F# as a first-class citizen</a> to write <a href="https://azure.microsoft.com/en-in/services/functions/">Azure Functions</a>. As F# is a functional-first programming language, I feel Azure Functions and F# would be a match made in heaven.</p>

<p>In this blog post, you are going to experience a scaled up version of Azure Functions in F# using <a href="https://suave.io">Suave</a></p>

<h2 id="whats-in-the-function-signatures">What’s in the Function Signatures?</h2>

<p>In a functional programming language, we define small functions that do one thing well and then we compose them together to represent the solution. To <a href="https://fsharpforfunandprofit.com/posts/function-composition/">compose functions</a>, we need to be thoughtful while designing the signature of a function.</p>

<p>Let’s see the signature of an <a href="https://azure.microsoft.com/en-us/documentation/articles/functions-reference-fsharp/">Azure Function in F#</a></p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"><a href="#n1" name="n1">1</a></span>// HttpRequestMessage -&gt; HttpResponseMessage
<span class="line-numbers"><a href="#n2" name="n2">2</a></span>let Run(req: HttpRequestMessage) =
<span class="line-numbers"><a href="#n3" name="n3">3</a></span>  new HttpResponseMessage(HttpStatusCode.OK)
</pre></div>
</div>
</div>

<p>The <code>Run</code> function takes a <code>HttpRequestMessage</code> and returns the <code>HttpResponseMessage</code>. This signature is simple, but it has a limitation. The limitation has been showcased in the <a href="https://github.com/Azure/azure-webjobs-sdk-templates/tree/dev/Templates">templates</a> directory of Azure Webjobs SDK</p>

<p><img class="center border" src="/images/AzureFunctionsSuave/Azure_Functions_CRUD.png" width="250" height="250"></p>

<p>My each <code>C</code>, <code>R</code>, <code>U</code>, <code>D</code> are in different functions. Well, there is nothing wrong here. These templates are suitable for getting started in Azure Functions. But what will you do if you have a requirement to expose <code>CRUD</code> of a resource as an Azure Functions?</p>

<p>One option is to define each part of the <code>CRUD</code> as separate Azure Functions (as defined by the templates). If you choose to go by this, you will have four different endpoints and I am sure your client code will have a hard time to consume these endpoints. In addition to this, you will also need to manage four things to satisfy your one requirement.</p>

<p>The other option is putting the <code>CRUD</code> inside a single function.</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"> <a href="#n1" name="n1">1</a></span>let Run (req:HttpRequestMessage) =
<span class="line-numbers"> <a href="#n2" name="n2">2</a></span>    if req.Method = HttpMethod.Get then
<span class="line-numbers"> <a href="#n3" name="n3">3</a></span>        // ...
<span class="line-numbers"> <a href="#n4" name="n4">4</a></span>    else if req.Method = HttpMethod.Post then
<span class="line-numbers"> <a href="#n5" name="n5">5</a></span>        // ...
<span class="line-numbers"> <a href="#n6" name="n6">6</a></span>    else if req.Method = HttpMethod.Put then
<span class="line-numbers"> <a href="#n7" name="n7">7</a></span>        // ...
<span class="line-numbers"> <a href="#n8" name="n8">8</a></span>    else if req.Method = HttpMethod.Delete then
<span class="line-numbers"> <a href="#n9" name="n9">9</a></span>        // ...
<span class="line-numbers"><strong><a href="#n10" name="n10">10</a></strong></span>    else
<span class="line-numbers"><a href="#n11" name="n11">11</a></span>        // ...
</pre></div>
</div>
</div>

<p>Though this approach solves the problem, it comes with another set of <a href="http://stackoverflow.com/questions/126409/ways-to-eliminate-switch-in-code">challenges</a>. In Object Oriented  Programming, we typically use <a href="http://www.refactoring.com/catalog/replaceConditionalWithPolymorphism.html">Polymorphism</a> to replace the conditional logic.</p>

<p><img class="center" src="http://scontent.cdninstagram.com/t51.2885-15/s480x480/e35/13391359_1083221395099569_1878773023_n.jpg?ig_cache_key=MTI3NTQ5MjQ4NzE4Mjk3MTIxOQ%3D%3D.2"></p>

<h2 id="revisiting-function-signature">Revisiting Function Signature</h2>

<p>A request <code>handler</code> looks for some condition to be meet in the incoming HTTP request, and if the predicate succeeds, it modifies the HTTP response.</p>

<p>The signature of the <code>Run</code> function, <code>HttpRequestMessage -&gt; HttpResponseMessage</code> is not completely reflecting the above specification.</p>

<p>Let’s have a look at the limitations of this signature</p>

<ul>
  <li>
    <p>The <code>Run</code> function doesn’t return the <code>HttpRequestMessage</code>. So if we have multiple <code>handler</code>s we are constrained to use either <code>if else if</code> or Polymorphism.</p>
  </li>
  <li>
    <p>It doesn’t represent a handler that doesn’t handle the HTTP request. If the HTTP request is <code>GET</code>, the <code>handler</code> for HTTP <code>POST</code> will not modify the <code>HttpResponseMessage</code></p>
  </li>
</ul>

<p>The better signature would have the following to describe a handler in a better way</p>

<ul>
  <li>
    <p>The handler has to be pure function that takes both <code>Request</code> and <code>Response</code> as it’s parameters</p>
  </li>
  <li>
    <p>If the handler is not handling the HTTP request, it has to return the unmodified <code>Request</code> and <code>Response</code> along with an indicator saying that it didn’t handle the request.</p>
  </li>
</ul>

<p>It’s where the <a href="https://suave.io">Suave</a> library shines. Suave defines a type called <code>WebPart</code> with the signature to model the <code>handler</code> with the above-said expectations.</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"><a href="#n1" name="n1">1</a></span>type HttpContext = {
<span class="line-numbers"><a href="#n2" name="n2">2</a></span>  request    : HttpRequest
<span class="line-numbers"><a href="#n3" name="n3">3</a></span>  response   : HttpResult
<span class="line-numbers"><a href="#n4" name="n4">4</a></span>  // ...
<span class="line-numbers"><a href="#n5" name="n5">5</a></span>}
<span class="line-numbers"><a href="#n6" name="n6">6</a></span>
<span class="line-numbers"><a href="#n7" name="n7">7</a></span>type WebPart = HttpContext -&gt; Async&lt;HttpContext option&gt;
</pre></div>
</div>
</div>

<blockquote>
  <p>The <code>Async</code> represents that the <code>WebPart</code> function is a non-blocking asynchronous function and <code>option</code> type models the <code>WebPart</code> which doesn’t handle the HTTP request</p>
</blockquote>

<p>The real power of Suave is its set of combinators to manipulate route flow and task composition. You can define an API in Suave that only handles HTTP <code>POST</code> requests and returns <code>Hello</code> as text without typing too much.</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"><a href="#n1" name="n1">1</a></span>// HttpContext -&gt; Async&lt;HttpContext option&gt;
<span class="line-numbers"><a href="#n2" name="n2">2</a></span>let app = POST &gt;=&gt; OK &quot;HelloSystem.Net.Http
</pre></div>
</div>
</div>

<blockquote>
  <p>To learn more about the Suave combinators refer my blog post on <a href="/blog/2015/06/11/building-rest-api-in-fsharp-using-suave/">Building REST API in suave</a></p>
</blockquote>

<p>If you notice the binding <code>app</code> itself is a <code>WebPart</code> (which in turn a function) with the signature <code>HttpContext -&gt; Async&lt;HttpContext option&gt;</code>. So, you can call this function in your application code and project the output of the function to any output medium that you wish.</p>

<h2 id="the-difference">The Difference</h2>

<p>The Azure Functions do an incredible job in helping you to define <em>a part of your system</em> as <em>a function</em>. Suave takes it to the next level by helping you to define <em>your system</em> as <em>function</em>.</p>

<p>In nutshell, Suave complements Azure Functions and helps you to define your system as a <em>Serverless Function</em></p>

<h2 id="creating-a-suave-adapter">Creating a Suave Adapter</h2>

<p>So, to scale up Azure Functions using Suave, all we need is an adapter.</p>

<p><img class="center" src="http://images.freeimages.com/images/previews/c0d/adapter-1420487.jpg"></p>

<p>The adapter does the following</p>

<ul>
  <li>
    <p>Transforms <code>HttpRequestMessage</code> from <code>System.Net.Http</code> to <code>HttpRequest</code> of <code>Suave.Http</code></p>
  </li>
  <li>
    <p>Then create an empty Suave’s <code>HttpContext</code> with the above <code>HttpRequest</code> and call the <code>WebPart</code> (that represents your system).</p>
  </li>
  <li>
    <p>The final step is converting the <code>HttpResult</code> of <code>Suave.Http</code> to <code>HttpResponseMessage</code> of <code>System.Net.Http</code>.</p>
  </li>
</ul>

<p>Let’s start from <code>HttpRequestMessage</code></p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"> <a href="#n1" name="n1">1</a></span>// SuaveAdapter.fsx
<span class="line-numbers"> <a href="#n2" name="n2">2</a></span>let SuaveHttpMethod (httpMethod : System.Net.Http.HttpMethod) =
<span class="line-numbers"> <a href="#n3" name="n3">3</a></span>  match httpMethod.Method with
<span class="line-numbers"> <a href="#n4" name="n4">4</a></span>  | &quot;GET&quot; -&gt; HttpMethod.GET
<span class="line-numbers"> <a href="#n5" name="n5">5</a></span>  | &quot;POST&quot; -&gt; HttpMethod.POST
<span class="line-numbers"> <a href="#n6" name="n6">6</a></span>  | &quot;PUT&quot; -&gt; HttpMethod.PUT
<span class="line-numbers"> <a href="#n7" name="n7">7</a></span>  | &quot;DELETE&quot; -&gt; HttpMethod.DELETE
<span class="line-numbers"> <a href="#n8" name="n8">8</a></span>  | x -&gt; HttpMethod.OTHER x
<span class="line-numbers"> <a href="#n9" name="n9">9</a></span>
<span class="line-numbers"><strong><a href="#n10" name="n10">10</a></strong></span>let SuaveHeaders (headers : HttpRequestHeaders) =
<span class="line-numbers"><a href="#n11" name="n11">11</a></span>  headers
<span class="line-numbers"><a href="#n12" name="n12">12</a></span>  |&gt; Seq.map (fun h -&gt; (h.Key, h.Value |&gt; Seq.head))
<span class="line-numbers"><a href="#n13" name="n13">13</a></span>  |&gt; Seq.toList
<span class="line-numbers"><a href="#n14" name="n14">14</a></span>
<span class="line-numbers"><a href="#n15" name="n15">15</a></span>let SuaveRawForm (content : System.Net.Http.HttpContent) = async {
<span class="line-numbers"><a href="#n16" name="n16">16</a></span>  let! content = content.ReadAsByteArrayAsync() |&gt; Async.AwaitTask
<span class="line-numbers"><a href="#n17" name="n17">17</a></span>  return content
<span class="line-numbers"><a href="#n18" name="n18">18</a></span>}
<span class="line-numbers"><a href="#n19" name="n19">19</a></span>
<span class="line-numbers"><strong><a href="#n20" name="n20">20</a></strong></span>let SuaveRawQuery (requestUri : System.Uri) =
<span class="line-numbers"><a href="#n21" name="n21">21</a></span>  if requestUri.Query.Length &gt; 1 then
<span class="line-numbers"><a href="#n22" name="n22">22</a></span>    requestUri.Query.Substring(1)
<span class="line-numbers"><a href="#n23" name="n23">23</a></span>  else
<span class="line-numbers"><a href="#n24" name="n24">24</a></span>      &quot;&quot;
<span class="line-numbers"><a href="#n25" name="n25">25</a></span>
<span class="line-numbers"><a href="#n26" name="n26">26</a></span>let NetHeaderValue (headers : HttpRequestHeaders) key =
<span class="line-numbers"><a href="#n27" name="n27">27</a></span>    headers
<span class="line-numbers"><a href="#n28" name="n28">28</a></span>    |&gt; Seq.tryFind (fun h -&gt; h.Key = key)
<span class="line-numbers"><a href="#n29" name="n29">29</a></span>    |&gt; Option.map (fun h -&gt; h.Value |&gt; Seq.head)
<span class="line-numbers"><strong><a href="#n30" name="n30">30</a></strong></span>
<span class="line-numbers"><a href="#n31" name="n31">31</a></span>let SuaveRequest (req : HttpRequestMessage) = async {
<span class="line-numbers"><a href="#n32" name="n32">32</a></span>  let! content = SuaveRawForm req.Content
<span class="line-numbers"><a href="#n33" name="n33">33</a></span>  let host = defaultArg (NetHeaderValue req.Headers &quot;Host&quot;) &quot;&quot;
<span class="line-numbers"><a href="#n34" name="n34">34</a></span>  return {HttpRequest.empty with
<span class="line-numbers"><a href="#n35" name="n35">35</a></span>            url = req.RequestUri            
<span class="line-numbers"><a href="#n36" name="n36">36</a></span>            ``method`` = SuaveHttpMethod req.Method
<span class="line-numbers"><a href="#n37" name="n37">37</a></span>            headers = SuaveHeaders req.Headers
<span class="line-numbers"><a href="#n38" name="n38">38</a></span>            rawForm = content
<span class="line-numbers"><a href="#n39" name="n39">39</a></span>            rawQuery = SuaveRawQuery req.RequestUri
<span class="line-numbers"><strong><a href="#n40" name="n40">40</a></strong></span>            host = host}
<span class="line-numbers"><a href="#n41" name="n41">41</a></span>}
</pre></div>
</div>
</div>

<blockquote>
  <p>As a convention, I’ve used <code>Net</code> and <code>Suave</code> prefixes in the function name to represent the returning type of <code>System.Net.Http</code> and <code>Suave.Http</code> respectively.  </p>
</blockquote>

<p>I hope that these functions are self-explanatory, so let’s move on the next step.</p>

<blockquote>
  <p>To keep it simple, I’ve ignored other HTTP Methods like PATCH, HEAD, etc.</p>
</blockquote>

<p>The next step is creating Suave <code>HttpContext</code></p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"><a href="#n1" name="n1">1</a></span>let SuaveContext httpRequest = async {
<span class="line-numbers"><a href="#n2" name="n2">2</a></span>  let! suaveReq = SuaveRequest httpRequest
<span class="line-numbers"><a href="#n3" name="n3">3</a></span>  return { HttpContext.empty with request = suaveReq}
<span class="line-numbers"><a href="#n4" name="n4">4</a></span>}   
</pre></div>
</div>
</div>

<p>Then we need to convert <code>HttpResult</code> to <code>HttpResponseMessage</code></p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"> <a href="#n1" name="n1">1</a></span>let NetStatusCode = function
<span class="line-numbers"> <a href="#n2" name="n2">2</a></span>| HttpCode.HTTP_200 -&gt; HttpStatusCode.OK
<span class="line-numbers"> <a href="#n3" name="n3">3</a></span>| HttpCode.HTTP_201 -&gt; HttpStatusCode.Created
<span class="line-numbers"> <a href="#n4" name="n4">4</a></span>| HttpCode.HTTP_400 -&gt; HttpStatusCode.BadRequest
<span class="line-numbers"> <a href="#n5" name="n5">5</a></span>| HttpCode.HTTP_404 -&gt; HttpStatusCode.NotFound
<span class="line-numbers"> <a href="#n6" name="n6">6</a></span>| HttpCode.HTTP_202 -&gt; HttpStatusCode.Accepted
<span class="line-numbers"> <a href="#n7" name="n7">7</a></span>| _ -&gt; HttpStatusCode.Ambiguous
<span class="line-numbers"> <a href="#n8" name="n8">8</a></span>
<span class="line-numbers"> <a href="#n9" name="n9">9</a></span>let NetHttpResponseMessage httpResult =
<span class="line-numbers"><strong><a href="#n10" name="n10">10</a></strong></span>  let content = function
<span class="line-numbers"><a href="#n11" name="n11">11</a></span>  | Bytes c -&gt; c
<span class="line-numbers"><a href="#n12" name="n12">12</a></span>  | _ -&gt; Array.empty
<span class="line-numbers"><a href="#n13" name="n13">13</a></span>  let res = new HttpResponseMessage()
<span class="line-numbers"><a href="#n14" name="n14">14</a></span>  let content = new ByteArrayContent(content httpResult.content)
<span class="line-numbers"><a href="#n15" name="n15">15</a></span>  httpResult.headers |&gt; List.iter content.Headers.Add  
<span class="line-numbers"><a href="#n16" name="n16">16</a></span>  res.Content &lt;- content
<span class="line-numbers"><a href="#n17" name="n17">17</a></span>  res.StatusCode &lt;- NetStatusCode httpResult.status
<span class="line-numbers"><a href="#n18" name="n18">18</a></span>  res
</pre></div>
</div>
</div>

<blockquote>
  <p>To keep it simple, I’ve ignored other HTTP StatusCodes</p>
</blockquote>

<p>The final step is putting these functions together and run the <code>WebPart</code> function with the translated <code>HttpContext</code>.</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"> <a href="#n1" name="n1">1</a></span>let SuaveRunAsync app suaveContext = async {
<span class="line-numbers"> <a href="#n2" name="n2">2</a></span>  let! res = app suaveContext
<span class="line-numbers"> <a href="#n3" name="n3">3</a></span>  match res with
<span class="line-numbers"> <a href="#n4" name="n4">4</a></span>  | Some ctx -&gt;
<span class="line-numbers"> <a href="#n5" name="n5">5</a></span>    return (NetHttpResponseMessage ctx.response, ctx)
<span class="line-numbers"> <a href="#n6" name="n6">6</a></span>  | _ -&gt;
<span class="line-numbers"> <a href="#n7" name="n7">7</a></span>    let res = new HttpResponseMessage()
<span class="line-numbers"> <a href="#n8" name="n8">8</a></span>    res.Content &lt;- new ByteArrayContent(Array.empty)
<span class="line-numbers"> <a href="#n9" name="n9">9</a></span>    res.StatusCode &lt;- HttpStatusCode.NotFound
<span class="line-numbers"><strong><a href="#n10" name="n10">10</a></strong></span>    return res,suaveContext
<span class="line-numbers"><a href="#n11" name="n11">11</a></span>}
<span class="line-numbers"><a href="#n12" name="n12">12</a></span>
<span class="line-numbers"><a href="#n13" name="n13">13</a></span>let RunWebPartAsync app httpRequest = async {
<span class="line-numbers"><a href="#n14" name="n14">14</a></span>  let! suaveContext = SuaveContext httpRequest
<span class="line-numbers"><a href="#n15" name="n15">15</a></span>  return! SuaveRunAsync app suaveContext
<span class="line-numbers"><a href="#n16" name="n16">16</a></span>}
</pre></div>
</div>
</div>

<h2 id="suave-adapter-in-action">Suave Adapter In Action</h2>

<p>Let’s see the Suave Adapter that we created in action.</p>

<p>As already there are two great blog posts by <a href="http://gregshackles.com/getting-started-with-azure-functions-and-f/">Greg Shackles</a> and <a href="https://mnie.github.io/2016-09-08-AzureFunctions/">Michał Niegrzybowski</a>, I am diving directly into Azure functions in F#.</p>

<p>Let me create a new Azure Function application in Azure with the name “TamAzureFun” and then define the first function <code>HelloSuave</code>.</p>

<p>The <code>function.json</code> of <code>HelloSuave</code> has to be updated with the <code>methods</code> property to support different HTTP request methods.</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"> <a href="#n1" name="n1">1</a></span>{
<span class="line-numbers"> <a href="#n2" name="n2">2</a></span>    <span class="key"><span class="delimiter">&quot;</span><span class="content">disabled</span><span class="delimiter">&quot;</span></span>: <span class="value">false</span>,
<span class="line-numbers"> <a href="#n3" name="n3">3</a></span>    <span class="key"><span class="delimiter">&quot;</span><span class="content">bindings</span><span class="delimiter">&quot;</span></span>: [{
<span class="line-numbers"> <a href="#n4" name="n4">4</a></span>      <span class="key"><span class="delimiter">&quot;</span><span class="content">type</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">httpTrigger</span><span class="delimiter">&quot;</span></span>,
<span class="line-numbers"> <a href="#n5" name="n5">5</a></span>      <span class="key"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">req</span><span class="delimiter">&quot;</span></span>,
<span class="line-numbers"> <a href="#n6" name="n6">6</a></span>      <span class="key"><span class="delimiter">&quot;</span><span class="content">methods</span><span class="delimiter">&quot;</span></span>: [<span class="string"><span class="delimiter">&quot;</span><span class="content">get</span><span class="delimiter">&quot;</span></span>,<span class="string"><span class="delimiter">&quot;</span><span class="content">put</span><span class="delimiter">&quot;</span></span>,<span class="string"><span class="delimiter">&quot;</span><span class="content">post</span><span class="delimiter">&quot;</span></span>,<span class="string"><span class="delimiter">&quot;</span><span class="content">delete</span><span class="delimiter">&quot;</span></span>],
<span class="line-numbers"> <a href="#n7" name="n7">7</a></span>      <span class="key"><span class="delimiter">&quot;</span><span class="content">authLevel</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">anonymous</span><span class="delimiter">&quot;</span></span>,
<span class="line-numbers"> <a href="#n8" name="n8">8</a></span>      <span class="key"><span class="delimiter">&quot;</span><span class="content">direction</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">in</span><span class="delimiter">&quot;</span></span>
<span class="line-numbers"> <a href="#n9" name="n9">9</a></span>    },{
<span class="line-numbers"><strong><a href="#n10" name="n10">10</a></strong></span>      <span class="key"><span class="delimiter">&quot;</span><span class="content">type</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">http</span><span class="delimiter">&quot;</span></span>,
<span class="line-numbers"><a href="#n11" name="n11">11</a></span>      <span class="key"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">res</span><span class="delimiter">&quot;</span></span>,
<span class="line-numbers"><a href="#n12" name="n12">12</a></span>      <span class="key"><span class="delimiter">&quot;</span><span class="content">direction</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">out</span><span class="delimiter">&quot;</span></span>
<span class="line-numbers"><a href="#n13" name="n13">13</a></span>    }]
<span class="line-numbers"><a href="#n14" name="n14">14</a></span>}
</pre></div>
</div>
</div>

<p>Then add the <code>Suave</code> dependency in <code>project.json</code></p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"> <a href="#n1" name="n1">1</a></span>{
<span class="line-numbers"> <a href="#n2" name="n2">2</a></span>  <span class="key"><span class="delimiter">&quot;</span><span class="content">frameworks</span><span class="delimiter">&quot;</span></span>: {
<span class="line-numbers"> <a href="#n3" name="n3">3</a></span>    <span class="key"><span class="delimiter">&quot;</span><span class="content">net46</span><span class="delimiter">&quot;</span></span>: {
<span class="line-numbers"> <a href="#n4" name="n4">4</a></span>      <span class="key"><span class="delimiter">&quot;</span><span class="content">dependencies</span><span class="delimiter">&quot;</span></span>: {
<span class="line-numbers"> <a href="#n5" name="n5">5</a></span>        <span class="key"><span class="delimiter">&quot;</span><span class="content">Suave</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">1.1.3</span><span class="delimiter">&quot;</span></span>
<span class="line-numbers"> <a href="#n6" name="n6">6</a></span>      }
<span class="line-numbers"> <a href="#n7" name="n7">7</a></span>    }
<span class="line-numbers"> <a href="#n8" name="n8">8</a></span>  }
<span class="line-numbers"> <a href="#n9" name="n9">9</a></span>}
</pre></div>
</div>
</div>

<p>Let’s start simply by defining small API (system) that handles different types of HTTP methods.</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"> <a href="#n1" name="n1">1</a></span>// app.fsx
<span class="line-numbers"> <a href="#n2" name="n2">2</a></span>open Suave
<span class="line-numbers"> <a href="#n3" name="n3">3</a></span>open Suave.Successful
<span class="line-numbers"> <a href="#n4" name="n4">4</a></span>open Suave.Operators
<span class="line-numbers"> <a href="#n5" name="n5">5</a></span>open Suave.Filters
<span class="line-numbers"> <a href="#n6" name="n6">6</a></span>
<span class="line-numbers"> <a href="#n7" name="n7">7</a></span>let app =
<span class="line-numbers"> <a href="#n8" name="n8">8</a></span>  choose [
<span class="line-numbers"> <a href="#n9" name="n9">9</a></span>      GET &gt;=&gt; OK &quot;GET test&quot;
<span class="line-numbers"><strong><a href="#n10" name="n10">10</a></strong></span>      POST &gt;=&gt; OK &quot;POST test&quot;
<span class="line-numbers"><a href="#n11" name="n11">11</a></span>      PUT &gt;=&gt; OK &quot;PUT test&quot;
<span class="line-numbers"><a href="#n12" name="n12">12</a></span>      DELETE &gt;=&gt; OK &quot;DELETE test&quot;]
</pre></div>
</div>
</div>

<p>The final step is referring the <code>SuaveAdapter.fsx</code> &amp; <code>app.fsx</code> files in the <code>run.fsx</code> and have fun!</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"> <a href="#n1" name="n1">1</a></span>// run.fsx
<span class="line-numbers"> <a href="#n2" name="n2">2</a></span>#load &quot;SuaveAdapter.fsx&quot;
<span class="line-numbers"> <a href="#n3" name="n3">3</a></span>#load &quot;app.fsx&quot;
<span class="line-numbers"> <a href="#n4" name="n4">4</a></span>open SuaveAdapter
<span class="line-numbers"> <a href="#n5" name="n5">5</a></span>open App
<span class="line-numbers"> <a href="#n6" name="n6">6</a></span>open System.Net.Http
<span class="line-numbers"> <a href="#n7" name="n7">7</a></span>open Suave
<span class="line-numbers"> <a href="#n8" name="n8">8</a></span>
<span class="line-numbers"> <a href="#n9" name="n9">9</a></span>let Run (req : HttpRequestMessage) =
<span class="line-numbers"><strong><a href="#n10" name="n10">10</a></strong></span>  let res, _ = RunWebPartAsync app req |&gt; Async.RunSynchronously
<span class="line-numbers"><a href="#n11" name="n11">11</a></span>  res
</pre></div>
</div>
</div>

<p>Let’s make some HTTP requests to test our implementation.</p>

<p><img class="center border" src="/images/AzureFunctionsSuave/HelloSuaveRequests.png" width="700" height="500"></p>

<p>Suave is rocking!</p>

<h2 id="creating-a-rest-api-in-azure-functions">Creating a REST API in Azure Functions</h2>

<p>We can extend the above example to expose a REST end point!</p>

<p>In Suave <em>a REST API</em> is a <strong>function</strong>.</p>

<p>Create a new Azure Function <code>HelloREST</code> and add <code>NewtonSoft.Json</code> &amp; <code>Suave</code> dependencies in <code>project.json</code></p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"> <a href="#n1" name="n1">1</a></span>{
<span class="line-numbers"> <a href="#n2" name="n2">2</a></span>  <span class="key"><span class="delimiter">&quot;</span><span class="content">frameworks</span><span class="delimiter">&quot;</span></span>: {
<span class="line-numbers"> <a href="#n3" name="n3">3</a></span>    <span class="key"><span class="delimiter">&quot;</span><span class="content">net46</span><span class="delimiter">&quot;</span></span>: {
<span class="line-numbers"> <a href="#n4" name="n4">4</a></span>      <span class="key"><span class="delimiter">&quot;</span><span class="content">dependencies</span><span class="delimiter">&quot;</span></span>: {
<span class="line-numbers"> <a href="#n5" name="n5">5</a></span>        <span class="key"><span class="delimiter">&quot;</span><span class="content">Suave</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">1.1.3</span><span class="delimiter">&quot;</span></span>,
<span class="line-numbers"> <a href="#n6" name="n6">6</a></span>        <span class="key"><span class="delimiter">&quot;</span><span class="content">NewtonSoft.Json</span><span class="delimiter">&quot;</span></span> : <span class="string"><span class="delimiter">&quot;</span><span class="content">9.0.1</span><span class="delimiter">&quot;</span></span>
<span class="line-numbers"> <a href="#n7" name="n7">7</a></span>      }
<span class="line-numbers"> <a href="#n8" name="n8">8</a></span>    }
<span class="line-numbers"> <a href="#n9" name="n9">9</a></span>  }
<span class="line-numbers"><strong><a href="#n10" name="n10">10</a></strong></span>}
</pre></div>
</div>
</div>

<p>To handle <em>JSON</em> requests and responses, let’s add some combinators</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"> <a href="#n1" name="n1">1</a></span>// Suave.Newtonsoft.Json.fsx
<span class="line-numbers"> <a href="#n2" name="n2">2</a></span>open Newtonsoft.Json
<span class="line-numbers"> <a href="#n3" name="n3">3</a></span>open Newtonsoft.Json.Serialization
<span class="line-numbers"> <a href="#n4" name="n4">4</a></span>open System.Text
<span class="line-numbers"> <a href="#n5" name="n5">5</a></span>open Suave.Json
<span class="line-numbers"> <a href="#n6" name="n6">6</a></span>open Suave.Http
<span class="line-numbers"> <a href="#n7" name="n7">7</a></span>open Suave
<span class="line-numbers"> <a href="#n8" name="n8">8</a></span>open Suave.Operators
<span class="line-numbers"> <a href="#n9" name="n9">9</a></span>
<span class="line-numbers"><strong><a href="#n10" name="n10">10</a></strong></span>let toJson&lt;'T&gt; (o: 'T) =
<span class="line-numbers"><a href="#n11" name="n11">11</a></span>  let settings = new JsonSerializerSettings()
<span class="line-numbers"><a href="#n12" name="n12">12</a></span>  settings.ContractResolver &lt;- new CamelCasePropertyNamesContractResolver()
<span class="line-numbers"><a href="#n13" name="n13">13</a></span>  JsonConvert.SerializeObject(o, settings)
<span class="line-numbers"><a href="#n14" name="n14">14</a></span>  |&gt; Encoding.UTF8.GetBytes
<span class="line-numbers"><a href="#n15" name="n15">15</a></span>
<span class="line-numbers"><a href="#n16" name="n16">16</a></span>let fromJson&lt;'T&gt; (bytes : byte []) =
<span class="line-numbers"><a href="#n17" name="n17">17</a></span>  let json = Encoding.UTF8.GetString bytes
<span class="line-numbers"><a href="#n18" name="n18">18</a></span>  JsonConvert.DeserializeObject(json, typeof&lt;'T&gt;) :?&gt; 'T
<span class="line-numbers"><a href="#n19" name="n19">19</a></span>
<span class="line-numbers"><strong><a href="#n20" name="n20">20</a></strong></span>let mapJsonWith&lt;'TIn, 'TOut&gt;
<span class="line-numbers"><a href="#n21" name="n21">21</a></span>  (deserializer:byte[] -&gt; 'TIn) (serializer:'TOut-&gt;byte[]) webpart f =
<span class="line-numbers"><a href="#n22" name="n22">22</a></span>  request(fun r -&gt;
<span class="line-numbers"><a href="#n23" name="n23">23</a></span>    f (deserializer r.rawForm)
<span class="line-numbers"><a href="#n24" name="n24">24</a></span>    |&gt; serializer
<span class="line-numbers"><a href="#n25" name="n25">25</a></span>    |&gt; webpart
<span class="line-numbers"><a href="#n26" name="n26">26</a></span>    &gt;=&gt; Writers.setMimeType &quot;application/json&quot;)
<span class="line-numbers"><a href="#n27" name="n27">27</a></span>
<span class="line-numbers"><a href="#n28" name="n28">28</a></span>let MapJson&lt;'T1,'T2&gt; webpart =
<span class="line-numbers"><a href="#n29" name="n29">29</a></span>  mapJsonWith&lt;'T1,'T2&gt; fromJson toJson webpart
<span class="line-numbers"><strong><a href="#n30" name="n30">30</a></strong></span>
<span class="line-numbers"><a href="#n31" name="n31">31</a></span>let ToJson webpart x  =
<span class="line-numbers"><a href="#n32" name="n32">32</a></span>  toJson x |&gt; webpart &gt;=&gt; Writers.setMimeType &quot;application/json&quot;   
</pre></div>
</div>
</div>

<p>Then define the REST api in <code>app.fsx</code></p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"> <a href="#n1" name="n1">1</a></span>#load &quot;Suave.Newtonsoft.Json.fsx&quot;
<span class="line-numbers"> <a href="#n2" name="n2">2</a></span>open Suave
<span class="line-numbers"> <a href="#n3" name="n3">3</a></span>open Suave.Successful
<span class="line-numbers"> <a href="#n4" name="n4">4</a></span>open Suave.Operators
<span class="line-numbers"> <a href="#n5" name="n5">5</a></span>open Suave.Filters
<span class="line-numbers"> <a href="#n6" name="n6">6</a></span>open System
<span class="line-numbers"> <a href="#n7" name="n7">7</a></span>open Suave.Newtonsoft.Json
<span class="line-numbers"> <a href="#n8" name="n8">8</a></span>
<span class="line-numbers"> <a href="#n9" name="n9">9</a></span>type Person = {
<span class="line-numbers"><strong><a href="#n10" name="n10">10</a></strong></span>  Id : Guid
<span class="line-numbers"><a href="#n11" name="n11">11</a></span>  Name : string
<span class="line-numbers"><a href="#n12" name="n12">12</a></span>  Email : string
<span class="line-numbers"><a href="#n13" name="n13">13</a></span>}
<span class="line-numbers"><a href="#n14" name="n14">14</a></span>
<span class="line-numbers"><a href="#n15" name="n15">15</a></span>let createPerson person =
<span class="line-numbers"><a href="#n16" name="n16">16</a></span>  let newPerson = {person with Id = Guid.NewGuid()}
<span class="line-numbers"><a href="#n17" name="n17">17</a></span>  newPerson
<span class="line-numbers"><a href="#n18" name="n18">18</a></span>
<span class="line-numbers"><a href="#n19" name="n19">19</a></span>let getPeople () = [
<span class="line-numbers"><strong><a href="#n20" name="n20">20</a></strong></span>  {Id = Guid.NewGuid(); Name = &quot;john&quot;; Email = &quot;j@g.co&quot;}
<span class="line-numbers"><a href="#n21" name="n21">21</a></span>  {Id = Guid.NewGuid(); Name = &quot;mark&quot;; Email = &quot;m@g.co&quot;}]
<span class="line-numbers"><a href="#n22" name="n22">22</a></span>
<span class="line-numbers"><a href="#n23" name="n23">23</a></span>let getPersonById id =
<span class="line-numbers"><a href="#n24" name="n24">24</a></span>  {Id = Guid.Parse(id); Name = &quot;john&quot;; Email = &quot;j@g.co&quot;}
<span class="line-numbers"><a href="#n25" name="n25">25</a></span>  |&gt; ToJson ok
<span class="line-numbers"><a href="#n26" name="n26">26</a></span>
<span class="line-numbers"><a href="#n27" name="n27">27</a></span>let deletePersonById id =
<span class="line-numbers"><a href="#n28" name="n28">28</a></span>  sprintf &quot;person %s deleted&quot; id |&gt; OK
<span class="line-numbers"><a href="#n29" name="n29">29</a></span>
<span class="line-numbers"><strong><a href="#n30" name="n30">30</a></strong></span>let app =
<span class="line-numbers"><a href="#n31" name="n31">31</a></span>  choose [
<span class="line-numbers"><a href="#n32" name="n32">32</a></span>    path &quot;/people&quot; &gt;=&gt; choose [
<span class="line-numbers"><a href="#n33" name="n33">33</a></span>      POST &gt;=&gt; MapJson created createPerson
<span class="line-numbers"><a href="#n34" name="n34">34</a></span>      GET &gt;=&gt; ToJson ok (getPeople ())
<span class="line-numbers"><a href="#n35" name="n35">35</a></span>      PUT &gt;=&gt; MapJson accepted id
<span class="line-numbers"><a href="#n36" name="n36">36</a></span>    ]
<span class="line-numbers"><a href="#n37" name="n37">37</a></span>    GET &gt;=&gt; pathScan &quot;/people/%s&quot; getPersonById
<span class="line-numbers"><a href="#n38" name="n38">38</a></span>    DELETE &gt;=&gt; pathScan &quot;/people/%s&quot; deletePersonById
<span class="line-numbers"><a href="#n39" name="n39">39</a></span>  ]
</pre></div>
</div>
</div>
<blockquote>
  <p>To keep things simple, I am hard coding the values here. It can easily be extended to talk to any data source</p>
</blockquote>

<p>Our <code>SuaveAdapter</code> has capable of handling different HTTP methods and but it hasn’t been programmed to deal with different paths.</p>

<p>Here in this example we need to support two separate paths</p>

<pre><code>GET /people
GET /people/feafa5b5-304d-455e-b7e7-13a5b3293f77
</code></pre>

<p>The HTTP endpoint to call an Azure function has the format</p>

<pre><code>https://{azure-function-app-name}.azurewebsites.net/api/{function-name}
</code></pre>

<p>At this point of writing it doesn’t support multiple paths. So, we need to find a workaround to do it.</p>

<p>One way achieving this is to pass the <em>paths</em> as a Header. Let’s name the Header key as <code>X-Suave-URL</code>. Upon receiving the request we can rewrite the URL as</p>

<pre><code>https://{azure-function-app-name}.azurewebsites.net/{header-value-of-X-Suave-URL}
</code></pre>

<p>Let’s update <code>SuaveAdapter.fsx</code> to do this</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"> <a href="#n1" name="n1">1</a></span>let RunWebPartWithPathAsync app httpRequest = async {
<span class="line-numbers"> <a href="#n2" name="n2">2</a></span>  let! suaveContext = SuaveContext httpRequest
<span class="line-numbers"> <a href="#n3" name="n3">3</a></span>  let netHeaderValue = NetHeaderValue httpRequest.Headers
<span class="line-numbers"> <a href="#n4" name="n4">4</a></span>  match netHeaderValue &quot;X-Suave-URL&quot;, netHeaderValue &quot;Host&quot;  with
<span class="line-numbers"> <a href="#n5" name="n5">5</a></span>  | Some suaveUrl, Some host -&gt;
<span class="line-numbers"> <a href="#n6" name="n6">6</a></span>    let url = sprintf &quot;https://%s%s&quot; host suaveUrl |&gt; System.Uri
<span class="line-numbers"> <a href="#n7" name="n7">7</a></span>    let ctx = {suaveContext with
<span class="line-numbers"> <a href="#n8" name="n8">8</a></span>                request = {suaveContext.request with
<span class="line-numbers"> <a href="#n9" name="n9">9</a></span>                            url = url
<span class="line-numbers"><strong><a href="#n10" name="n10">10</a></strong></span>                            rawQuery = SuaveRawQuery url}}
<span class="line-numbers"><a href="#n11" name="n11">11</a></span>    return! SuaveRunAsync app ctx
<span class="line-numbers"><a href="#n12" name="n12">12</a></span>  | _ -&gt; return! SuaveRunAsync app suaveContext
<span class="line-numbers"><a href="#n13" name="n13">13</a></span>}
</pre></div>
</div>
</div>

<p>The final step is updating the <code>run.fsx</code> file to use this new function</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"> <a href="#n1" name="n1">1</a></span>#load &quot;SuaveAdapter.fsx&quot;
<span class="line-numbers"> <a href="#n2" name="n2">2</a></span>#load &quot;app.fsx&quot;
<span class="line-numbers"> <a href="#n3" name="n3">3</a></span>open SuaveAdapter
<span class="line-numbers"> <a href="#n4" name="n4">4</a></span>open App
<span class="line-numbers"> <a href="#n5" name="n5">5</a></span>open System.Net.Http
<span class="line-numbers"> <a href="#n6" name="n6">6</a></span>open Suave
<span class="line-numbers"> <a href="#n7" name="n7">7</a></span>
<span class="line-numbers"> <a href="#n8" name="n8">8</a></span>let Run (req : HttpRequestMessage) =
<span class="line-numbers"> <a href="#n9" name="n9">9</a></span>  let res, _ = RunWebPartWithPathAsync app req |&gt; Async.RunSynchronously
<span class="line-numbers"><strong><a href="#n10" name="n10">10</a></strong></span>  res
</pre></div>
</div>
</div>

<p><strong>Serverless REST API in Action</strong></p>

<p><img class="center border" src="/images/AzureFunctionsSuave/HelloRestRequests.jpeg"></p>

<blockquote>
  <p>This blog post is a proof of concept to use Suave in Azure Functions. There are a lot of improvements to be made to make it production ready. I am planning to publish this as a NuGet package based on the feedback from the community.</p>
</blockquote>

<p><strong>Update</strong> : <a href="https://www.nuget.org/packages/Suave.Azure.Functions">Suave.Azure.Functions</a> is available now as a Nuget Package</p>

<h2 id="summary">Summary</h2>

<blockquote class="twitter-tweet" data-lang="en"><p lang="en" dir="ltr">&quot;F# is a general purpose language, not just a science, or data science language.&quot; <a href="https://twitter.com/tomaspetricek">@tomaspetricek</a> <a href="https://twitter.com/hashtag/ndcoslo?src=hash">#ndcoslo</a> <a href="https://twitter.com/hashtag/fsharp?src=hash">#fsharp</a></p>&mdash; Bryan Hunter (@bryan_hunter) <a href="https://twitter.com/bryan_hunter/status/741164339747520514">June 10, 2016</a></blockquote>

<blockquote class="twitter-tweet" data-lang="en"><p lang="en" dir="ltr">*PLEASE* Microsoft, stop saying <a href="https://twitter.com/hashtag/fsharp?src=hash">#fsharp</a> is great for &quot;financial applications and stuff like that&quot;. It&#39;s a bloody general purpose language.</p>&mdash; Isaac Abraham (@isaac_abraham) <a href="https://twitter.com/isaac_abraham/status/740209486359605248">June 7, 2016</a></blockquote>

<p>The complete source code is available in <a href="https://github.com/tamizhvendan/TamAzureFun">my GitHub repository</a>.</p>

<h2 id="are-you-interested-in-learning-more-about-f">Are you interested in learning more about F#?</h2>

<p>I’m delighted to share that I’m running a tutorial at <a href="https://skillsmatter.com/conferences/7431-progressive-f-sharp-tutorials-2016">Progressive F# Tutorials 2016</a>, London on Dec 5, 2016. I’m excited to share my experiences with Suave and help developers to understand this wonderful F# library.</p>

<p>The Progressive F# Tutorials offer hands-on learning for every skill set and is led by some of the best experts in F# and functional programming</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Implementing API Gateway in F# using Rx and Suave]]></title>
    <link href="http://blog.tamizhvendan.in/blog/2015/12/29/implementing-api-gateway-in-f-number-using-rx-and-suave/"/>
    <updated>2015-12-29T09:22:49+05:30</updated>
    <id>http://blog.tamizhvendan.in/blog/2015/12/29/implementing-api-gateway-in-f-number-using-rx-and-suave</id>
    <content type="html"><![CDATA[<p>One of the impressive aspects of functional programming is that it will enable you to write simple and expressive code to solve  complex problems. If you are wondering, how is it possible? Well, It is because, Functional Programming provides a lot of higher level abstractions to solve the problem in hand and avoids the need of writing lot of boilerplate &amp; plumbing code. As a developer, you will be more productive and deliver the solution faster.</p>

<p>In this blog post, we are going to see the application of the above statements by implementing an <a href="https://www.nginx.com/blog/building-microservices-using-an-api-gateway">API Gateway Pattern</a> in F# using <a href="http://reactivex.io/">Rx</a> and <a href="https://suave.io/">Suave</a>.  </p>

<blockquote>
  <p>This blog post is my contribution towards <a href="https://sergeytihon.wordpress.com/2015/10/25/f-advent-calendar-in-english-2015/">fsharp advent calendar 2015</a>. Do check out other great fsharp posts there</p>
</blockquote>

<h2 id="api-gateway-pattern">API Gateway Pattern</h2>
<p>Let’s assume that you are asked to build the backend for the below GitHub user profile screen.</p>

<p><img src="http://res.cloudinary.com/tamizhvendan/image/upload/v1450769741/Profile.png" alt="Github Profile" /></p>

<p>This profile screen has 3 components</p>

<ol>
  <li>
    <p>User - Username and Avatar</p>
  </li>
  <li>
    <p>Popular Repos - Top 3 Repos of the Given User (determined by the number of stars)</p>
  </li>
  <li>
    <p>Languages being used in the corresponding repos</p>
  </li>
</ol>

<p>Now as a developer, you have two options</p>

<ul>
  <li>
    <p>Build the Profile completely in client side by calling their corresponding GitHub APIs
<img src="http://res.cloudinary.com/tamizhvendan/image/upload/v1450769816/Profile_With_API_Calls.png" alt="Profile with URLs" /></p>

    <p>This approach makes the client side complex as it involves five HTTP requests to create the complete profile screen. It has a lot of drawbacks as mentioned in <a href="http://techblog.netflix.com/2013/01/optimizing-netflix-api.html">this blog post</a> by Netflix.</p>
  </li>
  <li>
    <p>Create a Facade API which takes care of the heavy lifting and hides the complexity of calling multiple services by  exposing a single endpoint which returns all the data required to create the profile screen in one API call
<img src="http://res.cloudinary.com/tamizhvendan/image/upload/v1450775641/API_Gateway.png" alt="API Gateway" /></p>

    <p>This approach is called API Gateway. It is one of the commonly used <a href="http://microservices.io/patterns/apigateway.html">patterns in the microservices</a> world.</p>
  </li>
</ul>

<h2 id="rx">Rx</h2>

<p>API Gateway is normally implemented using <a href="http://reactivex.io/">Rx</a>. Rx, an implementation of <a href="https://gist.github.com/staltz/868e7e9bc2a7b8c1f754">Functional Reactive Programming</a>, makes it easy to implement this kind of problems by enable us to think each asynchronous operation as streams (aka Observables). These streams offer a declarative API to work with the asynchronous operations.</p>

<p>In the implementation that we are going to see, we will be using <a href="http://fsprojects.github.io/FSharp.Control.Reactive/">FSharp.Control.Reactive</a>, an extension and wrapper for using the Reactive Extensions (Rx) with F#</p>

<h2 id="project-structure">Project Structure</h2>

<p>Create a new F# Console Application Project with the name <code>RxFsharp</code> and then create the files mentioned below in the given order</p>

<pre><code>RxFsharp
|--Http.fs --&gt; Abstraction to make http requests
|--GitHub.fs --&gt; Define data types, transforming &amp; parsing of responses from GitHub
|--ObservableExtensions.fs --&gt; Some Util methods over Rx Observable
|--Profile.fs --&gt; Implemention of API Gateway using Rx
|--ApiGateway.fs --&gt; Suave API
|--Program.fs --&gt; Entry Point
|--user.json --&gt; Sample response of GitHub user API
|--repos.json --&gt; Sample response of GitHub repos API
|--App.config
|--packages.config
</code></pre>

<p>Then install the following NuGet packages</p>

<ul>
  <li><a href="https://www.nuget.org/packages/FSharp.Control.Reactive">FSharp.Control.Reactive</a></li>
  <li><a href="https://www.nuget.org/packages/Http.fs">Http.fs</a></li>
  <li><a href="https://www.nuget.org/packages/Suave">Suave</a></li>
  <li><a href="https://www.nuget.org/packages/Newtonsoft.Json">Newtonsoft.Json</a></li>
  <li><a href="https://www.nuget.org/packages/FSharp.Data">FSharp.Data</a></li>
</ul>

<h2 id="modeling-http-request--response-as-stream">Modeling Http Request &amp; Response as Stream</h2>

<p>In Functional Reactive Programming(FRP) every action is treated as stream. So, first step in implementing an API Gateway is modeling each HTTP request&amp;response as stream.</p>

<p>Open <code>Http.fs</code> file and update it as below</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"> <a href="#n1" name="n1">1</a></span>module Http
<span class="line-numbers"> <a href="#n2" name="n2">2</a></span>
<span class="line-numbers"> <a href="#n3" name="n3">3</a></span>open HttpClient
<span class="line-numbers"> <a href="#n4" name="n4">4</a></span>open FSharp.Control.Reactive
<span class="line-numbers"> <a href="#n5" name="n5">5</a></span>
<span class="line-numbers"> <a href="#n6" name="n6">6</a></span>type HttpResponse =
<span class="line-numbers"> <a href="#n7" name="n7">7</a></span>| Ok of string
<span class="line-numbers"> <a href="#n8" name="n8">8</a></span>| Error of int
<span class="line-numbers"> <a href="#n9" name="n9">9</a></span>
<span class="line-numbers"><strong><a href="#n10" name="n10">10</a></strong></span>let getResponseAsync url =
<span class="line-numbers"><a href="#n11" name="n11">11</a></span>  async {
<span class="line-numbers"><a href="#n12" name="n12">12</a></span>    let! response =
<span class="line-numbers"><a href="#n13" name="n13">13</a></span>      createRequest Get url
<span class="line-numbers"><a href="#n14" name="n14">14</a></span>      |&gt; withHeader (UserAgent &quot;FsharpRx&quot;)
<span class="line-numbers"><a href="#n15" name="n15">15</a></span>      |&gt; HttpClient.getResponseAsync
<span class="line-numbers"><a href="#n16" name="n16">16</a></span>    let httpResponse =
<span class="line-numbers"><a href="#n17" name="n17">17</a></span>      match response.StatusCode with
<span class="line-numbers"><a href="#n18" name="n18">18</a></span>      | 200 -&gt; response.EntityBody.Value |&gt; Ok
<span class="line-numbers"><a href="#n19" name="n19">19</a></span>      | _ -&gt; response.StatusCode |&gt; Error
<span class="line-numbers"><strong><a href="#n20" name="n20">20</a></strong></span>    return httpResponse
<span class="line-numbers"><a href="#n21" name="n21">21</a></span>  }
<span class="line-numbers"><a href="#n22" name="n22">22</a></span>
<span class="line-numbers"><a href="#n23" name="n23">23</a></span>let asyncResponseToObservable = getResponseAsync &gt;&gt; Observable.ofAsync
</pre></div>
</div>
</div>

<p>The <code>getResponseAsync</code> function makes use of <a href="https://github.com/relentless/Http.fs">Http.fs</a>, an HTTP Client library for F#, to fire the HTTP GET request and returns the HTTP response asynchronously.</p>

<p>The HTTP response has been modeled as either <code>Ok</code> with the response content for all the responses with the status code <code>200</code> and everything else is treated as <code>Error</code> for simplicity.</p>

<p>In the final line, we create a stream (aka Observable) from asynchronous response using the function <code>Observable.ofAsync</code> from <a href="https://github.com/fsprojects/FSharp.Control.Reactive">FSharp.Control.Reactive</a></p>

<p>As all the GitHub API <a href="https://developer.github.com/v3/#user-agent-required">requests require user agent</a>, we are adding one before firing the request.</p>

<h2 id="parsing-and-transforming-github-api-responses">Parsing and Transforming GitHub API Responses</h2>

<p>Upon successful response from GitHub, the next step is parsing the JSON response and transforming the parsed response as per the Profile screen requirements.</p>

<p>To parse the response, we are going to leverage the powerful tool of FSharp called <a href="http://fsharp.github.io/FSharp.Data/library/JsonProvider.html">JsonTypeProvider</a></p>

<p>The JSON Type Provider provides statically typed access to JSON documents. It takes a sample document as an input. Here in our case, it is user.json and repos.json</p>

<p>Get the sample response from GitHub using its <a href="https://api.github.com/users/tamizhvendan">User API</a> and <a href="https://api.github.com/users/tamizhvendan/repos">Repos API</a> and save the response in user.json and repos.json respectively.</p>

<p>With the help of JsonTypeProvider, we can now easily parse the raw JSON response to its equivalent types in just a few lines of code in <code>GitHub.fs</code>!</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"> <a href="#n1" name="n1">1</a></span>module GitHub
<span class="line-numbers"> <a href="#n2" name="n2">2</a></span>
<span class="line-numbers"> <a href="#n3" name="n3">3</a></span>open Http
<span class="line-numbers"> <a href="#n4" name="n4">4</a></span>open FSharp.Data
<span class="line-numbers"> <a href="#n5" name="n5">5</a></span>
<span class="line-numbers"> <a href="#n6" name="n6">6</a></span>type GitHubUser = JsonProvider&lt;&quot;user.json&quot;&gt;
<span class="line-numbers"> <a href="#n7" name="n7">7</a></span>type GitHubUserRepos = JsonProvider&lt;&quot;repos.json&quot;&gt;
<span class="line-numbers"> <a href="#n8" name="n8">8</a></span>
<span class="line-numbers"> <a href="#n9" name="n9">9</a></span>let parseUser = GitHubUser.Parse
<span class="line-numbers"><strong><a href="#n10" name="n10">10</a></strong></span>let parseUserRepos = GitHubUserRepos.Parse
</pre></div>
</div>
</div>

<p>As <code>GitHub.fs</code> is an abstraction of GitHub let’s put their URLs also here in the same file</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"><a href="#n1" name="n1">1</a></span>let host = &quot;https://api.github.com&quot;
<span class="line-numbers"><a href="#n2" name="n2">2</a></span>let userUrl = sprintf &quot;%s/users/%s&quot; host
<span class="line-numbers"><a href="#n3" name="n3">3</a></span>let reposUrl = sprintf &quot;%s/users/%s/repos&quot; host
<span class="line-numbers"><a href="#n4" name="n4">4</a></span>let languagesUrl repoName userName = sprintf &quot;%s/repos/%s/%s/languages&quot; host userName repoName
</pre></div>
</div>
</div>
<p>We have used <a href="http://fsharpforfunandprofit.com/posts/partial-application">partial application</a> of function <code>sprintf</code> in the <code>userUrl</code> and <code>reposUrl</code> function here, so both of these functions take username as its parameter implicitly</p>

<p>The JSON response of <a href="https://api.github.com/repos/tamizhvendan/fsharp-phonecat/languages">languages</a> API is little tricky to parse as its keys are dynamic. The type provider will work only if the underlying response has a fixed schema. So, we can’t use the type provider directly to parse the response of languages API.</p>

<p>We are going to use the inbuilt <a href="http://fsharp.github.io/FSharp.Data/library/JsonValue.html">JSON Parser</a> available with JsonTypeProvider to parse the languages response</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"><a href="#n1" name="n1">1</a></span>let parseLanguages languagesJson =
<span class="line-numbers"><a href="#n2" name="n2">2</a></span>  languagesJson
<span class="line-numbers"><a href="#n3" name="n3">3</a></span>  |&gt; JsonValue.Parse
<span class="line-numbers"><a href="#n4" name="n4">4</a></span>  |&gt; JsonExtensions.Properties
<span class="line-numbers"><a href="#n5" name="n5">5</a></span>  |&gt; Array.map fst
</pre></div>
</div>
</div>

<p>The <code>JsonValue.Parse</code> parses the raw string JSON to a type called <code>JsonValue</code> and the <code>JsonExtensions.Properties</code> function takes a <code>JsonValue</code> and returns the key and value pairs of all the properties in the JSON as tuples. As we are interested only in the Keys here, we just pluck that value alone using the function <code>fst</code></p>

<p>Great! Now we are done with parsing the JSON response of all the three APIs and creating it’s equivalent types. The next step is doing some business transformation</p>

<p>One of the requirements of the Profile Screen is that we need to show only the top 3 popular repositories based on the stars received by the repository. Let’s implement it</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"> <a href="#n1" name="n1">1</a></span>let popularRepos (repos : GitHubUserRepos.Root []) =
<span class="line-numbers"> <a href="#n2" name="n2">2</a></span>  let ownRepos = repos |&gt; Array.filter (fun repo -&gt; not repo.Fork)
<span class="line-numbers"> <a href="#n3" name="n3">3</a></span>  let takeCount = if ownRepos.Length &gt; 3 then 3 else repos.Length
<span class="line-numbers"> <a href="#n4" name="n4">4</a></span>
<span class="line-numbers"> <a href="#n5" name="n5">5</a></span>  ownRepos
<span class="line-numbers"> <a href="#n6" name="n6">6</a></span>  |&gt; Array.sortBy (fun r -&gt; -r.StargazersCount)
<span class="line-numbers"> <a href="#n7" name="n7">7</a></span>  |&gt; Array.toSeq
<span class="line-numbers"> <a href="#n8" name="n8">8</a></span>  |&gt; Seq.take takeCount
<span class="line-numbers"> <a href="#n9" name="n9">9</a></span>  |&gt; Seq.toArray
</pre></div>
</div>
</div>

<p>In the <code>Http.fs</code> file, we defined how to get the raw JSON response using Stream as <code>HttpResponse</code> (<code>Ok</code> &amp; <code>Error</code>) and in this <code>GitHub.fs</code>, we have defined how to parse this raw JSON response and transform them its equivalent strongly types.</p>

<p>The final step is integrating both these logic and return the Output record type needed by the Profile Screen</p>

<p>let’s start by defining the Profile type</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"> <a href="#n1" name="n1">1</a></span>type Profile = {
<span class="line-numbers"> <a href="#n2" name="n2">2</a></span>  Name : string
<span class="line-numbers"> <a href="#n3" name="n3">3</a></span>  AvatarUrl : string
<span class="line-numbers"> <a href="#n4" name="n4">4</a></span>  PopularRepositories : Repository seq
<span class="line-numbers"> <a href="#n5" name="n5">5</a></span>} and Repository = {
<span class="line-numbers"> <a href="#n6" name="n6">6</a></span>  Name : string
<span class="line-numbers"> <a href="#n7" name="n7">7</a></span>  Stars : int
<span class="line-numbers"> <a href="#n8" name="n8">8</a></span>  Languages : string[]
<span class="line-numbers"> <a href="#n9" name="n9">9</a></span>}
</pre></div>
</div>
</div>
<p>Then write functions to get the value from <code>HttpResponse</code> and create this profile output.</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"> <a href="#n1" name="n1">1</a></span>let reposResponseToPopularRepos = function
<span class="line-numbers"> <a href="#n2" name="n2">2</a></span>  |Ok(r) -&gt; r |&gt; parseUserRepos |&gt; popularRepos
<span class="line-numbers"> <a href="#n3" name="n3">3</a></span>  |_ -&gt; [||]
<span class="line-numbers"> <a href="#n4" name="n4">4</a></span>
<span class="line-numbers"> <a href="#n5" name="n5">5</a></span>// Languages always associated with a repository
<span class="line-numbers"> <a href="#n6" name="n6">6</a></span>let languageResponseToRepoWithLanguages (repo : GitHubUserRepos.Root) = function
<span class="line-numbers"> <a href="#n7" name="n7">7</a></span>  |Ok(l) -&gt; {Name = repo.Name; Languages = (parseLanguages l); Stars = repo.StargazersCount}
<span class="line-numbers"> <a href="#n8" name="n8">8</a></span>  |_ -&gt; {Name = repo.Name; Languages = Array.empty; Stars = repo.StargazersCount}
<span class="line-numbers"> <a href="#n9" name="n9">9</a></span>
<span class="line-numbers"><strong><a href="#n10" name="n10">10</a></strong></span>let toProfile  = function
<span class="line-numbers"><a href="#n11" name="n11">11</a></span>  |Ok(u), repos -&gt;
<span class="line-numbers"><a href="#n12" name="n12">12</a></span>      let user = parseUser u
<span class="line-numbers"><a href="#n13" name="n13">13</a></span>      {Name = user.Name; PopularRepositories = repos; AvatarUrl = user.AvatarUrl} |&gt; Some
<span class="line-numbers"><a href="#n14" name="n14">14</a></span>  | _ -&gt; None
</pre></div>
</div>
</div>

<p>All the above functions except <code>toProfile</code> take <code>HttpResponse</code> as its last parameter implicitly.</p>

<p>In <code>reposResponseToPopularRepos</code> function, if the repos API request is successful, we parse the response to its equivalent type and then pick only three of them based on star count and in the case of an error we just return an empty array.</p>

<p>The <code>languageResponseToRepoWithLanguages</code> function handles the response from the Languages API request which takes its associated repository as its first parameter. If the response is successful, then it creates the <code>Repository</code> record with the returned languages else it just the <code>Repository</code> record with an empty array for languages.</p>

<p>The last function <code>toProfile</code> is a merge function which takes a tuple of <code>HttpResponse</code> (of User API request) and <code>Repository []</code> and creates a <code>Profile</code> record if the response is successful. In case of an error, it just returns <code>None</code></p>

<p><em>Note: To keep this blog post simple, I am handling the errors using empty arrays and None. It can be extended using <a href="http://fsharpforfunandprofit.com/rop/">ROP</a></em></p>

<h2 id="implementing-api-gateway">Implementing API Gateway</h2>

<p>Let me quickly summarize what we have done so far. We have created two abstractions.</p>

<ul>
  <li><code>Http</code> - Responsible for firing the HTTP GET request with the given URL and give the response as a Rx Stream</li>
</ul>

<pre><code>URL
  \
----------Response--|

</code></pre>

<ul>
  <li><code>GitHub</code> - Takes care of parsing the JSON response from GitHub API and does some business logic (finding top 3 popular repositories). Then returns the output in the format that the Client needs.</li>
</ul>

<p>With the help of these abstractions now we are going to build the API Gateway to get the profile object.</p>

<p>Open <code>Gateway.fs</code> and add the <code>getProfile</code> function</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"><a href="#n1" name="n1">1</a></span>//string -&gt; Async&lt;Profile&gt;
<span class="line-numbers"><a href="#n2" name="n2">2</a></span>let getProfile username =
<span class="line-numbers"><a href="#n3" name="n3">3</a></span>  async {
<span class="line-numbers"><a href="#n4" name="n4">4</a></span>    // TODO
<span class="line-numbers"><a href="#n5" name="n5">5</a></span>    return! profile
<span class="line-numbers"><a href="#n6" name="n6">6</a></span>  }
</pre></div>
</div>
</div>
<p>It is just a skeleton which just describes the what function does. Let’s start its implementation.</p>

<p>In Rx world, everything is a stream. So, the first step is converting GitHub User API request to stream</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"><a href="#n1" name="n1">1</a></span>let getProfile username =
<span class="line-numbers"><a href="#n2" name="n2">2</a></span>  // ...
<span class="line-numbers"><a href="#n3" name="n3">3</a></span>  let userStream = username |&gt; userUrl |&gt; asyncResponseToObservable
<span class="line-numbers"><a href="#n4" name="n4">4</a></span>  // ...
</pre></div>
</div>
</div>

<p>We have created the <code>userStream</code> using the <code>userUrl</code> and <code>asyncResponseToObservable</code> function defined earlier.</p>

<pre><code>userURL
  \
-----------UJ--|              // UJ - GitHub User Response in JSON format
</code></pre>

<p>Then we need top three popular repositories as a stream</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"><a href="#n1" name="n1">1</a></span>let getProfile username =
<span class="line-numbers"><a href="#n2" name="n2">2</a></span>  // ...
<span class="line-numbers"><a href="#n3" name="n3">3</a></span>  let popularReposStream =
<span class="line-numbers"><a href="#n4" name="n4">4</a></span>    username
<span class="line-numbers"><a href="#n5" name="n5">5</a></span>    |&gt; reposUrl
<span class="line-numbers"><a href="#n6" name="n6">6</a></span>    |&gt; asyncResponseToObservable
<span class="line-numbers"><a href="#n7" name="n7">7</a></span>    |&gt; Observable.map reposResponseToPopularRepos
<span class="line-numbers"><a href="#n8" name="n8">8</a></span>  // ...
</pre></div>
</div>
</div>

<p>Except the last line, everything is same as that of creating <code>userStream</code>. If you check <a href="https://api.github.com/users/tamizhvendan/repos">GitHub repos API</a> it just returns all the repos associated with the given username. But what we need is only top three of them based on the number of stars it has received.</p>

<p>We already have a function <code>reposResponseToPopularRepos</code> in <code>GitHub.fs</code> which does the job of picking the top three repos from the raw JSON. As the response is in the form Rx stream, we need to get the value from the stream and then we need to apply this function and that’s what the <code>Observable.map</code> does. It is very similar to <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/map">Array.map</a> and <a href="https://msdn.microsoft.com/en-us/library/system.linq.enumerable.select(v=vs.100).aspx">LINQ Select</a></p>

<pre><code>reposURL
  \
----------RJ---|                          // RJ - GitHub user repos in JSON format
          | MAP function (RJ -&gt; PR)       // PR - Popular Repos
          V
--------------PR---|
</code></pre>

<p>The next operation is a little complex. i.e. finding out the programming languages being used in these popular repositories. To get this GitHub API, we need to fire three separate requests to the <a href="https://developer.github.com/v3/repos/#list-languages">Languages API</a> for each repository and then merge the results back with the corresponding repository.</p>

<p>To implement this with the help of Rx streams, we need to understand the <code>flatMap</code> <a href="http://reactivex.io/documentation/operators/flatmap.html">function of Rx</a>.</p>

<p>It is similar to the <code>map</code> function that we have seen before with a difference that it takes a function that returns a new item stream instead of a new item.</p>

<h3 id="map">Map</h3>

<p><img src="http://reactivex.io/documentation/operators/images/map.c.png" alt="Map" /></p>

<p>The <code>map</code> function has the following signature</p>

<pre><code>('a -&gt; 'b) -&gt; IObservable&lt;'a&gt; -&gt; IObservable&lt;'b&gt;
</code></pre>

<h3 id="flatmap">FlatMap</h3>

<p><img src="http://reactivex.io/documentation/operators/images/flatMap.c.png" alt="FlatMap" /></p>

<p>The <code>flatMap</code> function has the following signature</p>

<pre><code>('a -&gt; IObservable&lt;'b&gt;) -&gt; IObservable&lt;'a&gt; -&gt; IObservable&lt;'b&gt;
</code></pre>

<p>This function is also called as <code>bind</code> function in the functional programming world. If you would like to know further on this topic, I strongly recommend <a href="http://fsharpforfunandprofit.com/posts/elevated-world">this blog series</a> by the fsharp great, <a href="https://twitter.com/ScottWlaschin">Scott Wlaschin</a></p>

<p>Back to the problem in hand, we need to fire three HTTP GET Requests to get back the languages associated with the each of the top three popular repos. In terms of the <code>flatMap</code> function, it boils down to three functions of the following syntax</p>

<pre><code>(GitHubUserRepos.Root -&gt; IObservable&lt;Repostiory&gt;)
  -&gt; IObservable&lt;GitHubUserRepos.Root&gt; -&gt; IObservable&lt;Repostiory&gt;
</code></pre>

<p>We can implement the solution using three <code>flatMap</code> functions using the above syntax. But, we can make it more granular by creating a new variant of <code>flatMap</code> function to achieve this in a more straightforward way.</p>

<p>The ideal function that we are looking for in this <code>flatMap</code> variant holds the following signature</p>

<pre><code>('a -&gt; IObservable&lt;'b&gt;) -&gt; IObservable&lt;'a []&gt; -&gt; IObservable&lt;'b []&gt;
</code></pre>
<p>i.e three <code>flatMap</code> can be rewritten as</p>

<pre><code>(GitHubUserRepos.Root -&gt; IObservable&lt;Repostiory&gt;)
  -&gt; IObservable&lt;GitHubUserRepos.Root []&gt; -&gt; IObservable&lt;Repostiory []&gt;
</code></pre>

<p>Let’s name it as <code>flatMap2</code> and add the implementation of it in the file <code>ObservableExtensions.fs</code></p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"><a href="#n1" name="n1">1</a></span>module ObservableExtensions
<span class="line-numbers"><a href="#n2" name="n2">2</a></span>open FSharp.Control.Reactive
<span class="line-numbers"><a href="#n3" name="n3">3</a></span>
<span class="line-numbers"><a href="#n4" name="n4">4</a></span>let flatmap2 f observable =
<span class="line-numbers"><a href="#n5" name="n5">5</a></span>  observable
<span class="line-numbers"><a href="#n6" name="n6">6</a></span>  |&gt; Observable.flatmap (Array.map f &gt;&gt; Observable.mergeArray)
<span class="line-numbers"><a href="#n7" name="n7">7</a></span>  |&gt; Observable.toArray
</pre></div>
</div>
</div>

<p>Here is the representation of what this function does</p>

<pre><code>-----X[n]--------------------------|-&gt;
      \   flatMap on each item in X which yield the stream of R
-------R1-------------------------|-&gt;
----------R2----------------------|-&gt;
          ......
-------------Rn-------------------|-&gt;
          ||  mergeArray -&gt; merge array of R streams into one stream
          VV
------R1-R2--Rn-------------------|-&gt;
              \ toArray -&gt; Creates an array from an observable sequence
-------------R[n]-----------------|-&gt;
</code></pre>

<p>It’s hard to get it right in a single shot. So, let’s see it in detail step by step by applying it to our use case here</p>

<ul>
  <li>We have the stream of three popular repos (i.e array of repos)</li>
</ul>

<pre><code>-----X[n]--------------------------|-&gt;
</code></pre>
<ul>
  <li>To get the languages associated with the each repo we need to call the languages API for every repo item in the above step</li>
</ul>

<pre><code>-----X[n]--------------------------|-&gt;
      \   flatMap on each item in X which yield the n streams of R
-------R1-------------------------|-&gt;
----------R2----------------------|-&gt;
          ......
-------------Rn-------------------|-&gt;
</code></pre>
<ul>
  <li>After we received the response from each languages API call, we need to merge them into one stream</li>
</ul>

<pre><code>-------R1-------------------------|-&gt;
----------R2----------------------|-&gt;
          ......
-------------Rn-------------------|-&gt;
          |  mergeArray -&gt; merge array of R streams into one stream
          V
------R1-R2--Rn-------------------|-&gt;
</code></pre>

<ul>
  <li>To integrate this with the expected application response, we need all the responses in a single go</li>
</ul>

<pre><code>------R1-R2--Rn-------------------|-&gt;
              \ toArray -&gt; Creates an array from an observable sequence
-------------R[n]-----------------|-&gt;
</code></pre>

<p>Great! You got it right!!</p>

<p>Let’s use this <code>flatMap2</code> function and complete the implementation of profile API gateway.</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"> <a href="#n1" name="n1">1</a></span>let getProfile username =
<span class="line-numbers"> <a href="#n2" name="n2">2</a></span>  // ...
<span class="line-numbers"> <a href="#n3" name="n3">3</a></span>  let toRepoWithLanguagesStream (repo : GitHubUserRepos.Root) =    
<span class="line-numbers"> <a href="#n4" name="n4">4</a></span>    username
<span class="line-numbers"> <a href="#n5" name="n5">5</a></span>    |&gt; languagesUrl repo.Name
<span class="line-numbers"> <a href="#n6" name="n6">6</a></span>    |&gt; asyncResponseToObservable
<span class="line-numbers"> <a href="#n7" name="n7">7</a></span>    |&gt; Observable.map (languageResponseToRepoWithLanguages repo)
<span class="line-numbers"> <a href="#n8" name="n8">8</a></span>
<span class="line-numbers"> <a href="#n9" name="n9">9</a></span>  let popularReposStream =
<span class="line-numbers"><strong><a href="#n10" name="n10">10</a></strong></span>    username
<span class="line-numbers"><a href="#n11" name="n11">11</a></span>    |&gt; reposUrl
<span class="line-numbers"><a href="#n12" name="n12">12</a></span>    |&gt; asyncResponseToObservable
<span class="line-numbers"><a href="#n13" name="n13">13</a></span>    |&gt; Observable.map reposResponseToPopularRepos
<span class="line-numbers"><a href="#n14" name="n14">14</a></span>    |&gt; flatmap2 toRepoWithLanguagesStream
<span class="line-numbers"><a href="#n15" name="n15">15</a></span>
<span class="line-numbers"><a href="#n16" name="n16">16</a></span>  // ...
</pre></div>
</div>
</div>

<p>The <code>flatmap2</code> function takes the function <code>toRepoWithLanguagesStream</code> which converts the <code>GitHubUserRepos.Root</code> type to <code>IObservable&lt;Repository&gt;</code> to find out the languages associated with the given popular repositories.</p>

<p>The <code>toRepoWithLanguagesStream</code> function does the following</p>

<pre><code>GitHubUserRepos.Root
  \ create a languages GitHub API stream using the repo name from the input
-------LR----------|              // LR - languages GitHub API response
        \ MAP function (GitHubUserRepos.Root -&gt; LR -&gt; R)
------------R------|              // R - Repository type that defined earlier
</code></pre>
<p>The <code>Observable.map</code> function takes only one input, but here we need to two inputs. So, With the help of <a href="http://fsharpforfunandprofit.com/posts/partial-application/">partial application</a>, we created an intermediate function by partially applying the first parameter alone</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"><a href="#n1" name="n1">1</a></span>Observable.map (languageResponseToRepoWithLanguages repo)
</pre></div>
</div>
</div>

<p>The <code>languageResponseToRepoWithLanguages</code> function has been already defined in the <code>GitHub.fs</code> file.</p>

<p>The last step of the <code>getProfile</code> function is combining this <code>popularReposStream</code> with the <code>userStream</code> created earlier and return the <code>Profile</code> type asynchronously.</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"> <a href="#n1" name="n1">1</a></span>let getProfile username =
<span class="line-numbers"> <a href="#n2" name="n2">2</a></span>  // ...
<span class="line-numbers"> <a href="#n3" name="n3">3</a></span>  async {
<span class="line-numbers"> <a href="#n4" name="n4">4</a></span>    return! popularReposStream
<span class="line-numbers"> <a href="#n5" name="n5">5</a></span>            |&gt; Observable.zip userStream
<span class="line-numbers"> <a href="#n6" name="n6">6</a></span>            |&gt; Observable.map toProfile
<span class="line-numbers"> <a href="#n7" name="n7">7</a></span>            |&gt; TaskObservableExtensions.ToTask
<span class="line-numbers"> <a href="#n8" name="n8">8</a></span>            |&gt; Async.AwaitTask
<span class="line-numbers"> <a href="#n9" name="n9">9</a></span>  }
<span class="line-numbers"><strong><a href="#n10" name="n10">10</a></strong></span>  // ...
</pre></div>
</div>
</div>

<p>The <code>Observable.zip</code> function takes two streams as its input, then merges the output of each stream and return the output as a tuple. From this tuple, we have used <code>Observable.map</code> function to map it a <code>Profile</code> type using the <code>toProfile</code> function created earlier in <code>GitHub.fs</code></p>

<pre><code>-----UR-------------|     // UR - GitHub User API Response
--------PR----------|     // PR - Popular Repos
        \ ZIP function (UR -&gt; PR -&gt; (UR,PR))   
---------(UR,PR)----|
          \ MAP ( (UR,PR) -&gt; P )  // P - Profile
----------P---------|
</code></pre>

<p>The last functions <code>TaskObservableExtensions.ToTask</code> and <code>Async.AwaitTask</code> does the conversion of <code>IObservable</code> to <code>async</code> by converting it to a <code>Task</code> first and then the <code>Task</code> to <code>async</code></p>

<p>The final <code>getProfile</code> function will be like</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"> <a href="#n1" name="n1">1</a></span>
<span class="line-numbers"> <a href="#n2" name="n2">2</a></span>let getProfile username =
<span class="line-numbers"> <a href="#n3" name="n3">3</a></span>
<span class="line-numbers"> <a href="#n4" name="n4">4</a></span>  let userStream = username |&gt; userUrl |&gt; asyncResponseToObservable
<span class="line-numbers"> <a href="#n5" name="n5">5</a></span>
<span class="line-numbers"> <a href="#n6" name="n6">6</a></span>  let toRepoWithLanguagesStream (repo : GitHubUserRepos.Root) =    
<span class="line-numbers"> <a href="#n7" name="n7">7</a></span>    username
<span class="line-numbers"> <a href="#n8" name="n8">8</a></span>    |&gt; languagesUrl repo.Name
<span class="line-numbers"> <a href="#n9" name="n9">9</a></span>    |&gt; asyncResponseToObservable
<span class="line-numbers"><strong><a href="#n10" name="n10">10</a></strong></span>    |&gt; Observable.map (languageResponseToRepoWithLanguages repo)
<span class="line-numbers"><a href="#n11" name="n11">11</a></span>
<span class="line-numbers"><a href="#n12" name="n12">12</a></span>  let popularReposStream =
<span class="line-numbers"><a href="#n13" name="n13">13</a></span>    username
<span class="line-numbers"><a href="#n14" name="n14">14</a></span>    |&gt; reposUrl
<span class="line-numbers"><a href="#n15" name="n15">15</a></span>    |&gt; asyncResponseToObservable
<span class="line-numbers"><a href="#n16" name="n16">16</a></span>    |&gt; Observable.map reposResponseToPopularRepos
<span class="line-numbers"><a href="#n17" name="n17">17</a></span>    |&gt; flatmap2 toRepoWithLanguagesStream
<span class="line-numbers"><a href="#n18" name="n18">18</a></span>
<span class="line-numbers"><a href="#n19" name="n19">19</a></span>  async {
<span class="line-numbers"><strong><a href="#n20" name="n20">20</a></strong></span>    return! popularReposStream
<span class="line-numbers"><a href="#n21" name="n21">21</a></span>            |&gt; Observable.zip userStream
<span class="line-numbers"><a href="#n22" name="n22">22</a></span>            |&gt; Observable.map toProfile
<span class="line-numbers"><a href="#n23" name="n23">23</a></span>            |&gt; TaskObservableExtensions.ToTask
<span class="line-numbers"><a href="#n24" name="n24">24</a></span>            |&gt; Async.AwaitTask
<span class="line-numbers"><a href="#n25" name="n25">25</a></span>  }
</pre></div>
</div>
</div>

<p>This function is a testimonial on <em>How functional programming helps to write less, robust, and readable code to solve a complex problem</em></p>

<p>We have handled all the five HTTP requests asynchronously, did some error handling (by returning empty types), and finally efficiently combined outputs of these five HTTP requests and created a type to send back to the client. Everything is asynchronous!</p>

<p>Pretty awesome isn’t it?</p>

<h2 id="exposing-the-api">Exposing the API</h2>

<p>The final step is exposing what we have done so far as an API to the outside world. We are going to implement this using <a href="https://suave.io/">Suave</a></p>

<p>Open <code>ApiGateway.fs</code> file and update it as below</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"> <a href="#n1" name="n1">1</a></span>let JSON v =  
<span class="line-numbers"> <a href="#n2" name="n2">2</a></span>  let jsonSerializerSettings = new JsonSerializerSettings()
<span class="line-numbers"> <a href="#n3" name="n3">3</a></span>  jsonSerializerSettings.ContractResolver &lt;- new CamelCasePropertyNamesContractResolver()
<span class="line-numbers"> <a href="#n4" name="n4">4</a></span>
<span class="line-numbers"> <a href="#n5" name="n5">5</a></span>  JsonConvert.SerializeObject(v, jsonSerializerSettings)
<span class="line-numbers"> <a href="#n6" name="n6">6</a></span>  |&gt; OK
<span class="line-numbers"> <a href="#n7" name="n7">7</a></span>  &gt;=&gt; Writers.setMimeType &quot;application/json; charset=utf-8&quot;
<span class="line-numbers"> <a href="#n8" name="n8">8</a></span>
<span class="line-numbers"> <a href="#n9" name="n9">9</a></span>let getProfile userName (httpContext : HttpContext) =
<span class="line-numbers"><strong><a href="#n10" name="n10">10</a></strong></span>   async {
<span class="line-numbers"><a href="#n11" name="n11">11</a></span>      let! profile = getProfile userName
<span class="line-numbers"><a href="#n12" name="n12">12</a></span>      match profile with
<span class="line-numbers"><a href="#n13" name="n13">13</a></span>      | Some p -&gt; return! JSON p httpContext
<span class="line-numbers"><a href="#n14" name="n14">14</a></span>      | None -&gt; return! NOT_FOUND (sprintf &quot;Username %s not found&quot; userName) httpContext
<span class="line-numbers"><a href="#n15" name="n15">15</a></span>   }
</pre></div>
</div>
</div>

<p>The <code>JSON</code> is a utility function (WebPart in the world of Suave) which takes any type, serialize it to JSON format and return it as JSON HTTP response.</p>

<p>The <code>getProfile</code> function is the API WebPart which calls our backend API gateway implementation and pass the received response to the <code>JSON</code> WebPart defined before.</p>

<p>In case if there is no profile available (Remember? we return empty types in case of errors), we just return <code>404</code> with the message that the given username is not found.</p>

<p>Then update the <code>Program.fs</code> to write the web server code</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"><a href="#n1" name="n1">1</a></span>[&lt;EntryPoint&gt;]
<span class="line-numbers"><a href="#n2" name="n2">2</a></span>let main argv =
<span class="line-numbers"><a href="#n3" name="n3">3</a></span>  let webpart = pathScan &quot;/api/profile/%s&quot; ApiGateway.getProfile
<span class="line-numbers"><a href="#n4" name="n4">4</a></span>  startWebServer defaultConfig webpart
<span class="line-numbers"><a href="#n5" name="n5">5</a></span>  0
</pre></div>
</div>
</div>

<p>Thanks to <code>Suave</code> for it’s lightweight and low-ceremony offerings in creating an API. We just exposed it in two lines!</p>

<p>Hit <code>F5</code> and access the API at <code>http://localhost:8083/api/profile/{github-username}</code> Bingo!!</p>

<h2 id="summary">Summary</h2>

<blockquote>
  <p>A language that doesn’t affect the way you think about programming is not worth knowing - Alan Perils</p>
</blockquote>

<p>The above quote summarizes the gist of this blog post. Functional Programming will help you think better. You can get the source code associated with the blog post in my <a href="https://github.com/tamizhvendan/blog-samples/tree/master/RxFsharp">blog-samples GitHub repository</a></p>

<p>Wish you a happy and prosperous new year</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Creating Mock API server in fsharp using Suave]]></title>
    <link href="http://blog.tamizhvendan.in/blog/2015/07/23/creating-mock-api-server-in-fsharp-using-suave/"/>
    <updated>2015-07-23T16:56:20+05:30</updated>
    <id>http://blog.tamizhvendan.in/blog/2015/07/23/creating-mock-api-server-in-fsharp-using-suave</id>
    <content type="html"><![CDATA[<p>As part of the current assignment in my day job, I am working in a web application which integrates with an another web application via web APIs. The backend calls the exposed web APIs and does some business logic. Due to some technical limitations, we are not able to setup a development environment of the Web APIs so we have decided to create a mock API server during the development and replace it with the real one in the production.</p>

<p>Since it’s just a mock API server, we don’t want to spend much time on it. Thanks to the awesome light-weight fsharp library <a href="http://suave.io/">Suave</a> we have made it in just 15 minutes!</p>

<p>In this blog post, I will be sharing how we have achieved it. As a sample, we will mock the <a href="https://developer.GitHub.com/v3/">GitHub API</a>.</p>

<h2 id="getting-started">Getting Started</h2>

<p>Create a new fsharp console application project “GitHubMockApiServer” in Visual Studio and install the <a href="https://www.nuget.org/packages/Suave/">suave</a> nuget package.</p>

<p>To keep it short we are going to mock only two GitHub APIs</p>

<ul>
  <li><a href="https://developer.GitHub.com/v3/users/#get-a-single-user">Get a single user</a> - <strong>/users/:username</strong></li>
  <li><a href="https://developer.GitHub.com/v3/repos/#list-user-repositories">List user repositories</a> - <strong>/users/:username/repos</strong></li>
</ul>

<h2 id="creating-the-mock-apis">Creating the mock APIs</h2>

<p>The first step is getting the sample response for these APIs and save them in separate JSON files. In this example, I’ve created these using my GitHub username and added to the project as below.</p>

<p><img class="center" src="/images/suave_mock_api/project.png"></p>

<p>After adding, change the “Copy to Output Directory” property of the both the files to “Copy always”</p>

<p>Open the <strong>Program.fs</strong> and update it as follows</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"> <a href="#n1" name="n1">1</a></span>open Suave
<span class="line-numbers"> <a href="#n2" name="n2">2</a></span>open Suave.Operators
<span class="line-numbers"> <a href="#n3" name="n3">3</a></span>open Suave.Successful
<span class="line-numbers"> <a href="#n4" name="n4">4</a></span>open Suave.Filters
<span class="line-numbers"> <a href="#n5" name="n5">5</a></span>open System.IO
<span class="line-numbers"> <a href="#n6" name="n6">6</a></span>
<span class="line-numbers"> <a href="#n7" name="n7">7</a></span>[&lt;EntryPoint&gt;]
<span class="line-numbers"> <a href="#n8" name="n8">8</a></span>let main argv =
<span class="line-numbers"> <a href="#n9" name="n9">9</a></span>  let json fileName =
<span class="line-numbers"><strong><a href="#n10" name="n10">10</a></strong></span>    let content = File.ReadAllText fileName  
<span class="line-numbers"><a href="#n11" name="n11">11</a></span>    content.Replace(&quot;\r&quot;, &quot;&quot;).Replace(&quot;\n&quot;,&quot;&quot;)
<span class="line-numbers"><a href="#n12" name="n12">12</a></span>    |&gt; OK &gt;=&gt; Writers.setMimeType &quot;application/json&quot;      
<span class="line-numbers"><a href="#n13" name="n13">13</a></span>
<span class="line-numbers"><a href="#n14" name="n14">14</a></span>  let user = pathScan &quot;/users/%s&quot; (fun _ -&gt; &quot;User.json&quot; |&gt; json)  
<span class="line-numbers"><a href="#n15" name="n15">15</a></span>  let repos = pathScan &quot;/users/%s/repos&quot; (fun _ -&gt; &quot;Repos.json&quot; |&gt; json)
<span class="line-numbers"><a href="#n16" name="n16">16</a></span>  let mockApi = choose [repos;user]
<span class="line-numbers"><a href="#n17" name="n17">17</a></span>
<span class="line-numbers"><a href="#n18" name="n18">18</a></span>  startWebServer defaultConfig mockApi          
<span class="line-numbers"><a href="#n19" name="n19">19</a></span>  0
</pre></div>
</div>
</div>

<p>Short and Sweet! Now you can hit this mock GitHub APIs without worrying about its <a href="https://developer.GitHub.com/v3/#rate-limiting">rate limits</a></p>

<p>The <code>json</code> function reads the sample JSON file, then removes the line breaks and return the HTTP 200 response with the content type as  “application/json”</p>

<p>The nice DSL in suave enabled us to configure the routes without giving much works to our hands :-)  </p>

<h2 id="mock-apis-in-action">Mock APIs in action</h2>

<p><img class="border center" src="/images/suave_mock_api/user_api.png"></p>

<p><img class="border center" src="/images/suave_mock_api/repos_api.png"></p>

<h2 id="summary">Summary</h2>

<p>This work is inspired by Scott Wlaschin’s blog post series on <a href="http://fsharpforfunandprofit.com/series/low-risk-ways-to-use-fsharp-at-work.html">Low-risk ways to use F# at work</a>. I am glad to find one more low-risk way to use F# at work and I believe it would help you in future. You can find the sample code in my <a href="https://github.com/tamizhvendan/blog-samples/tree/master/GithubMockApiServer">blog-samples GitHub repository</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Securing APIs in Suave using JSON Web Token]]></title>
    <link href="http://blog.tamizhvendan.in/blog/2015/07/15/securing-apis-in-suave-using-json-web-token/"/>
    <updated>2015-07-15T12:04:12+05:30</updated>
    <id>http://blog.tamizhvendan.in/blog/2015/07/15/securing-apis-in-suave-using-json-web-token</id>
    <content type="html"><![CDATA[<p>In the <a href="/blog/2015/06/11/building-rest-api-in-fsharp-using-suave/">last blog post</a>, we have seen how we can combine small functions to create a REST API in Suave and in this blog post we are going to see how can we secure the APIs using JSON web tokens(JWT).</p>

<p>This blog post is based on <a href="http://bitoftech.net/">Taiseer’s</a> blog post on <a href="http://bitoftech.net/2014/10/27/json-web-token-asp-net-web-api-2-jwt-owin-authorization-server/">JSON Web Token in ASP.NET Web API 2 using Owin</a> and I will be covering how to implement the same in <a href="http://suave.io">Suave</a>. If you are interested in the theoretical background of JWT, kindly read his blog post before reading this.</p>

<h2 id="workflow">Workflow</h2>

<p>The typical workflow of JWT based application would look like this</p>

<ol>
  <li>New Audience (Resource Server) gets registered with Authorization Server.</li>
  <li>Get the JWT access token from Authorization Server by passing Client Id of the resource server and login credentials</li>
  <li>Use the access token obtained above to get access to the secured resources in the resource server</li>
</ol>

<p>We are going to see how to implement all these three steps in this blog post</p>

<h2 id="project-setup">Project Setup</h2>

<p>Create an empty visual studio solution and add new projects with the following name</p>

<ul>
  <li>SuaveJwt - A fsharp library project which contains all the JWT related things</li>
  <li>SuaveJwt.AuthServerHost - A fsharp console application which is going to host the authorization server</li>
  <li>Audience1 - A fsharp console application representing the resource server 1   </li>
  <li>Audience2 - A fsharp console application representing the resource server 2   </li>
</ul>

<p>After creating, install the following NuGet packages</p>

<ul>
  <li><a href="https://www.nuget.org/packages/Suave/">Suave</a> in all the four projects</li>
  <li><a href="https://www.nuget.org/packages/Newtonsoft.Json/">Newtonsoft.Json</a> and <a href="https://www.nuget.org/packages/System.IdentityModel.Tokens.Jwt/">JSON Web Token Handler</a> in <em>SuaveJwt</em></li>
</ul>

<p>Then add reference the .NET framework library <strong>System.IdentityModel</strong> in all the four projects from GAC and then add a reference to the <strong>SuaveJwt</strong> project library in all the other three projects.</p>

<p><img class="center" src="/images/suave_jwt/project_structure.png"></p>

<h2 id="new-audience-registration">New Audience Registration</h2>

<p>As we have seen in the workflow, the first step is to enable an audience to register itself with the authorization server. Let’s begin by defining the business logic.</p>

<p>Add a new source file <em>JwtToken.fs</em> in the <strong>SuaveJwt</strong> project and update it as follows</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"> <a href="#n1" name="n1">1</a></span>type Audience = {
<span class="line-numbers"> <a href="#n2" name="n2">2</a></span>  ClientId : string
<span class="line-numbers"> <a href="#n3" name="n3">3</a></span>  Secret : Base64String
<span class="line-numbers"> <a href="#n4" name="n4">4</a></span>  Name : string
<span class="line-numbers"> <a href="#n5" name="n5">5</a></span>}
<span class="line-numbers"> <a href="#n6" name="n6">6</a></span>
<span class="line-numbers"> <a href="#n7" name="n7">7</a></span>// string -&gt; Audience
<span class="line-numbers"> <a href="#n8" name="n8">8</a></span>let createAudience audienceName =
<span class="line-numbers"> <a href="#n9" name="n9">9</a></span>  let clientId = Guid.NewGuid().ToString(&quot;N&quot;)
<span class="line-numbers"><strong><a href="#n10" name="n10">10</a></strong></span>  let data = Array.zeroCreate 32
<span class="line-numbers"><a href="#n11" name="n11">11</a></span>  RNGCryptoServiceProvider.Create().GetBytes(data)
<span class="line-numbers"><a href="#n12" name="n12">12</a></span>  let secret = data |&gt; Base64String.create
<span class="line-numbers"><a href="#n13" name="n13">13</a></span>  {ClientId = clientId; Secret = secret; Name =  audienceName}
</pre></div>
</div>
</div>

<p>The above snippet creates an audience record with a random client id and secret key. The secret key is of type <a href="https://en.wikipedia.org/wiki/Base64#URL_applications">base64 URL encoded</a> string. This type doesn’t exist, so let’s create it.</p>

<p>Add a new source file <em>Encodings.fs</em> in the <strong>SuaveJwt</strong> project and add this type</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"> <a href="#n1" name="n1">1</a></span>type Base64String = private Base64String of string with
<span class="line-numbers"> <a href="#n2" name="n2">2</a></span>
<span class="line-numbers"> <a href="#n3" name="n3">3</a></span>  static member decode (base64String : Base64String) =
<span class="line-numbers"> <a href="#n4" name="n4">4</a></span>    let (Base64String text) = base64String
<span class="line-numbers"> <a href="#n5" name="n5">5</a></span>    let pad text =
<span class="line-numbers"> <a href="#n6" name="n6">6</a></span>      let padding = 3 - ((String.length text + 3) % 4)
<span class="line-numbers"> <a href="#n7" name="n7">7</a></span>      if padding = 0 then text else (text + new String('=', padding))
<span class="line-numbers"> <a href="#n8" name="n8">8</a></span>
<span class="line-numbers"> <a href="#n9" name="n9">9</a></span>    Convert.FromBase64String(pad(text.Replace('-', '+').Replace('_', '/')))
<span class="line-numbers"><strong><a href="#n10" name="n10">10</a></strong></span>
<span class="line-numbers"><a href="#n11" name="n11">11</a></span>  static member create data =
<span class="line-numbers"><a href="#n12" name="n12">12</a></span>    Convert.ToBase64String(data)
<span class="line-numbers"><a href="#n13" name="n13">13</a></span>      .TrimEnd('=')
<span class="line-numbers"><a href="#n14" name="n14">14</a></span>      .Replace('+', '-')
<span class="line-numbers"><a href="#n15" name="n15">15</a></span>      .Replace('/', '_') |&gt; Base64String;
<span class="line-numbers"><a href="#n16" name="n16">16</a></span>
<span class="line-numbers"><a href="#n17" name="n17">17</a></span>
<span class="line-numbers"><a href="#n18" name="n18">18</a></span>  static member fromString = Base64String
<span class="line-numbers"><a href="#n19" name="n19">19</a></span>
<span class="line-numbers"><strong><a href="#n20" name="n20">20</a></strong></span>  override this.ToString() =
<span class="line-numbers"><a href="#n21" name="n21">21</a></span>    let (Base64String str) = this
<span class="line-numbers"><a href="#n22" name="n22">22</a></span>    str
</pre></div>
</div>
</div>

<p>To keep things simple, I haven’t added any validations here. The next step is to create a Suave <em>WebPart</em> to expose the audience create functionality.</p>

<p>Add a new source file <em>AuthServer.fs</em> in the <strong>SuaveJwt</strong> project and update it as below</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"> <a href="#n1" name="n1">1</a></span>type AudienceCreateRequest = {
<span class="line-numbers"> <a href="#n2" name="n2">2</a></span>  Name : string
<span class="line-numbers"> <a href="#n3" name="n3">3</a></span>}
<span class="line-numbers"> <a href="#n4" name="n4">4</a></span>
<span class="line-numbers"> <a href="#n5" name="n5">5</a></span>type AudienceCreateResponse = {
<span class="line-numbers"> <a href="#n6" name="n6">6</a></span>  ClientId : string
<span class="line-numbers"> <a href="#n7" name="n7">7</a></span>  Base64Secret : string
<span class="line-numbers"> <a href="#n8" name="n8">8</a></span>  Name : string
<span class="line-numbers"> <a href="#n9" name="n9">9</a></span>}
<span class="line-numbers"><strong><a href="#n10" name="n10">10</a></strong></span>
<span class="line-numbers"><a href="#n11" name="n11">11</a></span>type Config = {
<span class="line-numbers"><a href="#n12" name="n12">12</a></span>  AddAudienceUrlPath : string  
<span class="line-numbers"><a href="#n13" name="n13">13</a></span>  SaveAudience : Audience -&gt; Async&lt;Audience&gt;
<span class="line-numbers"><a href="#n14" name="n14">14</a></span>}
<span class="line-numbers"><a href="#n15" name="n15">15</a></span>
<span class="line-numbers"><a href="#n16" name="n16">16</a></span>let audienceWebPart config =
<span class="line-numbers"><a href="#n17" name="n17">17</a></span>
<span class="line-numbers"><a href="#n18" name="n18">18</a></span>  let toAudienceCreateResponse (audience : Audience) = {
<span class="line-numbers"><a href="#n19" name="n19">19</a></span>    Base64Secret = audience.Secret.ToString()
<span class="line-numbers"><strong><a href="#n20" name="n20">20</a></strong></span>    ClientId = audience.ClientId        
<span class="line-numbers"><a href="#n21" name="n21">21</a></span>    Name = audience.Name
<span class="line-numbers"><a href="#n22" name="n22">22</a></span>  }
<span class="line-numbers"><a href="#n23" name="n23">23</a></span>
<span class="line-numbers"><a href="#n24" name="n24">24</a></span>  let tryCreateAudience (ctx: HttpContext) =
<span class="line-numbers"><a href="#n25" name="n25">25</a></span>    match mapJsonPayload&lt;AudienceCreateRequest&gt; ctx.request with
<span class="line-numbers"><a href="#n26" name="n26">26</a></span>    | Some audienceCreateRequest -&gt;
<span class="line-numbers"><a href="#n27" name="n27">27</a></span>        async {
<span class="line-numbers"><a href="#n28" name="n28">28</a></span>          let! audience =
<span class="line-numbers"><a href="#n29" name="n29">29</a></span>            audienceCreateRequest.Name |&gt; createAudience |&gt; config.SaveAudience                     
<span class="line-numbers"><strong><a href="#n30" name="n30">30</a></strong></span>          let audienceCreateResponse = toAudienceCreateResponse audience
<span class="line-numbers"><a href="#n31" name="n31">31</a></span>          return! JSON audienceCreateResponse ctx
<span class="line-numbers"><a href="#n32" name="n32">32</a></span>        }
<span class="line-numbers"><a href="#n33" name="n33">33</a></span>    | None -&gt; BAD_REQUEST &quot;Invalid Audience Create Request&quot; ctx
<span class="line-numbers"><a href="#n34" name="n34">34</a></span>
<span class="line-numbers"><a href="#n35" name="n35">35</a></span>  path config.AddAudienceUrlPath &gt;=&gt; POST &gt;=&gt; tryCreateAudience
</pre></div>
</div>
</div>

<p>The <code>audienceWebPart</code> function retrieves the <code>AudienceCreateRequest</code> from the JSON request payload and creates a new audience.<br />
To make it independent of the host, we have externalized the hosting functionality using the <code>Config</code> record type.</p>

<p>The <code>mapJsonPayload</code> and <code>JSON</code> functions serialize and deserialize JSON objects across the wire respectively. These functions are not part of Suave, so let’s add them</p>

<p>Add a new source file <em>SuaveJson.fs</em> in the <strong>SuaveJwt</strong> project and add these functions</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"> <a href="#n1" name="n1">1</a></span>let JSON v =     
<span class="line-numbers"> <a href="#n2" name="n2">2</a></span>  let jsonSerializerSettings = new JsonSerializerSettings()
<span class="line-numbers"> <a href="#n3" name="n3">3</a></span>  jsonSerializerSettings.ContractResolver &lt;- new CamelCasePropertyNamesContractResolver()
<span class="line-numbers"> <a href="#n4" name="n4">4</a></span>
<span class="line-numbers"> <a href="#n5" name="n5">5</a></span>  JsonConvert.SerializeObject(v, jsonSerializerSettings)
<span class="line-numbers"> <a href="#n6" name="n6">6</a></span>  |&gt; OK
<span class="line-numbers"> <a href="#n7" name="n7">7</a></span>  &gt;=&gt; Writers.setMimeType &quot;application/json; charset=utf-8&quot;
<span class="line-numbers"> <a href="#n8" name="n8">8</a></span>
<span class="line-numbers"> <a href="#n9" name="n9">9</a></span>let mapJsonPayload&lt;'a&gt; (req : HttpRequest) =     
<span class="line-numbers"><strong><a href="#n10" name="n10">10</a></strong></span>  let fromJson json =
<span class="line-numbers"><a href="#n11" name="n11">11</a></span>    try
<span class="line-numbers"><a href="#n12" name="n12">12</a></span>      let obj = JsonConvert.DeserializeObject(json, typeof&lt;'a&gt;) :?&gt; 'a    
<span class="line-numbers"><a href="#n13" name="n13">13</a></span>      Some obj
<span class="line-numbers"><a href="#n14" name="n14">14</a></span>    with
<span class="line-numbers"><a href="#n15" name="n15">15</a></span>    | _ -&gt; None
<span class="line-numbers"><a href="#n16" name="n16">16</a></span>
<span class="line-numbers"><a href="#n17" name="n17">17</a></span>  let getString rawForm =
<span class="line-numbers"><a href="#n18" name="n18">18</a></span>    System.Text.Encoding.UTF8.GetString(rawForm)
<span class="line-numbers"><a href="#n19" name="n19">19</a></span>
<span class="line-numbers"><strong><a href="#n20" name="n20">20</a></strong></span>  req.rawForm |&gt; getString |&gt; fromJson
</pre></div>
</div>
</div>

<p>The next step is hosting this audience web part.</p>

<p>Open the <em>Program.fs</em> file in the <strong>SuaveJwt.AuthServerHost</strong> project and update it as below</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"><a href="#n1" name="n1">1</a></span>let authorizationServerConfig = {
<span class="line-numbers"><a href="#n2" name="n2">2</a></span>  AddAudienceUrlPath = &quot;/api/audience&quot;  
<span class="line-numbers"><a href="#n3" name="n3">3</a></span>  SaveAudience = AudienceStorage.saveAudience
<span class="line-numbers"><a href="#n4" name="n4">4</a></span>}
<span class="line-numbers"><a href="#n5" name="n5">5</a></span>let audienceWebPart' = audienceWebPart authorizationServerConfig
<span class="line-numbers"><a href="#n6" name="n6">6</a></span>startWebServer defaultConfig audienceWebPart'
<span class="line-numbers"><a href="#n7" name="n7">7</a></span>0 // return an integer exit code
</pre></div>
</div>
</div>

<p>It is a straight forward self-host suave server program which exposes the audience web part.</p>

<p>The <em>AudienceStorage</em> is responsible for storing the created audiences and to add it create a new source file <em>AudienceStorage.fs</em> in the <strong>SuaveJwt.AuthServerHost</strong> project and add these functions</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"><a href="#n1" name="n1">1</a></span>module AudienceStorage
<span class="line-numbers"><a href="#n2" name="n2">2</a></span>
<span class="line-numbers"><a href="#n3" name="n3">3</a></span>let private audienceStorage
<span class="line-numbers"><a href="#n4" name="n4">4</a></span>  = new Dictionary&lt;string, Audience&gt;()
<span class="line-numbers"><a href="#n5" name="n5">5</a></span>
<span class="line-numbers"><a href="#n6" name="n6">6</a></span>let saveAudience (audience : Audience) =      
<span class="line-numbers"><a href="#n7" name="n7">7</a></span>    audienceStorage.Add(audience.ClientId, audience)
<span class="line-numbers"><a href="#n8" name="n8">8</a></span>    audience |&gt; async.Return
</pre></div>
</div>
</div>
<p>To keep this simple, we are using in-memory dictionary here and it can be easily replaced with any data store</p>

<p>Now we have everything to create a new audience. So, let’s run the <strong>SuaveJwt.AuthServerHost</strong> application and verify</p>

<p><img class="center" src="/images/suave_jwt/audience_create.png"></p>

<p>Keep a note of this <em>clientId</em> and <em>base64Secret</em> as we will be using them while defining the resource server (“Audience1” in this case).</p>

<h2 id="generating-access-token">Generating Access Token</h2>

<p>After registering an audience with the authorization server, the next step is to get the access token to access the resources in the given resource server.</p>

<p>Let’s begin by defining the business logic to create an access token.</p>

<p><img class="center" src="/images/suave_jwt/createToken.png"></p>

<p>Open <em>JwtToken.fs</em> and add the following types</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"> <a href="#n1" name="n1">1</a></span>type TokenCreateRequest = {         
<span class="line-numbers"> <a href="#n2" name="n2">2</a></span>  Issuer : string        
<span class="line-numbers"> <a href="#n3" name="n3">3</a></span>  UserName : string
<span class="line-numbers"> <a href="#n4" name="n4">4</a></span>  Password : string        
<span class="line-numbers"> <a href="#n5" name="n5">5</a></span>  TokenTimeSpan : TimeSpan
<span class="line-numbers"> <a href="#n6" name="n6">6</a></span>}
<span class="line-numbers"> <a href="#n7" name="n7">7</a></span>
<span class="line-numbers"> <a href="#n8" name="n8">8</a></span>type IdentityStore = {
<span class="line-numbers"> <a href="#n9" name="n9">9</a></span>  getClaims : string -&gt; Async&lt;Claim seq&gt;
<span class="line-numbers"><strong><a href="#n10" name="n10">10</a></strong></span>  isValidCredentials : string -&gt; string -&gt; Async&lt;bool&gt;
<span class="line-numbers"><a href="#n11" name="n11">11</a></span>  getSecurityKey : Base64String -&gt; SecurityKey
<span class="line-numbers"><a href="#n12" name="n12">12</a></span>  getSigningCredentials : SecurityKey -&gt; SigningCredentials
<span class="line-numbers"><a href="#n13" name="n13">13</a></span>}
<span class="line-numbers"><a href="#n14" name="n14">14</a></span>
<span class="line-numbers"><a href="#n15" name="n15">15</a></span>type Token = {
<span class="line-numbers"><a href="#n16" name="n16">16</a></span>  AccessToken : string        
<span class="line-numbers"><a href="#n17" name="n17">17</a></span>  ExpiresIn : float        
<span class="line-numbers"><a href="#n18" name="n18">18</a></span>}
</pre></div>
</div>
</div>

<p>These types are generic abstractions which decouple the token creation part from the underlying host.</p>

<p>The <code>TokenCreateRequest</code> models the underlying issuer and token lifetime.</p>

<p>The <code>IdentityStore</code> represents a generic data store in which the identity information has been stored and it also provides the security key and the signing credentials to protect the access token from misuse.</p>

<p>With these types in place let’s add the <code>createToken</code> function in the <em>SuaveJwt.fs</em> file</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"> <a href="#n1" name="n1">1</a></span>let createToken tokenCreateRequest identityStore audience =
<span class="line-numbers"> <a href="#n2" name="n2">2</a></span>  async {
<span class="line-numbers"> <a href="#n3" name="n3">3</a></span>    let! isValidCredentials =
<span class="line-numbers"> <a href="#n4" name="n4">4</a></span>      identityStore.isValidCredentials tokenCreateRequest.UserName tokenCreateRequest.Password
<span class="line-numbers"> <a href="#n5" name="n5">5</a></span>    if isValidCredentials then                            
<span class="line-numbers"> <a href="#n6" name="n6">6</a></span>      let signingCredentials =
<span class="line-numbers"> <a href="#n7" name="n7">7</a></span>        (identityStore.getSecurityKey &gt;&gt; identityStore.getSigningCredentials) audience.Secret
<span class="line-numbers"> <a href="#n8" name="n8">8</a></span>      let issuedOn = Nullable DateTime.UtcNow
<span class="line-numbers"> <a href="#n9" name="n9">9</a></span>      let expiresBy = Nullable (DateTime.UtcNow.Add(tokenCreateRequest.TokenTimeSpan))       
<span class="line-numbers"><strong><a href="#n10" name="n10">10</a></strong></span>      let! claims =  identityStore.getClaims tokenCreateRequest.UserName
<span class="line-numbers"><a href="#n11" name="n11">11</a></span>      let jwtSecurityToken =
<span class="line-numbers"><a href="#n12" name="n12">12</a></span>        new JwtSecurityToken(tokenCreateRequest.Issuer, audience.ClientId, claims, issuedOn, expiresBy, signingCredentials)
<span class="line-numbers"><a href="#n13" name="n13">13</a></span>      let handler = new JwtSecurityTokenHandler()
<span class="line-numbers"><a href="#n14" name="n14">14</a></span>      let accessToken = handler.WriteToken(jwtSecurityToken)                
<span class="line-numbers"><a href="#n15" name="n15">15</a></span>      return Some {AccessToken = accessToken; ExpiresIn = tokenCreateRequest.TokenTimeSpan.TotalSeconds}
<span class="line-numbers"><a href="#n16" name="n16">16</a></span>    else return None
<span class="line-numbers"><a href="#n17" name="n17">17</a></span>  }
</pre></div>
</div>
</div>

<p>The <code>createToken</code> function checks the validness of the login credentials. If it is valid, then it get the claims associated with the given username and creates a <em>JwtToken</em> using the <a href="https://www.nuget.org/packages/System.IdentityModel.Tokens.Jwt/">JSON Web Token Handler</a> library, else it returns <code>None</code></p>

<p>Now we have got the backend business logic ready, let’s expose it as a suave <em>WebPart</em></p>

<p>Open <em>AuthServer.fs</em> and add a new record type for the incoming token create request and update <code>Config</code> and <code>audienceWebPart</code> as below</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"> <a href="#n1" name="n1">1</a></span>type TokenCreateCredentials = {
<span class="line-numbers"> <a href="#n2" name="n2">2</a></span>  UserName : string
<span class="line-numbers"> <a href="#n3" name="n3">3</a></span>  Password : string
<span class="line-numbers"> <a href="#n4" name="n4">4</a></span>  ClientId : string
<span class="line-numbers"> <a href="#n5" name="n5">5</a></span>}
<span class="line-numbers"> <a href="#n6" name="n6">6</a></span>
<span class="line-numbers"> <a href="#n7" name="n7">7</a></span>type Config = {
<span class="line-numbers"> <a href="#n8" name="n8">8</a></span>  // ... existing fields ...
<span class="line-numbers"> <a href="#n9" name="n9">9</a></span>  CreateTokenUrlPath : string  
<span class="line-numbers"><strong><a href="#n10" name="n10">10</a></strong></span>  GetAudience : string -&gt; Async&lt;Audience option&gt;
<span class="line-numbers"><a href="#n11" name="n11">11</a></span>  Issuer : string
<span class="line-numbers"><a href="#n12" name="n12">12</a></span>  TokenTimeSpan : TimeSpan
<span class="line-numbers"><a href="#n13" name="n13">13</a></span>}
<span class="line-numbers"><a href="#n14" name="n14">14</a></span>
<span class="line-numbers"><a href="#n15" name="n15">15</a></span>let audienceWebPart config identityStore =
<span class="line-numbers"><a href="#n16" name="n16">16</a></span>
<span class="line-numbers"><a href="#n17" name="n17">17</a></span>  // ... existing functions ...
<span class="line-numbers"><a href="#n18" name="n18">18</a></span>
<span class="line-numbers"><a href="#n19" name="n19">19</a></span>  let tryCreateToken (ctx: HttpContext) =
<span class="line-numbers"><strong><a href="#n20" name="n20">20</a></strong></span>    match mapJsonPayload&lt;TokenCreateCredentials&gt; ctx.request with
<span class="line-numbers"><a href="#n21" name="n21">21</a></span>    | Some tokenCreateCredentials -&gt;
<span class="line-numbers"><a href="#n22" name="n22">22</a></span>      async {
<span class="line-numbers"><a href="#n23" name="n23">23</a></span>        let! audience = config.GetAudience tokenCreateCredentials.ClientId
<span class="line-numbers"><a href="#n24" name="n24">24</a></span>        match audience with
<span class="line-numbers"><a href="#n25" name="n25">25</a></span>        | Some audience -&gt;
<span class="line-numbers"><a href="#n26" name="n26">26</a></span>            let tokenCreateRequest : TokenCreateRequest = {         
<span class="line-numbers"><a href="#n27" name="n27">27</a></span>              Issuer = config.Issuer        
<span class="line-numbers"><a href="#n28" name="n28">28</a></span>              UserName = tokenCreateCredentials.UserName
<span class="line-numbers"><a href="#n29" name="n29">29</a></span>              Password = tokenCreateCredentials.Password        
<span class="line-numbers"><strong><a href="#n30" name="n30">30</a></strong></span>              TokenTimeSpan = config.TokenTimeSpan
<span class="line-numbers"><a href="#n31" name="n31">31</a></span>            }            
<span class="line-numbers"><a href="#n32" name="n32">32</a></span>            let! token = createToken tokenCreateRequest identityStore audience
<span class="line-numbers"><a href="#n33" name="n33">33</a></span>            match token with
<span class="line-numbers"><a href="#n34" name="n34">34</a></span>            | Some token -&gt; return! JSON token ctx
<span class="line-numbers"><a href="#n35" name="n35">35</a></span>            | None -&gt; return! BAD_REQUEST &quot;Invalid Login Credentials&quot; ctx
<span class="line-numbers"><a href="#n36" name="n36">36</a></span>
<span class="line-numbers"><a href="#n37" name="n37">37</a></span>        | None -&gt; return! BAD_REQUEST &quot;Invalid Client Id&quot; ctx
<span class="line-numbers"><a href="#n38" name="n38">38</a></span>      }    
<span class="line-numbers"><a href="#n39" name="n39">39</a></span>    | None -&gt; BAD_REQUEST &quot;Invalid Token Create Request&quot; ctx
<span class="line-numbers"><strong><a href="#n40" name="n40">40</a></strong></span>
<span class="line-numbers"><a href="#n41" name="n41">41</a></span>  choose [
<span class="line-numbers"><a href="#n42" name="n42">42</a></span>    path config.AddAudienceUrlPath &gt;=&gt; POST &gt;=&gt; tryCreateAudience
<span class="line-numbers"><a href="#n43" name="n43">43</a></span>    path config.CreateTokenUrlPath &gt;=&gt; POST &gt;=&gt; tryCreateToken
<span class="line-numbers"><a href="#n44" name="n44">44</a></span>  ]
</pre></div>
</div>
</div>

<p>The <code>tryCreateToken</code> function checks whether the <code>ClientId</code> is a registered audience or not, if it exists, then this function creates a token using the <code>createToken</code> function defined above otherwise it returns the <code>BAD_REQUST</code> <em>WebPart</em> with the appropriate error message.</p>

<p>The final change is modifying the <em>Program.fs</em> and <em>AudienceStorage.fs</em> files in the <strong>SuaveJwt.AuthServerHost</strong> to expose this <em>WebPart</em>.</p>

<p><strong>Program.fs</strong></p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"> <a href="#n1" name="n1">1</a></span>let authorizationServerConfig = {
<span class="line-numbers"> <a href="#n2" name="n2">2</a></span>  AddAudienceUrlPath = &quot;/api/audience&quot;
<span class="line-numbers"> <a href="#n3" name="n3">3</a></span>  CreateTokenUrlPath = &quot;/oauth2/token&quot;
<span class="line-numbers"> <a href="#n4" name="n4">4</a></span>  SaveAudience = AudienceStorage.saveAudience
<span class="line-numbers"> <a href="#n5" name="n5">5</a></span>  GetAudience = AudienceStorage.getAudience
<span class="line-numbers"> <a href="#n6" name="n6">6</a></span>  Issuer = &quot;http://localhost:8083/suave&quot;
<span class="line-numbers"> <a href="#n7" name="n7">7</a></span>  TokenTimeSpan = TimeSpan.FromMinutes(1.)
<span class="line-numbers"> <a href="#n8" name="n8">8</a></span>}
<span class="line-numbers"> <a href="#n9" name="n9">9</a></span>
<span class="line-numbers"><strong><a href="#n10" name="n10">10</a></strong></span>let identityStore = {
<span class="line-numbers"><a href="#n11" name="n11">11</a></span>  getClaims = IdentityStore.getClaims
<span class="line-numbers"><a href="#n12" name="n12">12</a></span>  isValidCredentials = IdentityStore.isValidCredentials
<span class="line-numbers"><a href="#n13" name="n13">13</a></span>  getSecurityKey = KeyStore.securityKey
<span class="line-numbers"><a href="#n14" name="n14">14</a></span>  getSigningCredentials = KeyStore.hmacSha256
<span class="line-numbers"><a href="#n15" name="n15">15</a></span>}    
<span class="line-numbers"><a href="#n16" name="n16">16</a></span>
<span class="line-numbers"><a href="#n17" name="n17">17</a></span>let audienceWebPart' = audienceWebPart authorizationServerConfig identityStore   
<span class="line-numbers"><a href="#n18" name="n18">18</a></span>
<span class="line-numbers"><a href="#n19" name="n19">19</a></span>startWebServer defaultConfig audienceWebPart'
</pre></div>
</div>
</div>

<p><strong>AudienceStorage.fs</strong></p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"><a href="#n1" name="n1">1</a></span>let getAudience clientId =        
<span class="line-numbers"><a href="#n2" name="n2">2</a></span>  if audienceStorage.ContainsKey(clientId) then
<span class="line-numbers"><a href="#n3" name="n3">3</a></span>    Some audienceStorage.[clientId] |&gt; async.Return
<span class="line-numbers"><a href="#n4" name="n4">4</a></span>  else
<span class="line-numbers"><a href="#n5" name="n5">5</a></span>    None |&gt; async.Return
</pre></div>
</div>
</div>

<p>The <em>KeyStore</em> and <em>IdentityStore</em> do not exists, so let’s add them</p>

<p>Add <em>KeyStore.fs</em> in the <strong>SuaveJwt</strong> project and it provide the in-memory symmetric security key based on <a href="https://en.wikipedia.org/wiki/Hash-based_message_authentication_code">HMAC</a></p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"> <a href="#n1" name="n1">1</a></span>module KeyStore
<span class="line-numbers"> <a href="#n2" name="n2">2</a></span>open System.IdentityModel.Tokens
<span class="line-numbers"> <a href="#n3" name="n3">3</a></span>open Encodings
<span class="line-numbers"> <a href="#n4" name="n4">4</a></span>
<span class="line-numbers"> <a href="#n5" name="n5">5</a></span>let securityKey sharedKey : SecurityKey =
<span class="line-numbers"> <a href="#n6" name="n6">6</a></span>  let symmetricKey = sharedKey |&gt; Base64String.decode
<span class="line-numbers"> <a href="#n7" name="n7">7</a></span>  new InMemorySymmetricSecurityKey(symmetricKey) :&gt; SecurityKey
<span class="line-numbers"> <a href="#n8" name="n8">8</a></span>
<span class="line-numbers"> <a href="#n9" name="n9">9</a></span>let hmacSha256 secretKey =
<span class="line-numbers"><strong><a href="#n10" name="n10">10</a></strong></span>  new SigningCredentials(secretKey,SecurityAlgorithms.HmacSha256Signature, SecurityAlgorithms.Sha256Digest)
</pre></div>
</div>
</div>

<p>Then add <em>IdentityStore.fs</em> in the <strong>SuaveJwt.AuthServerHost</strong> project.</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"> <a href="#n1" name="n1">1</a></span>module IdentityStore
<span class="line-numbers"> <a href="#n2" name="n2">2</a></span>open System.Security.Claims       
<span class="line-numbers"> <a href="#n3" name="n3">3</a></span>
<span class="line-numbers"> <a href="#n4" name="n4">4</a></span>let getClaims userName =
<span class="line-numbers"> <a href="#n5" name="n5">5</a></span>  seq {
<span class="line-numbers"> <a href="#n6" name="n6">6</a></span>    yield (ClaimTypes.Name, userName)
<span class="line-numbers"> <a href="#n7" name="n7">7</a></span>    if (userName = &quot;Admin&quot;) then
<span class="line-numbers"> <a href="#n8" name="n8">8</a></span>      yield (ClaimTypes.Role, &quot;Admin&quot;)
<span class="line-numbers"> <a href="#n9" name="n9">9</a></span>    if (userName = &quot;Foo&quot;) then
<span class="line-numbers"><strong><a href="#n10" name="n10">10</a></strong></span>      yield (ClaimTypes.Role, &quot;SuperUser&quot;)            
<span class="line-numbers"><a href="#n11" name="n11">11</a></span>  } |&gt; Seq.map (fun x -&gt; new Claim(fst x, snd x)) |&gt; async.Return
<span class="line-numbers"><a href="#n12" name="n12">12</a></span>
<span class="line-numbers"><a href="#n13" name="n13">13</a></span>let isValidCredentials username password =
<span class="line-numbers"><a href="#n14" name="n14">14</a></span>  username = password |&gt; async.Return
</pre></div>
</div>
</div>

<p>To keep this simple, I am just hardcoding the credentials and claims here and it can be replaced with any backend. In this case, I am just going with accepting all the credentials as valid if the username and password are same.</p>

<p>Let’s run the <strong>SuaveJwt.AuthServerHost</strong> and verify the token</p>

<p><img class="center" src="/images/suave_jwt/audience_admin_token.png"></p>

<h2 id="securing-the-resources">Securing the resources</h2>

<p>Now we have come to the interesting part of securing the resources using the <em>access token</em> created in the above step</p>

<p>The first step to achieving this to validate the incoming access token. Let’s add this validation logic in the <em>JwtToken.fs</em> file.</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"> <a href="#n1" name="n1">1</a></span>type TokenValidationRequest = {
<span class="line-numbers"> <a href="#n2" name="n2">2</a></span>  Issuer : string
<span class="line-numbers"> <a href="#n3" name="n3">3</a></span>  SecurityKey : SecurityKey
<span class="line-numbers"> <a href="#n4" name="n4">4</a></span>  ClientId : string
<span class="line-numbers"> <a href="#n5" name="n5">5</a></span>  AccessToken : string
<span class="line-numbers"> <a href="#n6" name="n6">6</a></span>}
<span class="line-numbers"> <a href="#n7" name="n7">7</a></span>
<span class="line-numbers"> <a href="#n8" name="n8">8</a></span>let validate tokenValidationRequest =
<span class="line-numbers"> <a href="#n9" name="n9">9</a></span>  let tokenValidationParameters =
<span class="line-numbers"><strong><a href="#n10" name="n10">10</a></strong></span>    let validationParams = new TokenValidationParameters()
<span class="line-numbers"><a href="#n11" name="n11">11</a></span>    validationParams.ValidAudience &lt;- tokenValidationRequest.ClientId
<span class="line-numbers"><a href="#n12" name="n12">12</a></span>    validationParams.ValidIssuer &lt;- tokenValidationRequest.Issuer
<span class="line-numbers"><a href="#n13" name="n13">13</a></span>    validationParams.ValidateLifetime &lt;- true
<span class="line-numbers"><a href="#n14" name="n14">14</a></span>    validationParams.ValidateIssuerSigningKey &lt;- true
<span class="line-numbers"><a href="#n15" name="n15">15</a></span>    validationParams.IssuerSigningKey &lt;-  tokenValidationRequest.SecurityKey
<span class="line-numbers"><a href="#n16" name="n16">16</a></span>    validationParams
<span class="line-numbers"><a href="#n17" name="n17">17</a></span>  try
<span class="line-numbers"><a href="#n18" name="n18">18</a></span>    let handler = new JwtSecurityTokenHandler()
<span class="line-numbers"><a href="#n19" name="n19">19</a></span>    let principal =
<span class="line-numbers"><strong><a href="#n20" name="n20">20</a></strong></span>      handler.ValidateToken(tokenValidationRequest.AccessToken, tokenValidationParameters, ref null)
<span class="line-numbers"><a href="#n21" name="n21">21</a></span>    principal.Claims |&gt; Choice1Of2
<span class="line-numbers"><a href="#n22" name="n22">22</a></span>  with
<span class="line-numbers"><a href="#n23" name="n23">23</a></span>    | ex -&gt; ex.Message |&gt; Choice2Of2
</pre></div>
</div>
</div>

<p>The <code>validate</code> function returns a <code>Choice</code> type which contains either a sequence of <a href="https://msdn.microsoft.com/en-us/library/system.security.claims(v=vs.110).aspx">Claims</a> present in the token if the access token is valid or an error message describing what’s wrong with the access token</p>

<p>The next step is using this function to secure a Suave <em>WebPart</em></p>

<p>Create a new source file <em>Secure.fs</em> in the <strong>SuaveJwt</strong> project and add the following code</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"> <a href="#n1" name="n1">1</a></span>type JwtConfig = {
<span class="line-numbers"> <a href="#n2" name="n2">2</a></span>    Issuer : string    
<span class="line-numbers"> <a href="#n3" name="n3">3</a></span>    SecurityKey : SecurityKey
<span class="line-numbers"> <a href="#n4" name="n4">4</a></span>    ClientId : string    
<span class="line-numbers"> <a href="#n5" name="n5">5</a></span>}
<span class="line-numbers"> <a href="#n6" name="n6">6</a></span>
<span class="line-numbers"> <a href="#n7" name="n7">7</a></span>let jwtAuthenticate jwtConfig webpart (ctx: HttpContext) =
<span class="line-numbers"> <a href="#n8" name="n8">8</a></span>
<span class="line-numbers"> <a href="#n9" name="n9">9</a></span>  let updateContextWithClaims claims =
<span class="line-numbers"><strong><a href="#n10" name="n10">10</a></strong></span>    { ctx with userState = ctx.userState.Remove(&quot;Claims&quot;).Add(&quot;Claims&quot;, claims) }    
<span class="line-numbers"><a href="#n11" name="n11">11</a></span>
<span class="line-numbers"><a href="#n12" name="n12">12</a></span>  match ctx.request.header &quot;token&quot; with
<span class="line-numbers"><a href="#n13" name="n13">13</a></span>  | Choice1Of2 accessToken -&gt;
<span class="line-numbers"><a href="#n14" name="n14">14</a></span>      let tokenValidationRequest =  {
<span class="line-numbers"><a href="#n15" name="n15">15</a></span>        Issuer = jwtConfig.Issuer
<span class="line-numbers"><a href="#n16" name="n16">16</a></span>        SecurityKey = jwtConfig.SecurityKey
<span class="line-numbers"><a href="#n17" name="n17">17</a></span>        ClientId = jwtConfig.ClientId
<span class="line-numbers"><a href="#n18" name="n18">18</a></span>        AccessToken = accessToken
<span class="line-numbers"><a href="#n19" name="n19">19</a></span>      }
<span class="line-numbers"><strong><a href="#n20" name="n20">20</a></strong></span>      let validationResult = validate tokenValidationRequest
<span class="line-numbers"><a href="#n21" name="n21">21</a></span>      match validationResult with
<span class="line-numbers"><a href="#n22" name="n22">22</a></span>      | Choice1Of2 claims -&gt; webpart (updateContextWithClaims claims)
<span class="line-numbers"><a href="#n23" name="n23">23</a></span>      | Choice2Of2 err -&gt; FORBIDDEN err ctx                         
<span class="line-numbers"><a href="#n24" name="n24">24</a></span>
<span class="line-numbers"><a href="#n25" name="n25">25</a></span>  | _ -&gt; BAD_REQUEST &quot;Invalid Request. Provide both clientid and token&quot; ctx  
</pre></div>
</div>
</div>

<p>The <code>jwtAuthenticate</code> function validates the access token present in the request header and invokes the given <em>WebPart</em> if it is valid. In case of invalid or absence of access token, it returns an HTTP error response instead of executing the <em>WebPart</em>.</p>

<p>Upon successful access token validation, the <code>jwtAuthenticate</code> function puts the claims in the <code>userState</code> map of incoming <code>HttpContext</code> so that subsequent <em>WebPart</em>s in the pipeline can use it.</p>

<p>The <code>JwtConfig</code> record abstracts the underlying audience from the validation logic so that it can be reused across multiple audiences.</p>

<p>Now we have a functionality secure a web part. Let’s create an audience and leverage this</p>

<p>Update the <em>Program.fs</em> file in the <strong>Audience1</strong> project as mentioned below</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"> <a href="#n1" name="n1">1</a></span>[&lt;EntryPoint&gt;]
<span class="line-numbers"> <a href="#n2" name="n2">2</a></span>let main argv =
<span class="line-numbers"> <a href="#n3" name="n3">3</a></span>
<span class="line-numbers"> <a href="#n4" name="n4">4</a></span>  let jwtConfig = {
<span class="line-numbers"> <a href="#n5" name="n5">5</a></span>    Issuer = &quot;http://localhost:8083/suave&quot;
<span class="line-numbers"> <a href="#n6" name="n6">6</a></span>    ClientId = &quot;7ff79ba3305c4e4f9d0ececeae70c78f&quot;
<span class="line-numbers"> <a href="#n7" name="n7">7</a></span>    SecurityKey = KeyStore.securityKey (Base64String.fromString &quot;Op5EqjC70aLS2dx3gI0zADPIZGX2As6UEwjA4oyBjMo&quot;)       
<span class="line-numbers"> <a href="#n8" name="n8">8</a></span>  }
<span class="line-numbers"> <a href="#n9" name="n9">9</a></span>
<span class="line-numbers"><strong><a href="#n10" name="n10">10</a></strong></span>  let sample1 = path &quot;/audience1/sample1&quot; &gt;=&gt; jwtAuthenticate jwtConfig (OK &quot;Sample 1&quot;)
<span class="line-numbers"><a href="#n11" name="n11">11</a></span>  let config = { defaultConfig with bindings = [HttpBinding.mkSimple HTTP &quot;127.0.0.1&quot; 8084] }
<span class="line-numbers"><a href="#n12" name="n12">12</a></span>
<span class="line-numbers"><a href="#n13" name="n13">13</a></span>  startWebServer config sample1
<span class="line-numbers"><a href="#n14" name="n14">14</a></span>  0
</pre></div>
</div>
</div>

<p>I’ve asked you to keep a note of the <em>clientId</em> and the <em>securityKey</em> while doing the registration of <strong>Audience1</strong>. We are using them here in the <code>jwtConfig</code> record.</p>

<p>Let’s see it in action</p>

<p><img class="center" src="/images/suave_jwt/audience_sample1_success.png"></p>

<p>Hurray! We have made it. “/audience1/sample1” is a secured API now!</p>

<p>What will happen if we mess with the access token? Well, we will get an HTTP error. Let’s change the character <code>Q</code> in the access token from upper case to lower case and here is the result of it.</p>

<p><img class="center" src="/images/suave_jwt/audience_sample1_error.png"></p>

<p>Cool, Isn’t it?</p>

<p>Let’s add authorization based on the claims that we have obtained from the JWT token</p>

<p>Open <em>Secure.fs</em> and update the authorization functionality</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"> <a href="#n1" name="n1">1</a></span>type AuthorizationResult =
<span class="line-numbers"> <a href="#n2" name="n2">2</a></span>  | Authorized
<span class="line-numbers"> <a href="#n3" name="n3">3</a></span>  | UnAuthorized of string
<span class="line-numbers"> <a href="#n4" name="n4">4</a></span>
<span class="line-numbers"> <a href="#n5" name="n5">5</a></span>let jwtAuthorize jwtConfig authorizeUser webpart  =
<span class="line-numbers"> <a href="#n6" name="n6">6</a></span>
<span class="line-numbers"> <a href="#n7" name="n7">7</a></span>  let getClaims (ctx: HttpContext) =
<span class="line-numbers"> <a href="#n8" name="n8">8</a></span>    let userState = ctx.userState
<span class="line-numbers"> <a href="#n9" name="n9">9</a></span>    if userState.ContainsKey(&quot;Claims&quot;) then
<span class="line-numbers"><strong><a href="#n10" name="n10">10</a></strong></span>      match userState.Item &quot;Claims&quot; with
<span class="line-numbers"><a href="#n11" name="n11">11</a></span>      | :? (Claim seq) as claims -&gt; Some claims             
<span class="line-numbers"><a href="#n12" name="n12">12</a></span>      | _ -&gt; None
<span class="line-numbers"><a href="#n13" name="n13">13</a></span>    else
<span class="line-numbers"><a href="#n14" name="n14">14</a></span>        None
<span class="line-numbers"><a href="#n15" name="n15">15</a></span>
<span class="line-numbers"><a href="#n16" name="n16">16</a></span>  let authorize httpContext =
<span class="line-numbers"><a href="#n17" name="n17">17</a></span>    match getClaims httpContext with
<span class="line-numbers"><a href="#n18" name="n18">18</a></span>    | Some claims -&gt;
<span class="line-numbers"><a href="#n19" name="n19">19</a></span>        async {
<span class="line-numbers"><strong><a href="#n20" name="n20">20</a></strong></span>          let! authorizationResult = authorizeUser claims          
<span class="line-numbers"><a href="#n21" name="n21">21</a></span>          match authorizationResult with
<span class="line-numbers"><a href="#n22" name="n22">22</a></span>          | Authorized -&gt; return! webpart httpContext
<span class="line-numbers"><a href="#n23" name="n23">23</a></span>          | UnAuthorized err -&gt; return! FORBIDDEN err httpContext
<span class="line-numbers"><a href="#n24" name="n24">24</a></span>        }
<span class="line-numbers"><a href="#n25" name="n25">25</a></span>    | None -&gt; FORBIDDEN &quot;Claims not found&quot; httpContext
<span class="line-numbers"><a href="#n26" name="n26">26</a></span>
<span class="line-numbers"><a href="#n27" name="n27">27</a></span>  jwtAuthenticate jwtConfig authorize
</pre></div>
</div>
</div>

<p>The <code>jwtConfig</code> function is very similar to the <code>jwtAuthenticate</code> function which provides authorization in addition to the authentication.</p>

<p>The key here is the parameter <code>authorizeUser</code> which is a function that takes a sequence of claims and returns an <code>AuthorizationResult</code>.</p>

<p>Like <code>jwtAuthenticate`` function, the</code>jwtConfig``` function is also abstracted from the underlying <em>Audience</em> so we can use it across multiple <em>Audience</em>s.</p>

<p>Let’s use this in the <strong>Audience1</strong>.</p>

<p><strong>Program.fs</strong></p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"> <a href="#n1" name="n1">1</a></span>[&lt;EntryPoint&gt;]
<span class="line-numbers"> <a href="#n2" name="n2">2</a></span>let main argv =
<span class="line-numbers"> <a href="#n3" name="n3">3</a></span>
<span class="line-numbers"> <a href="#n4" name="n4">4</a></span>  // ... existing code ...
<span class="line-numbers"> <a href="#n5" name="n5">5</a></span>
<span class="line-numbers"> <a href="#n6" name="n6">6</a></span>  // Claim Seq -&gt; Async&lt;AuthorizationResult&gt;
<span class="line-numbers"> <a href="#n7" name="n7">7</a></span>  let authorizeAdmin (claims : Claim seq) =
<span class="line-numbers"> <a href="#n8" name="n8">8</a></span>    match claims |&gt; Seq.tryFind (fun c -&gt; c.Type = ClaimTypes.Role &amp;&amp; c.Value = &quot;Admin&quot;) with
<span class="line-numbers"> <a href="#n9" name="n9">9</a></span>    | Some _ -&gt; Authorized |&gt; async.Return
<span class="line-numbers"><strong><a href="#n10" name="n10">10</a></strong></span>    | None -&gt; UnAuthorized &quot;User is not an admin&quot; |&gt; async.Return
<span class="line-numbers"><a href="#n11" name="n11">11</a></span>
<span class="line-numbers"><a href="#n12" name="n12">12</a></span>  let sample2 = path &quot;/audience1/sample2&quot; &gt;=&gt; jwtAuthorize jwtConfig authorizeAdmin (OK &quot;Sample 2&quot;)
<span class="line-numbers"><a href="#n13" name="n13">13</a></span>  let app = choose [sample1;sample2]
<span class="line-numbers"><a href="#n14" name="n14">14</a></span>
<span class="line-numbers"><a href="#n15" name="n15">15</a></span>  startWebServer config app
<span class="line-numbers"><a href="#n16" name="n16">16</a></span>  0  
</pre></div>
</div>
</div>

<p>The <code>jwtAuthroize</code> function in action</p>

<p><img class="center" src="/images/suave_jwt/audience1_sample2_error.png"></p>

<p><em>Note: I’ve generated a new access token here to exercise this use case.</em></p>

<p>That’s it we have successfully completed all the three steps mentioned at the beginning of this blog post.</p>

<h2 id="a-supplement">A Supplement</h2>

<p>One cool thing about the design of the <strong>SuaveJwt</strong> library is, it doesn’t have any assumption about the <em>Authorization Server</em> and the <em>Resource Server</em>. Because of it, we can easily extend it.</p>

<p>Let’s prove it by updating the <em>Program.fs</em> file in the <strong>Audience2</strong> project.</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"> <a href="#n1" name="n1">1</a></span>[&lt;EntryPoint&gt;]
<span class="line-numbers"> <a href="#n2" name="n2">2</a></span>let main argv =
<span class="line-numbers"> <a href="#n3" name="n3">3</a></span>  let jwtConfig = {
<span class="line-numbers"> <a href="#n4" name="n4">4</a></span>    Issuer = &quot;http://localhost:8083/suave&quot;
<span class="line-numbers"> <a href="#n5" name="n5">5</a></span>    ClientId = &quot;ada9263885c440869fb484fe354de13d&quot;
<span class="line-numbers"> <a href="#n6" name="n6">6</a></span>    SecurityKey = KeyStore.securityKey (Base64String.fromString &quot;0RWyzyttDmJtiaYkG9rph5cqxCTI8YAOsR7stq-P_5o&quot;)       
<span class="line-numbers"> <a href="#n7" name="n7">7</a></span>  }
<span class="line-numbers"> <a href="#n8" name="n8">8</a></span>
<span class="line-numbers"> <a href="#n9" name="n9">9</a></span>  let authorizeSuperUser (claims : Claim seq) =
<span class="line-numbers"><strong><a href="#n10" name="n10">10</a></strong></span>    match claims |&gt; Seq.tryFind (fun c -&gt; c.Type = ClaimTypes.Role &amp;&amp; c.Value = &quot;SuperUser&quot;) with
<span class="line-numbers"><a href="#n11" name="n11">11</a></span>    | Some _ -&gt; Authorized |&gt; async.Return
<span class="line-numbers"><a href="#n12" name="n12">12</a></span>    | None -&gt; UnAuthorized &quot;User is not a Super User&quot; |&gt; async.Return
<span class="line-numbers"><a href="#n13" name="n13">13</a></span>
<span class="line-numbers"><a href="#n14" name="n14">14</a></span>  let authorize = jwtAuthorize jwtConfig
<span class="line-numbers"><a href="#n15" name="n15">15</a></span>  let sample1 = path &quot;/audience2/sample1&quot; &gt;=&gt; OK &quot;Sample 1&quot;
<span class="line-numbers"><a href="#n16" name="n16">16</a></span>  let sample2 = path &quot;/audience2/sample2&quot; &gt;=&gt; authorize authorizeSuperUser (OK &quot;Sample 2&quot;)      
<span class="line-numbers"><a href="#n17" name="n17">17</a></span>  let config = { defaultConfig with bindings = [HttpBinding.mkSimple HTTP &quot;127.0.0.1&quot; 8085] }    
<span class="line-numbers"><a href="#n18" name="n18">18</a></span>  let app = choose [sample1;sample2]
<span class="line-numbers"><a href="#n19" name="n19">19</a></span>
<span class="line-numbers"><strong><a href="#n20" name="n20">20</a></strong></span>  startWebServer config app
<span class="line-numbers"><a href="#n21" name="n21">21</a></span>  0
</pre></div>
</div>
</div>

<p>Note that the <code>jwtConfig</code> values are different from that of <strong>Audience1</strong> and it is obtained from calling the <strong>AuthorizationServer</strong>’s audience registration API for <strong>Audience2</strong>.</p>

<h2 id="summary">Summary</h2>

<p>Suave provides a simple and elegant way of extending its core functionality. In this blog post, we have seen how to bend it to support JWT based authorization and I believe we can do a lot of other cool things too!</p>

<p>You can find the complete source code of the sample application used in this blog post in my <a href="https://github.com/tamizhvendan/blog-samples/tree/master/SuaveJwtSampleApplication">blog-samples</a> GitHub repository.    </p>
]]></content>
  </entry>
  
</feed>
