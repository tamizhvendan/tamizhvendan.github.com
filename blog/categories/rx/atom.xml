<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: rx | P3 Programmer]]></title>
  <link href="http://blog.tamizhvendan.in/blog/categories/rx/atom.xml" rel="self"/>
  <link href="http://blog.tamizhvendan.in/"/>
  <updated>2016-07-01T15:39:35+05:30</updated>
  <id>http://blog.tamizhvendan.in/</id>
  <author>
    <name><![CDATA[Tamizhvendan S]]></name>
    <email><![CDATA[tamizh88@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Implementing API Gateway in F# using Rx and Suave]]></title>
    <link href="http://blog.tamizhvendan.in/blog/2015/12/29/implementing-api-gateway-in-f-number-using-rx-and-suave/"/>
    <updated>2015-12-29T09:22:49+05:30</updated>
    <id>http://blog.tamizhvendan.in/blog/2015/12/29/implementing-api-gateway-in-f-number-using-rx-and-suave</id>
    <content type="html"><![CDATA[<p>One of the impressive aspects of functional programming is that it will enable you to write simple and expressive code to solve  complex problems. If you are wondering, how is it possible? Well, It is because, Functional Programming provides a lot of higher level abstractions to solve the problem in hand and avoids the need of writing lot of boilerplate &amp; plumbing code. As a developer, you will be more productive and deliver the solution faster.</p>

<p>In this blog post, we are going to see the application of the above statements by implementing an <a href="https://www.nginx.com/blog/building-microservices-using-an-api-gateway">API Gateway Pattern</a> in F# using <a href="http://reactivex.io/">Rx</a> and <a href="https://suave.io/">Suave</a>.  </p>

<blockquote>
  <p>This blog post is my contribution towards <a href="https://sergeytihon.wordpress.com/2015/10/25/f-advent-calendar-in-english-2015/">fsharp advent calendar 2015</a>. Do check out other great fsharp posts there</p>
</blockquote>

<h2 id="api-gateway-pattern">API Gateway Pattern</h2>
<p>Let’s assume that you are asked to build the backend for the below GitHub user profile screen.</p>

<p><img src="http://res.cloudinary.com/tamizhvendan/image/upload/v1450769741/Profile.png" alt="Github Profile" /></p>

<p>This profile screen has 3 components</p>

<ol>
  <li>
    <p>User - Username and Avatar</p>
  </li>
  <li>
    <p>Popular Repos - Top 3 Repos of the Given User (determined by the number of stars)</p>
  </li>
  <li>
    <p>Languages being used in the corresponding repos</p>
  </li>
</ol>

<p>Now as a developer, you have two options</p>

<ul>
  <li>
    <p>Build the Profile completely in client side by calling their corresponding GitHub APIs
<img src="http://res.cloudinary.com/tamizhvendan/image/upload/v1450769816/Profile_With_API_Calls.png" alt="Profile with URLs" /></p>

    <p>This approach makes the client side complex as it involves five HTTP requests to create the complete profile screen. It has a lot of drawbacks as mentioned in <a href="http://techblog.netflix.com/2013/01/optimizing-netflix-api.html">this blog post</a> by Netflix.</p>
  </li>
  <li>
    <p>Create a Facade API which takes care of the heavy lifting and hides the complexity of calling multiple services by  exposing a single endpoint which returns all the data required to create the profile screen in one API call
<img src="http://res.cloudinary.com/tamizhvendan/image/upload/v1450775641/API_Gateway.png" alt="API Gateway" /></p>

    <p>This approach is called API Gateway. It is one of the commonly used <a href="http://microservices.io/patterns/apigateway.html">patterns in the microservices</a> world.</p>
  </li>
</ul>

<h2 id="rx">Rx</h2>

<p>API Gateway is normally implemented using <a href="http://reactivex.io/">Rx</a>. Rx, an implementation of <a href="https://gist.github.com/staltz/868e7e9bc2a7b8c1f754">Functional Reactive Programming</a>, makes it easy to implement this kind of problems by enable us to think each asynchronous operation as streams (aka Observables). These streams offer a declarative API to work with the asynchronous operations.</p>

<p>In the implementation that we are going to see, we will be using <a href="http://fsprojects.github.io/FSharp.Control.Reactive/">FSharp.Control.Reactive</a>, an extension and wrapper for using the Reactive Extensions (Rx) with F#</p>

<h2 id="project-structure">Project Structure</h2>

<p>Create a new F# Console Application Project with the name <code>RxFsharp</code> and then create the files mentioned below in the given order</p>

<pre><code>RxFsharp
|--Http.fs --&gt; Abstraction to make http requests
|--GitHub.fs --&gt; Define data types, transforming &amp; parsing of responses from GitHub
|--ObservableExtensions.fs --&gt; Some Util methods over Rx Observable
|--Profile.fs --&gt; Implemention of API Gateway using Rx
|--ApiGateway.fs --&gt; Suave API
|--Program.fs --&gt; Entry Point
|--user.json --&gt; Sample response of GitHub user API
|--repos.json --&gt; Sample response of GitHub repos API
|--App.config
|--packages.config
</code></pre>

<p>Then install the following NuGet packages</p>

<ul>
  <li><a href="https://www.nuget.org/packages/FSharp.Control.Reactive">FSharp.Control.Reactive</a></li>
  <li><a href="https://www.nuget.org/packages/Http.fs">Http.fs</a></li>
  <li><a href="https://www.nuget.org/packages/Suave">Suave</a></li>
  <li><a href="https://www.nuget.org/packages/Newtonsoft.Json">Newtonsoft.Json</a></li>
  <li><a href="https://www.nuget.org/packages/FSharp.Data">FSharp.Data</a></li>
</ul>

<h2 id="modeling-http-request--response-as-stream">Modeling Http Request &amp; Response as Stream</h2>

<p>In Functional Reactive Programming(FRP) every action is treated as stream. So, first step in implementing an API Gateway is modeling each HTTP request&amp;response as stream.</p>

<p>Open <code>Http.fs</code> file and update it as below</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"> <a href="#n1" name="n1">1</a></span>module Http
<span class="line-numbers"> <a href="#n2" name="n2">2</a></span>
<span class="line-numbers"> <a href="#n3" name="n3">3</a></span>open HttpClient
<span class="line-numbers"> <a href="#n4" name="n4">4</a></span>open FSharp.Control.Reactive
<span class="line-numbers"> <a href="#n5" name="n5">5</a></span>
<span class="line-numbers"> <a href="#n6" name="n6">6</a></span>type HttpResponse =
<span class="line-numbers"> <a href="#n7" name="n7">7</a></span>| Ok of string
<span class="line-numbers"> <a href="#n8" name="n8">8</a></span>| Error of int
<span class="line-numbers"> <a href="#n9" name="n9">9</a></span>
<span class="line-numbers"><strong><a href="#n10" name="n10">10</a></strong></span>let getResponseAsync url =
<span class="line-numbers"><a href="#n11" name="n11">11</a></span>  async {
<span class="line-numbers"><a href="#n12" name="n12">12</a></span>    let! response =
<span class="line-numbers"><a href="#n13" name="n13">13</a></span>      createRequest Get url
<span class="line-numbers"><a href="#n14" name="n14">14</a></span>      |&gt; withHeader (UserAgent &quot;FsharpRx&quot;)
<span class="line-numbers"><a href="#n15" name="n15">15</a></span>      |&gt; HttpClient.getResponseAsync
<span class="line-numbers"><a href="#n16" name="n16">16</a></span>    let httpResponse =
<span class="line-numbers"><a href="#n17" name="n17">17</a></span>      match response.StatusCode with
<span class="line-numbers"><a href="#n18" name="n18">18</a></span>      | 200 -&gt; response.EntityBody.Value |&gt; Ok
<span class="line-numbers"><a href="#n19" name="n19">19</a></span>      | _ -&gt; response.StatusCode |&gt; Error
<span class="line-numbers"><strong><a href="#n20" name="n20">20</a></strong></span>    return httpResponse
<span class="line-numbers"><a href="#n21" name="n21">21</a></span>  }
<span class="line-numbers"><a href="#n22" name="n22">22</a></span>
<span class="line-numbers"><a href="#n23" name="n23">23</a></span>let asyncResponseToObservable = getResponseAsync &gt;&gt; Observable.ofAsync
</pre></div>
</div>
</div>

<p>The <code>getResponseAsync</code> function makes use of <a href="https://github.com/relentless/Http.fs">Http.fs</a>, an HTTP Client library for F#, to fire the HTTP GET request and returns the HTTP response asynchronously.</p>

<p>The HTTP response has been modeled as either <code>Ok</code> with the response content for all the responses with the status code <code>200</code> and everything else is treated as <code>Error</code> for simplicity.</p>

<p>In the final line, we create a stream (aka Observable) from asynchronous response using the function <code>Observable.ofAsync</code> from <a href="https://github.com/fsprojects/FSharp.Control.Reactive">FSharp.Control.Reactive</a></p>

<p>As all the GitHub API <a href="https://developer.github.com/v3/#user-agent-required">requests require user agent</a>, we are adding one before firing the request.</p>

<h2 id="parsing-and-transforming-github-api-responses">Parsing and Transforming GitHub API Responses</h2>

<p>Upon successful response from GitHub, the next step is parsing the JSON response and transforming the parsed response as per the Profile screen requirements.</p>

<p>To parse the response, we are going to leverage the powerful tool of FSharp called <a href="http://fsharp.github.io/FSharp.Data/library/JsonProvider.html">JsonTypeProvider</a></p>

<p>The JSON Type Provider provides statically typed access to JSON documents. It takes a sample document as an input. Here in our case, it is user.json and repos.json</p>

<p>Get the sample response from GitHub using its <a href="https://api.github.com/users/tamizhvendan">User API</a> and <a href="https://api.github.com/users/tamizhvendan/repos">Repos API</a> and save the response in user.json and repos.json respectively.</p>

<p>With the help of JsonTypeProvider, we can now easily parse the raw JSON response to its equivalent types in just a few lines of code in <code>GitHub.fs</code>!</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"> <a href="#n1" name="n1">1</a></span>module GitHub
<span class="line-numbers"> <a href="#n2" name="n2">2</a></span>
<span class="line-numbers"> <a href="#n3" name="n3">3</a></span>open Http
<span class="line-numbers"> <a href="#n4" name="n4">4</a></span>open FSharp.Data
<span class="line-numbers"> <a href="#n5" name="n5">5</a></span>
<span class="line-numbers"> <a href="#n6" name="n6">6</a></span>type GitHubUser = JsonProvider&lt;&quot;user.json&quot;&gt;
<span class="line-numbers"> <a href="#n7" name="n7">7</a></span>type GitHubUserRepos = JsonProvider&lt;&quot;repos.json&quot;&gt;
<span class="line-numbers"> <a href="#n8" name="n8">8</a></span>
<span class="line-numbers"> <a href="#n9" name="n9">9</a></span>let parseUser = GitHubUser.Parse
<span class="line-numbers"><strong><a href="#n10" name="n10">10</a></strong></span>let parseUserRepos = GitHubUserRepos.Parse
</pre></div>
</div>
</div>

<p>As <code>GitHub.fs</code> is an abstraction of GitHub let’s put their URLs also here in the same file</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"><a href="#n1" name="n1">1</a></span>let host = &quot;https://api.github.com&quot;
<span class="line-numbers"><a href="#n2" name="n2">2</a></span>let userUrl = sprintf &quot;%s/users/%s&quot; host
<span class="line-numbers"><a href="#n3" name="n3">3</a></span>let reposUrl = sprintf &quot;%s/users/%s/repos&quot; host
<span class="line-numbers"><a href="#n4" name="n4">4</a></span>let languagesUrl repoName userName = sprintf &quot;%s/repos/%s/%s/languages&quot; host userName repoName
</pre></div>
</div>
</div>
<p>We have used <a href="http://fsharpforfunandprofit.com/posts/partial-application">partial application</a> of function <code>sprintf</code> in the <code>userUrl</code> and <code>reposUrl</code> function here, so both of these functions take username as its parameter implicitly</p>

<p>The JSON response of <a href="https://api.github.com/repos/tamizhvendan/fsharp-phonecat/languages">languages</a> API is little tricky to parse as its keys are dynamic. The type provider will work only if the underlying response has a fixed schema. So, we can’t use the type provider directly to parse the response of languages API.</p>

<p>We are going to use the inbuilt <a href="http://fsharp.github.io/FSharp.Data/library/JsonValue.html">JSON Parser</a> available with JsonTypeProvider to parse the languages response</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"><a href="#n1" name="n1">1</a></span>let parseLanguages languagesJson =
<span class="line-numbers"><a href="#n2" name="n2">2</a></span>  languagesJson
<span class="line-numbers"><a href="#n3" name="n3">3</a></span>  |&gt; JsonValue.Parse
<span class="line-numbers"><a href="#n4" name="n4">4</a></span>  |&gt; JsonExtensions.Properties
<span class="line-numbers"><a href="#n5" name="n5">5</a></span>  |&gt; Array.map fst
</pre></div>
</div>
</div>

<p>The <code>JsonValue.Parse</code> parses the raw string JSON to a type called <code>JsonValue</code> and the <code>JsonExtensions.Properties</code> function takes a <code>JsonValue</code> and returns the key and value pairs of all the properties in the JSON as tuples. As we are interested only in the Keys here, we just pluck that value alone using the function <code>fst</code></p>

<p>Great! Now we are done with parsing the JSON response of all the three APIs and creating it’s equivalent types. The next step is doing some business transformation</p>

<p>One of the requirements of the Profile Screen is that we need to show only the top 3 popular repositories based on the stars received by the repository. Let’s implement it</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"> <a href="#n1" name="n1">1</a></span>let popularRepos (repos : GitHubUserRepos.Root []) =
<span class="line-numbers"> <a href="#n2" name="n2">2</a></span>  let ownRepos = repos |&gt; Array.filter (fun repo -&gt; not repo.Fork)
<span class="line-numbers"> <a href="#n3" name="n3">3</a></span>  let takeCount = if ownRepos.Length &gt; 3 then 3 else repos.Length
<span class="line-numbers"> <a href="#n4" name="n4">4</a></span>
<span class="line-numbers"> <a href="#n5" name="n5">5</a></span>  ownRepos
<span class="line-numbers"> <a href="#n6" name="n6">6</a></span>  |&gt; Array.sortBy (fun r -&gt; -r.StargazersCount)
<span class="line-numbers"> <a href="#n7" name="n7">7</a></span>  |&gt; Array.toSeq
<span class="line-numbers"> <a href="#n8" name="n8">8</a></span>  |&gt; Seq.take takeCount
<span class="line-numbers"> <a href="#n9" name="n9">9</a></span>  |&gt; Seq.toArray
</pre></div>
</div>
</div>

<p>In the <code>Http.fs</code> file, we defined how to get the raw JSON response using Stream as <code>HttpResponse</code> (<code>Ok</code> &amp; <code>Error</code>) and in this <code>GitHub.fs</code>, we have defined how to parse this raw JSON response and transform them its equivalent strongly types.</p>

<p>The final step is integrating both these logic and return the Output record type needed by the Profile Screen</p>

<p>let’s start by defining the Profile type</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"> <a href="#n1" name="n1">1</a></span>type Profile = {
<span class="line-numbers"> <a href="#n2" name="n2">2</a></span>  Name : string
<span class="line-numbers"> <a href="#n3" name="n3">3</a></span>  AvatarUrl : string
<span class="line-numbers"> <a href="#n4" name="n4">4</a></span>  PopularRepositories : Repository seq
<span class="line-numbers"> <a href="#n5" name="n5">5</a></span>} and Repository = {
<span class="line-numbers"> <a href="#n6" name="n6">6</a></span>  Name : string
<span class="line-numbers"> <a href="#n7" name="n7">7</a></span>  Stars : int
<span class="line-numbers"> <a href="#n8" name="n8">8</a></span>  Languages : string[]
<span class="line-numbers"> <a href="#n9" name="n9">9</a></span>}
</pre></div>
</div>
</div>
<p>Then write functions to get the value from <code>HttpResponse</code> and create this profile output.</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"> <a href="#n1" name="n1">1</a></span>let reposResponseToPopularRepos = function
<span class="line-numbers"> <a href="#n2" name="n2">2</a></span>  |Ok(r) -&gt; r |&gt; parseUserRepos |&gt; popularRepos
<span class="line-numbers"> <a href="#n3" name="n3">3</a></span>  |_ -&gt; [||]
<span class="line-numbers"> <a href="#n4" name="n4">4</a></span>
<span class="line-numbers"> <a href="#n5" name="n5">5</a></span>// Languages always associated with a repository
<span class="line-numbers"> <a href="#n6" name="n6">6</a></span>let languageResponseToRepoWithLanguages (repo : GitHubUserRepos.Root) = function
<span class="line-numbers"> <a href="#n7" name="n7">7</a></span>  |Ok(l) -&gt; {Name = repo.Name; Languages = (parseLanguages l); Stars = repo.StargazersCount}
<span class="line-numbers"> <a href="#n8" name="n8">8</a></span>  |_ -&gt; {Name = repo.Name; Languages = Array.empty; Stars = repo.StargazersCount}
<span class="line-numbers"> <a href="#n9" name="n9">9</a></span>
<span class="line-numbers"><strong><a href="#n10" name="n10">10</a></strong></span>let toProfile  = function
<span class="line-numbers"><a href="#n11" name="n11">11</a></span>  |Ok(u), repos -&gt;
<span class="line-numbers"><a href="#n12" name="n12">12</a></span>      let user = parseUser u
<span class="line-numbers"><a href="#n13" name="n13">13</a></span>      {Name = user.Name; PopularRepositories = repos; AvatarUrl = user.AvatarUrl} |&gt; Some
<span class="line-numbers"><a href="#n14" name="n14">14</a></span>  | _ -&gt; None
</pre></div>
</div>
</div>

<p>All the above functions except <code>toProfile</code> take <code>HttpResponse</code> as its last parameter implicitly.</p>

<p>In <code>reposResponseToPopularRepos</code> function, if the repos API request is successful, we parse the response to its equivalent type and then pick only three of them based on star count and in the case of an error we just return an empty array.</p>

<p>The <code>languageResponseToRepoWithLanguages</code> function handles the response from the Languages API request which takes its associated repository as its first parameter. If the response is successful, then it creates the <code>Repository</code> record with the returned languages else it just the <code>Repository</code> record with an empty array for languages.</p>

<p>The last function <code>toProfile</code> is a merge function which takes a tuple of <code>HttpResponse</code> (of User API request) and <code>Repository []</code> and creates a <code>Profile</code> record if the response is successful. In case of an error, it just returns <code>None</code></p>

<p><em>Note: To keep this blog post simple, I am handling the errors using empty arrays and None. It can be extended using <a href="http://fsharpforfunandprofit.com/rop/">ROP</a></em></p>

<h2 id="implementing-api-gateway">Implementing API Gateway</h2>

<p>Let me quickly summarize what we have done so far. We have created two abstractions.</p>

<ul>
  <li><code>Http</code> - Responsible for firing the HTTP GET request with the given URL and give the response as a Rx Stream</li>
</ul>

<pre><code>URL
  \
----------Response--|

</code></pre>

<ul>
  <li><code>GitHub</code> - Takes care of parsing the JSON response from GitHub API and does some business logic (finding top 3 popular repositories). Then returns the output in the format that the Client needs.</li>
</ul>

<p>With the help of these abstractions now we are going to build the API Gateway to get the profile object.</p>

<p>Open <code>Gateway.fs</code> and add the <code>getProfile</code> function</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"><a href="#n1" name="n1">1</a></span>//string -&gt; Async&lt;Profile&gt;
<span class="line-numbers"><a href="#n2" name="n2">2</a></span>let getProfile username =
<span class="line-numbers"><a href="#n3" name="n3">3</a></span>  async {
<span class="line-numbers"><a href="#n4" name="n4">4</a></span>    // TODO
<span class="line-numbers"><a href="#n5" name="n5">5</a></span>    return! profile
<span class="line-numbers"><a href="#n6" name="n6">6</a></span>  }
</pre></div>
</div>
</div>
<p>It is just a skeleton which just describes the what function does. Let’s start its implementation.</p>

<p>In Rx world, everything is a stream. So, the first step is converting GitHub User API request to stream</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"><a href="#n1" name="n1">1</a></span>let getProfile username =
<span class="line-numbers"><a href="#n2" name="n2">2</a></span>  // ...
<span class="line-numbers"><a href="#n3" name="n3">3</a></span>  let userStream = username |&gt; userUrl |&gt; asyncResponseToObservable
<span class="line-numbers"><a href="#n4" name="n4">4</a></span>  // ...
</pre></div>
</div>
</div>

<p>We have created the <code>userStream</code> using the <code>userUrl</code> and <code>asyncResponseToObservable</code> function defined earlier.</p>

<pre><code>userURL
  \
-----------UJ--|              // UJ - GitHub User Response in JSON format
</code></pre>

<p>Then we need top three popular repositories as a stream</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"><a href="#n1" name="n1">1</a></span>let getProfile username =
<span class="line-numbers"><a href="#n2" name="n2">2</a></span>  // ...
<span class="line-numbers"><a href="#n3" name="n3">3</a></span>  let popularReposStream =
<span class="line-numbers"><a href="#n4" name="n4">4</a></span>    username
<span class="line-numbers"><a href="#n5" name="n5">5</a></span>    |&gt; reposUrl
<span class="line-numbers"><a href="#n6" name="n6">6</a></span>    |&gt; asyncResponseToObservable
<span class="line-numbers"><a href="#n7" name="n7">7</a></span>    |&gt; Observable.map reposResponseToPopularRepos
<span class="line-numbers"><a href="#n8" name="n8">8</a></span>  // ...
</pre></div>
</div>
</div>

<p>Except the last line, everything is same as that of creating <code>userStream</code>. If you check <a href="https://api.github.com/users/tamizhvendan/repos">GitHub repos API</a> it just returns all the repos associated with the given username. But what we need is only top three of them based on the number of stars it has received.</p>

<p>We already have a function <code>reposResponseToPopularRepos</code> in <code>GitHub.fs</code> which does the job of picking the top three repos from the raw JSON. As the response is in the form Rx stream, we need to get the value from the stream and then we need to apply this function and that’s what the <code>Observable.map</code> does. It is very similar to <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/map">Array.map</a> and <a href="https://msdn.microsoft.com/en-us/library/system.linq.enumerable.select(v=vs.100).aspx">LINQ Select</a></p>

<pre><code>reposURL
  \
----------RJ---|                          // RJ - GitHub user repos in JSON format
          | MAP function (RJ -&gt; PR)       // PR - Popular Repos
          V
--------------PR---|
</code></pre>

<p>The next operation is a little complex. i.e. finding out the programming languages being used in these popular repositories. To get this GitHub API, we need to fire three separate requests to the <a href="https://developer.github.com/v3/repos/#list-languages">Languages API</a> for each repository and then merge the results back with the corresponding repository.</p>

<p>To implement this with the help of Rx streams, we need to understand the <code>flatMap</code> <a href="http://reactivex.io/documentation/operators/flatmap.html">function of Rx</a>.</p>

<p>It is similar to the <code>map</code> function that we have seen before with a difference that it takes a function that returns a new item stream instead of a new item.</p>

<h3 id="map">Map</h3>

<p><img src="http://reactivex.io/documentation/operators/images/map.c.png" alt="Map" /></p>

<p>The <code>map</code> function has the following signature</p>

<pre><code>('a -&gt; 'b) -&gt; IObservable&lt;'a&gt; -&gt; IObservable&lt;'b&gt;
</code></pre>

<h3 id="flatmap">FlatMap</h3>

<p><img src="http://reactivex.io/documentation/operators/images/flatMap.c.png" alt="FlatMap" /></p>

<p>The <code>flatMap</code> function has the following signature</p>

<pre><code>('a -&gt; IObservable&lt;'b&gt;) -&gt; IObservable&lt;'a&gt; -&gt; IObservable&lt;'b&gt;
</code></pre>

<p>This function is also called as <code>bind</code> function in the functional programming world. If you would like to know further on this topic, I strongly recommend <a href="http://fsharpforfunandprofit.com/posts/elevated-world">this blog series</a> by the fsharp great, <a href="https://twitter.com/ScottWlaschin">Scott Wlaschin</a></p>

<p>Back to the problem in hand, we need to fire three HTTP GET Requests to get back the languages associated with the each of the top three popular repos. In terms of the <code>flatMap</code> function, it boils down to three functions of the following syntax</p>

<pre><code>(GitHubUserRepos.Root -&gt; IObservable&lt;Repostiory&gt;)
  -&gt; IObservable&lt;GitHubUserRepos.Root&gt; -&gt; IObservable&lt;Repostiory&gt;
</code></pre>

<p>We can implement the solution using three <code>flatMap</code> functions using the above syntax. But, we can make it more granular by creating a new variant of <code>flatMap</code> function to achieve this in a more straightforward way.</p>

<p>The ideal function that we are looking for in this <code>flatMap</code> variant holds the following signature</p>

<pre><code>('a -&gt; IObservable&lt;'b&gt;) -&gt; IObservable&lt;'a []&gt; -&gt; IObservable&lt;'b []&gt;
</code></pre>
<p>i.e three <code>flatMap</code> can be rewritten as</p>

<pre><code>(GitHubUserRepos.Root -&gt; IObservable&lt;Repostiory&gt;)
  -&gt; IObservable&lt;GitHubUserRepos.Root []&gt; -&gt; IObservable&lt;Repostiory []&gt;
</code></pre>

<p>Let’s name it as <code>flatMap2</code> and add the implementation of it in the file <code>ObservableExtensions.fs</code></p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"><a href="#n1" name="n1">1</a></span>module ObservableExtensions
<span class="line-numbers"><a href="#n2" name="n2">2</a></span>open FSharp.Control.Reactive
<span class="line-numbers"><a href="#n3" name="n3">3</a></span>
<span class="line-numbers"><a href="#n4" name="n4">4</a></span>let flatmap2 f observable =
<span class="line-numbers"><a href="#n5" name="n5">5</a></span>  observable
<span class="line-numbers"><a href="#n6" name="n6">6</a></span>  |&gt; Observable.flatmap (Array.map f &gt;&gt; Observable.mergeArray)
<span class="line-numbers"><a href="#n7" name="n7">7</a></span>  |&gt; Observable.toArray
</pre></div>
</div>
</div>

<p>Here is the representation of what this function does</p>

<pre><code>-----X[n]--------------------------|-&gt;
      \   flatMap on each item in X which yield the stream of R
-------R1-------------------------|-&gt;
----------R2----------------------|-&gt;
          ......
-------------Rn-------------------|-&gt;
          ||  mergeArray -&gt; merge array of R streams into one stream
          VV
------R1-R2--Rn-------------------|-&gt;
              \ toArray -&gt; Creates an array from an observable sequence
-------------R[n]-----------------|-&gt;
</code></pre>

<p>It’s hard to get it right in a single shot. So, let’s see it in detail step by step by applying it to our use case here</p>

<ul>
  <li>We have the stream of three popular repos (i.e array of repos)</li>
</ul>

<pre><code>-----X[n]--------------------------|-&gt;
</code></pre>
<ul>
  <li>To get the languages associated with the each repo we need to call the languages API for every repo item in the above step</li>
</ul>

<pre><code>-----X[n]--------------------------|-&gt;
      \   flatMap on each item in X which yield the n streams of R
-------R1-------------------------|-&gt;
----------R2----------------------|-&gt;
          ......
-------------Rn-------------------|-&gt;
</code></pre>
<ul>
  <li>After we received the response from each languages API call, we need to merge them into one stream</li>
</ul>

<pre><code>-------R1-------------------------|-&gt;
----------R2----------------------|-&gt;
          ......
-------------Rn-------------------|-&gt;
          |  mergeArray -&gt; merge array of R streams into one stream
          V
------R1-R2--Rn-------------------|-&gt;
</code></pre>

<ul>
  <li>To integrate this with the expected application response, we need all the responses in a single go</li>
</ul>

<pre><code>------R1-R2--Rn-------------------|-&gt;
              \ toArray -&gt; Creates an array from an observable sequence
-------------R[n]-----------------|-&gt;
</code></pre>

<p>Great! You got it right!!</p>

<p>Let’s use this <code>flatMap2</code> function and complete the implementation of profile API gateway.</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"> <a href="#n1" name="n1">1</a></span>let getProfile username =
<span class="line-numbers"> <a href="#n2" name="n2">2</a></span>  // ...
<span class="line-numbers"> <a href="#n3" name="n3">3</a></span>  let toRepoWithLanguagesStream (repo : GitHubUserRepos.Root) =    
<span class="line-numbers"> <a href="#n4" name="n4">4</a></span>    username
<span class="line-numbers"> <a href="#n5" name="n5">5</a></span>    |&gt; languagesUrl repo.Name
<span class="line-numbers"> <a href="#n6" name="n6">6</a></span>    |&gt; asyncResponseToObservable
<span class="line-numbers"> <a href="#n7" name="n7">7</a></span>    |&gt; Observable.map (languageResponseToRepoWithLanguages repo)
<span class="line-numbers"> <a href="#n8" name="n8">8</a></span>
<span class="line-numbers"> <a href="#n9" name="n9">9</a></span>  let popularReposStream =
<span class="line-numbers"><strong><a href="#n10" name="n10">10</a></strong></span>    username
<span class="line-numbers"><a href="#n11" name="n11">11</a></span>    |&gt; reposUrl
<span class="line-numbers"><a href="#n12" name="n12">12</a></span>    |&gt; asyncResponseToObservable
<span class="line-numbers"><a href="#n13" name="n13">13</a></span>    |&gt; Observable.map reposResponseToPopularRepos
<span class="line-numbers"><a href="#n14" name="n14">14</a></span>    |&gt; flatmap2 toRepoWithLanguagesStream
<span class="line-numbers"><a href="#n15" name="n15">15</a></span>
<span class="line-numbers"><a href="#n16" name="n16">16</a></span>  // ...
</pre></div>
</div>
</div>

<p>The <code>flatmap2</code> function takes the function <code>toRepoWithLanguagesStream</code> which converts the <code>GitHubUserRepos.Root</code> type to <code>IObservable&lt;Repository&gt;</code> to find out the languages associated with the given popular repositories.</p>

<p>The <code>toRepoWithLanguagesStream</code> function does the following</p>

<pre><code>GitHubUserRepos.Root
  \ create a languages GitHub API stream using the repo name from the input
-------LR----------|              // LR - languages GitHub API response
        \ MAP function (GitHubUserRepos.Root -&gt; LR -&gt; R)
------------R------|              // R - Repository type that defined earlier
</code></pre>
<p>The <code>Observable.map</code> function takes only one input, but here we need to two inputs. So, With the help of <a href="http://fsharpforfunandprofit.com/posts/partial-application/">partial application</a>, we created an intermediate function by partially applying the first parameter alone</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"><a href="#n1" name="n1">1</a></span>Observable.map (languageResponseToRepoWithLanguages repo)
</pre></div>
</div>
</div>

<p>The <code>languageResponseToRepoWithLanguages</code> function has been already defined in the <code>GitHub.fs</code> file.</p>

<p>The last step of the <code>getProfile</code> function is combining this <code>popularReposStream</code> with the <code>userStream</code> created earlier and return the <code>Profile</code> type asynchronously.</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"> <a href="#n1" name="n1">1</a></span>let getProfile username =
<span class="line-numbers"> <a href="#n2" name="n2">2</a></span>  // ...
<span class="line-numbers"> <a href="#n3" name="n3">3</a></span>  async {
<span class="line-numbers"> <a href="#n4" name="n4">4</a></span>    return! popularReposStream
<span class="line-numbers"> <a href="#n5" name="n5">5</a></span>            |&gt; Observable.zip userStream
<span class="line-numbers"> <a href="#n6" name="n6">6</a></span>            |&gt; Observable.map toProfile
<span class="line-numbers"> <a href="#n7" name="n7">7</a></span>            |&gt; TaskObservableExtensions.ToTask
<span class="line-numbers"> <a href="#n8" name="n8">8</a></span>            |&gt; Async.AwaitTask
<span class="line-numbers"> <a href="#n9" name="n9">9</a></span>  }
<span class="line-numbers"><strong><a href="#n10" name="n10">10</a></strong></span>  // ...
</pre></div>
</div>
</div>

<p>The <code>Observable.zip</code> function takes two streams as its input, then merges the output of each stream and return the output as a tuple. From this tuple, we have used <code>Observable.map</code> function to map it a <code>Profile</code> type using the <code>toProfile</code> function created earlier in <code>GitHub.fs</code></p>

<pre><code>-----UR-------------|     // UR - GitHub User API Response
--------PR----------|     // PR - Popular Repos
        \ ZIP function (UR -&gt; PR -&gt; (UR,PR))   
---------(UR,PR)----|
          \ MAP ( (UR,PR) -&gt; P )  // P - Profile
----------P---------|
</code></pre>

<p>The last functions <code>TaskObservableExtensions.ToTask</code> and <code>Async.AwaitTask</code> does the conversion of <code>IObservable</code> to <code>async</code> by converting it to a <code>Task</code> first and then the <code>Task</code> to <code>async</code></p>

<p>The final <code>getProfile</code> function will be like</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"> <a href="#n1" name="n1">1</a></span>
<span class="line-numbers"> <a href="#n2" name="n2">2</a></span>let getProfile username =
<span class="line-numbers"> <a href="#n3" name="n3">3</a></span>
<span class="line-numbers"> <a href="#n4" name="n4">4</a></span>  let userStream = username |&gt; userUrl |&gt; asyncResponseToObservable
<span class="line-numbers"> <a href="#n5" name="n5">5</a></span>
<span class="line-numbers"> <a href="#n6" name="n6">6</a></span>  let toRepoWithLanguagesStream (repo : GitHubUserRepos.Root) =    
<span class="line-numbers"> <a href="#n7" name="n7">7</a></span>    username
<span class="line-numbers"> <a href="#n8" name="n8">8</a></span>    |&gt; languagesUrl repo.Name
<span class="line-numbers"> <a href="#n9" name="n9">9</a></span>    |&gt; asyncResponseToObservable
<span class="line-numbers"><strong><a href="#n10" name="n10">10</a></strong></span>    |&gt; Observable.map (languageResponseToRepoWithLanguages repo)
<span class="line-numbers"><a href="#n11" name="n11">11</a></span>
<span class="line-numbers"><a href="#n12" name="n12">12</a></span>  let popularReposStream =
<span class="line-numbers"><a href="#n13" name="n13">13</a></span>    username
<span class="line-numbers"><a href="#n14" name="n14">14</a></span>    |&gt; reposUrl
<span class="line-numbers"><a href="#n15" name="n15">15</a></span>    |&gt; asyncResponseToObservable
<span class="line-numbers"><a href="#n16" name="n16">16</a></span>    |&gt; Observable.map reposResponseToPopularRepos
<span class="line-numbers"><a href="#n17" name="n17">17</a></span>    |&gt; flatmap2 toRepoWithLanguagesStream
<span class="line-numbers"><a href="#n18" name="n18">18</a></span>
<span class="line-numbers"><a href="#n19" name="n19">19</a></span>  async {
<span class="line-numbers"><strong><a href="#n20" name="n20">20</a></strong></span>    return! popularReposStream
<span class="line-numbers"><a href="#n21" name="n21">21</a></span>            |&gt; Observable.zip userStream
<span class="line-numbers"><a href="#n22" name="n22">22</a></span>            |&gt; Observable.map toProfile
<span class="line-numbers"><a href="#n23" name="n23">23</a></span>            |&gt; TaskObservableExtensions.ToTask
<span class="line-numbers"><a href="#n24" name="n24">24</a></span>            |&gt; Async.AwaitTask
<span class="line-numbers"><a href="#n25" name="n25">25</a></span>  }
</pre></div>
</div>
</div>

<p>This function is a testimonial on <em>How functional programming helps to write less, robust, and readable code to solve a complex problem</em></p>

<p>We have handled all the five HTTP requests asynchronously, did some error handling (by returning empty types), and finally efficiently combined outputs of these five HTTP requests and created a type to send back to the client. Everything is asynchronous!</p>

<p>Pretty awesome isn’t it?</p>

<h2 id="exposing-the-api">Exposing the API</h2>

<p>The final step is exposing what we have done so far as an API to the outside world. We are going to implement this using <a href="https://suave.io/">Suave</a></p>

<p>Open <code>ApiGateway.fs</code> file and update it as below</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"> <a href="#n1" name="n1">1</a></span>let JSON v =  
<span class="line-numbers"> <a href="#n2" name="n2">2</a></span>  let jsonSerializerSettings = new JsonSerializerSettings()
<span class="line-numbers"> <a href="#n3" name="n3">3</a></span>  jsonSerializerSettings.ContractResolver &lt;- new CamelCasePropertyNamesContractResolver()
<span class="line-numbers"> <a href="#n4" name="n4">4</a></span>
<span class="line-numbers"> <a href="#n5" name="n5">5</a></span>  JsonConvert.SerializeObject(v, jsonSerializerSettings)
<span class="line-numbers"> <a href="#n6" name="n6">6</a></span>  |&gt; OK
<span class="line-numbers"> <a href="#n7" name="n7">7</a></span>  &gt;=&gt; Writers.setMimeType &quot;application/json; charset=utf-8&quot;
<span class="line-numbers"> <a href="#n8" name="n8">8</a></span>
<span class="line-numbers"> <a href="#n9" name="n9">9</a></span>let getProfile userName (httpContext : HttpContext) =
<span class="line-numbers"><strong><a href="#n10" name="n10">10</a></strong></span>   async {
<span class="line-numbers"><a href="#n11" name="n11">11</a></span>      let! profile = getProfile userName
<span class="line-numbers"><a href="#n12" name="n12">12</a></span>      match profile with
<span class="line-numbers"><a href="#n13" name="n13">13</a></span>      | Some p -&gt; return! JSON p httpContext
<span class="line-numbers"><a href="#n14" name="n14">14</a></span>      | None -&gt; return! NOT_FOUND (sprintf &quot;Username %s not found&quot; userName) httpContext
<span class="line-numbers"><a href="#n15" name="n15">15</a></span>   }
</pre></div>
</div>
</div>

<p>The <code>JSON</code> is a utility function (WebPart in the world of Suave) which takes any type, serialize it to JSON format and return it as JSON HTTP response.</p>

<p>The <code>getProfile</code> function is the API WebPart which calls our backend API gateway implementation and pass the received response to the <code>JSON</code> WebPart defined before.</p>

<p>In case if there is no profile available (Remember? we return empty types in case of errors), we just return <code>404</code> with the message that the given username is not found.</p>

<p>Then update the <code>Program.fs</code> to write the web server code</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"><a href="#n1" name="n1">1</a></span>[&lt;EntryPoint&gt;]
<span class="line-numbers"><a href="#n2" name="n2">2</a></span>let main argv =
<span class="line-numbers"><a href="#n3" name="n3">3</a></span>  let webpart = pathScan &quot;/api/profile/%s&quot; ApiGateway.getProfile
<span class="line-numbers"><a href="#n4" name="n4">4</a></span>  startWebServer defaultConfig webpart
<span class="line-numbers"><a href="#n5" name="n5">5</a></span>  0
</pre></div>
</div>
</div>

<p>Thanks to <code>Suave</code> for it’s lightweight and low-ceremony offerings in creating an API. We just exposed it in two lines!</p>

<p>Hit <code>F5</code> and access the API at <code>http://localhost:8083/api/profile/{github-username}</code> Bingo!!</p>

<h2 id="summary">Summary</h2>

<blockquote>
  <p>A language that doesn’t affect the way you think about programming is not worth knowing - Alan Perils</p>
</blockquote>

<p>The above quote summarizes the gist of this blog post. Functional Programming will help you think better. You can get the source code associated with the blog post in my <a href="https://github.com/tamizhvendan/blog-samples/tree/master/RxFsharp">blog-samples GitHub repository</a></p>

<p>Wish you a happy and prosperous new year</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Step-3 PhoneCat Recommendation System using F# Agents, SignalR and Rx]]></title>
    <link href="http://blog.tamizhvendan.in/blog/2015/01/02/step-3-phonecat-recommendation-system-using-f-number-agents/"/>
    <updated>2015-01-02T05:44:52+05:30</updated>
    <id>http://blog.tamizhvendan.in/blog/2015/01/02/step-3-phonecat-recommendation-system-using-f-number-agents</id>
    <content type="html"><![CDATA[<blockquote>
  <p>This is step 3 of my blog series on <a href="/blog/2014/12/10/web-application-development-in-fsharp-using-asp-dot-net-mvc/">Web Application Development in Fsharp using ASP.NET MVC</a></p>
</blockquote>

<p>In the last two steps we have seen how to create a <a href="/blog/2014/12/17/phonecat-backend-using-web-api-and-typeproviders/">web apis</a> and <a href="/blog/2014/12/23/step-2-fsharp-phonecat-views-using-razor/">static razor views</a> in fsharp. In this blog post we are going to see one of my favorite feature in fsharp <a href="http://fsharpforfunandprofit.com/posts/concurrency-actor-model/">“Message based approach to concurrency”</a>.</p>

<h3 id="a-small-flashback">A Small Flashback</h3>
<p>I’ve actually planned to put this blog post for the great fsharp community initiative <a href="https://sergeytihon.wordpress.com/2014/11/24/f-advent-calendar-in-english-2014/">F# Advent Calender</a>. Unfortunately it was not able to get through as I’ve <a href="http://sergeytihon.wordpress.com/2014/11/24/f-advent-calendar-in-english-2014/#comment-4135">nominated myself</a> little late. I always believe there is an opportunity behind every adversity. I didn’t get hung up and I knew this is one of the great topic to blog about. When I decided to blog about it, I needed a sample web application. So, I was creating that sample application and it suddenly strikes! <em>How about a blog series on web application development in fsharp?</em> I’ve immediately started working on it and hence this blog series.</p>

<h3 id="so-what-we-gonna-do-in-this-step">So what we gonna do in this step</h3>
<p>In this blog post we are going to build a recommendation system which keeps track of what phones that the user is viewing, and based on his navigation history, we will be recommending a phone that he might be interested in</p>

<p style="text-align:center"> <strong> User visits "Motorola XOOM™" </strong> </p>
<p><img src="/images/fsharp_phonecat/step_3/Phone_1.png"></p>

<p style="text-align:center"> <strong> User visits "Motorola XOOM™ with Wi-Fi" </strong> </p>
<p><img src="/images/fsharp_phonecat/step_3/Phone_2.png"></p>

<p>Let us start the implementation by defining two high level tasks</p>

<ol>
  <li>Tracking user navigation</li>
  <li>Recommending a phone</li>
</ol>

<h3 id="tracking-user-navigation">1. Tracking user navigation</h3>

<p><img class="center" src="/images/fsharp_phonecat/step_3/Phone_Visit_Workflow.png" width="600" height="500"></p>

<p>The first two components has been already implemented as part of <a href="/blog/2014/12/23/step-2-fsharp-phonecat-views-using-razor/">step-2</a>. So we just need to wire up the other two components. Let’s start from <code>PhoneViewTracker</code></p>

<p>Create a source file in the <strong>Web</strong> project and name it as <code>PhoneViewTracker</code>. Add a function <code>observePhonesViewed</code> which will be invoked when you a user visits a phone.</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"><a href="#n1" name="n1">1</a></span>module PhoneViewTracker =     
<span class="line-numbers"><a href="#n2" name="n2">2</a></span>    
<span class="line-numbers"><a href="#n3" name="n3">3</a></span>  let observePhonesViewed anonymousId phoneIdBeingVisited =
<span class="line-numbers"><a href="#n4" name="n4">4</a></span>    StorageAgent.Post (SavePhoneVisit (anonymousId, phoneIdBeingVisited))
</pre></div>
</div>
</div>

<p>The <code>anonymousId</code> is a <a href="http://msdn.microsoft.com/en-us/library/system.web.httprequest.anonymousid%28v=vs.110%29.aspx">http property</a> which represents a unique identifier for the given user session</p>

<p>Upon receiving the <code>anonymousId</code> and <code>phoneIdBeingVisited</code> we will be posting a message to the <code>StorageAgent</code> to save this visit. Both the agent and the message doesn’t exist now, so lets create them</p>

<p>Create a source file in the <strong>Domain</strong> project and name it as <code>UserNavigationHistory</code> and add the following</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"> <a href="#n1" name="n1">1</a></span>namespace PhoneCat.Domain
<span class="line-numbers"> <a href="#n2" name="n2">2</a></span>
<span class="line-numbers"> <a href="#n3" name="n3">3</a></span>open System.Reactive.Subjects
<span class="line-numbers"> <a href="#n4" name="n4">4</a></span>open System.Collections.Generic
<span class="line-numbers"> <a href="#n5" name="n5">5</a></span>
<span class="line-numbers"> <a href="#n6" name="n6">6</a></span>type Agent&lt;'T&gt; = MailboxProcessor&lt;'T&gt;
<span class="line-numbers"> <a href="#n7" name="n7">7</a></span>
<span class="line-numbers"> <a href="#n8" name="n8">8</a></span>module UserNavigationHistory =  
<span class="line-numbers"> <a href="#n9" name="n9">9</a></span>
<span class="line-numbers"><strong><a href="#n10" name="n10">10</a></strong></span>  type StorageAgentMessage =
<span class="line-numbers"><a href="#n11" name="n11">11</a></span>    | SavePhoneVisit of string * string
<span class="line-numbers"><a href="#n12" name="n12">12</a></span>  
<span class="line-numbers"><a href="#n13" name="n13">13</a></span>  let private storageAgentFunc (agent : Agent&lt;StorageAgentMessage&gt;) =  
<span class="line-numbers"><a href="#n14" name="n14">14</a></span>    
<span class="line-numbers"><a href="#n15" name="n15">15</a></span>    let rec loop (dict : Dictionary&lt;string, list&lt;string&gt;&gt;) = async { 
<span class="line-numbers"><a href="#n16" name="n16">16</a></span>      let! storageAgentMessage = agent.Receive()
<span class="line-numbers"><a href="#n17" name="n17">17</a></span>      match storageAgentMessage with
<span class="line-numbers"><a href="#n18" name="n18">18</a></span>      | SavePhoneVisit (anonymousId, phoneIdBeingVisited) -&gt; 
<span class="line-numbers"><a href="#n19" name="n19">19</a></span>          if dict.ContainsKey(anonymousId) then
<span class="line-numbers"><strong><a href="#n20" name="n20">20</a></strong></span>            let phoneIdsVisited = phoneIdBeingVisited :: dict.[anonymousId]
<span class="line-numbers"><a href="#n21" name="n21">21</a></span>            dict.[anonymousId] &lt;- phoneIdsVisited
<span class="line-numbers"><a href="#n22" name="n22">22</a></span>          else
<span class="line-numbers"><a href="#n23" name="n23">23</a></span>            dict.Add(anonymousId, [phoneIdBeingVisited])
<span class="line-numbers"><a href="#n24" name="n24">24</a></span>      return! loop dict      
<span class="line-numbers"><a href="#n25" name="n25">25</a></span>    }
<span class="line-numbers"><a href="#n26" name="n26">26</a></span>
<span class="line-numbers"><a href="#n27" name="n27">27</a></span>    loop (new Dictionary&lt;string, list&lt;string&gt;&gt;())
<span class="line-numbers"><a href="#n28" name="n28">28</a></span>
<span class="line-numbers"><a href="#n29" name="n29">29</a></span>  let StorageAgent = Agent.Start(storageAgentFunc)
<span class="line-numbers"><strong><a href="#n30" name="n30">30</a></strong></span>
</pre></div>
</div>
</div>

<p>Storage Agent is an F# Agent which stores the user navigation history in an in-memory dictionary. It can be replaced by any key-value store like <a href="http://redis.io/">redis</a> but for experimentation I’ve preferred to use F# Agents.</p>

<p>The <code>StorageAgentMessage</code> is a <a href="http://fsharpforfunandprofit.com/posts/discriminated-unions/">dicriminated union</a> represents possible messages that the <code>StorageAgent</code> can process. Right now it has only message <code>SavePhoneVisit</code> which takes a tuple representing the <code>anonymousId</code> and the <code>phoneIdBeingVisited</code></p>

<p>The <code>StorageAgent</code> is a typical F# Agent which waits for the incoming <code>StorageAgentMessage</code> and upon receiving it stores the visit in the in-memory dictionary. </p>

<p>The next step is wiring the <code>PhoneViewTracker.observePhonesViewed</code> function with the <code>PhoneController.Show</code> action method. We can call the function directly that will create a strongly coupled code. We can even directly post the message to the agent. But that also makes the code tightly coupled. </p>

<p>What we are actually trying to implement here is a <strong>User Phone Visit Stream</strong>. Whenever the user visits a phone, we just want to notifiy somebody to keep track of it and move on. And its where <a href="http://msdn.microsoft.com/en-in/data/gg577609.aspx">Reactive Extensions aka Rx</a> comes into the picture. If you are new to Reactive Programming or Rx, I strongly recommend you to go through <a href="https://gist.github.com/staltz/868e7e9bc2a7b8c1f754">this excellent article</a> by <a href="http://staltz.com/">André Staltz</a></p>

<p>Install the <a href="https://www.nuget.org/packages/Rx-Main/">Rx Nuget Package</a> in the <em>Web</em> project. With Rx in the kitty the next step is to make the User’s phone visit as event and subscribe this event with the <code>PhoneViewTracker</code></p>

<p>The first step is to make the <code>PhoneController</code> as observable. Modify the already created <code>PhoneController</code> as below</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"> <a href="#n1" name="n1">1</a></span>type PhoneController(phones : seq&lt;Phone&gt;) =
<span class="line-numbers"> <a href="#n2" name="n2">2</a></span>  inherit Controller()
<span class="line-numbers"> <a href="#n3" name="n3">3</a></span>  
<span class="line-numbers"> <a href="#n4" name="n4">4</a></span>  let subject = new Subject&lt;string&gt;()
<span class="line-numbers"> <a href="#n5" name="n5">5</a></span>  
<span class="line-numbers"> <a href="#n6" name="n6">6</a></span>  interface IObservable&lt;string&gt; with
<span class="line-numbers"> <a href="#n7" name="n7">7</a></span>    member this.Subscribe observer = subject.Subscribe observer
<span class="line-numbers"> <a href="#n8" name="n8">8</a></span>  
<span class="line-numbers"> <a href="#n9" name="n9">9</a></span>  member this.Show (id : string) = 
<span class="line-numbers"><strong><a href="#n10" name="n10">10</a></strong></span>    let phone = phones |&gt; Seq.find (fun p -&gt; p.Id = id) |&gt; PhoneViewModel.ToPhoneViewModel
<span class="line-numbers"><a href="#n11" name="n11">11</a></span>    subject.OnNext id 
<span class="line-numbers"><a href="#n12" name="n12">12</a></span>    this.View(phone)
<span class="line-numbers"><a href="#n13" name="n13">13</a></span>
<span class="line-numbers"><a href="#n14" name="n14">14</a></span>  override this.Dispose disposing =
<span class="line-numbers"><a href="#n15" name="n15">15</a></span>    if disposing then 
<span class="line-numbers"><a href="#n16" name="n16">16</a></span>      subject.OnCompleted()
<span class="line-numbers"><a href="#n17" name="n17">17</a></span>      subject.Dispose()      
<span class="line-numbers"><a href="#n18" name="n18">18</a></span>    base.Dispose disposing
</pre></div>
</div>
</div>

<p>One of the great feature of F# is its seamless interoperability with C# libraries. As you seen in the above code snippet we have just made the <code>PhoneController</code> into an observable by implementing the interface <a href="http://msdn.microsoft.com/en-us/library/dd990377%28v=vs.110%29.aspx">IObservable</a>. </p>

<p>We have created a private <a href="http://msdn.microsoft.com/en-us/library/hh242970%28v=vs.103%29.aspx">Rx Subject</a> and made it responsible for pushing the notification which contains the phone id that is being visited.</p>

<p>But wait how do we configure the subscription between this controller and the <code>PhoneViewTracker</code> ? Thanks to the CompositionRoot that we have <a href="https://github.com/tamizhvendan/fsharp-phonecat/blob/2/Web/Infrastructure.fs#L28-L32">created in the step-2</a>. As we have full control over the creation of controller its just a matter of two lines to achieve it.</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"> <a href="#n1" name="n1">1</a></span>type CompositionRoot(phones : seq&lt;PhoneTypeProvider.Root&gt;) =          
<span class="line-numbers"> <a href="#n2" name="n2">2</a></span>    inherit DefaultControllerFactory() with
<span class="line-numbers"> <a href="#n3" name="n3">3</a></span>      override this.GetControllerInstance(requestContext, controllerType) = 
<span class="line-numbers"> <a href="#n4" name="n4">4</a></span>        // ...
<span class="line-numbers"> <a href="#n5" name="n5">5</a></span>        else if controllerType = typeof&lt;PhoneController&gt; then          
<span class="line-numbers"> <a href="#n6" name="n6">6</a></span>          let phones' = phones |&gt; Seq.map TypeProviders.ToCatalogPhone
<span class="line-numbers"> <a href="#n7" name="n7">7</a></span>          let observer = PhoneViewTracker.observePhonesViewed (requestContext.HttpContext.Request.AnonymousID)
<span class="line-numbers"> <a href="#n8" name="n8">8</a></span>          let phoneController = new PhoneController(phones')
<span class="line-numbers"> <a href="#n9" name="n9">9</a></span>          let subscription = phoneController.Subscribe observer                    
<span class="line-numbers"><strong><a href="#n10" name="n10">10</a></strong></span>          phoneController :&gt; IController
<span class="line-numbers"><a href="#n11" name="n11">11</a></span>        // ...
</pre></div>
</div>
</div>
<p>We are leveraging the ASP.NET’s <a href="http://msdn.microsoft.com/en-us/library/fsykd036.aspx">Anonymous Identification Module</a> which help us in creating a unique anonymous id for every user session. We can retrieve it from the <a href="http://msdn.microsoft.com/en-us/library/system.web.httprequest.anonymousid.aspx">HttpRequest</a> as mentioned in the above snippet</p>

<p><a href="http://msdn.microsoft.com/en-in/library/91ka2e6a(v=vs.85).aspx">Anonymous identification of user session</a> are not enabled by default, so add the following entry in the <strong>Web.config</strong> file</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"><a href="#n1" name="n1">1</a></span><span class="tag">&lt;configuration&gt;</span>
<span class="line-numbers"><a href="#n2" name="n2">2</a></span>  <span class="comment">&lt;!-- Existing Code ignored for brevity ... --&gt;</span>
<span class="line-numbers"><a href="#n3" name="n3">3</a></span>  <span class="tag">&lt;system.web&gt;</span>
<span class="line-numbers"><a href="#n4" name="n4">4</a></span>    <span class="comment">&lt;!-- Existing Code ignored for brevity... --&gt;</span>
<span class="line-numbers"><a href="#n5" name="n5">5</a></span>    <span class="tag">&lt;anonymousIdentification</span> <span class="attribute-name">enabled</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">true</span><span class="delimiter">&quot;</span></span> <span class="tag">/&gt;</span>
<span class="line-numbers"><a href="#n6" name="n6">6</a></span>  <span class="tag">&lt;/system.web&gt;</span>
<span class="line-numbers"><a href="#n7" name="n7">7</a></span><span class="tag">&lt;/configuration&gt;</span>
</pre></div>
</div>
</div>

<p>With the help of the partial application of functions as we did it in the previous steps, we have created a partial function called <code>observer</code> which has the signature <code>string -&gt; unit</code>. Then we have subscribed to <code>PhoneController</code> using the <code>Subscribe</code> method and with this we are done with saving an user visit. </p>

<h3 id="recommending-a-phone">2. Recommending a phone</h3>

<p><strong>Workflow</strong></p>

<p><img class="center" src="/images/fsharp_phonecat/step_3/Phone_Recommendation_Workflow.png" width="600" height="500"></p>

<ol>
  <li>User initiates the recommendation request using SignalR</li>
  <li>Upon receiving it, Recommendation SignalR hub sends a recommendation request message to Storage Agent with the user Anonymous Id and SignlaR connection Id of the given user</li>
  <li>Storage Agent then fetches the phone visit history of the given user based on the incoming anonymous id and pass it to the Recommendation Agent along with the SignalR connection id.</li>
  <li>Recommendation Agent responds to this by computing the recommendation and publish the result (Either recommended phone id or none) in the Recommendation observable</li>
  <li>Recommendation hub receives this recommendation result, send the response back to the corresponding SignalR client.</li>
</ol>

<p>The beauty of this entire workflow is all are message driven and asynchronous by default.  </p>

<p>Let’s start from Recommendation SignalR hub. The first step is installing SingalR from <a href="https://www.nuget.org/packages/Microsoft.AspNet.SignalR/2.1.2">the nuget</a>.</p>

<p>After installing create a source file in the <strong>Web</strong> project and name it as <code>Startup</code> then add the following code as per the SignalR convention.</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"><a href="#n1" name="n1">1</a></span>namespace PhoneCat.Web
<span class="line-numbers"><a href="#n2" name="n2">2</a></span>
<span class="line-numbers"><a href="#n3" name="n3">3</a></span>open Owin
<span class="line-numbers"><a href="#n4" name="n4">4</a></span>
<span class="line-numbers"><a href="#n5" name="n5">5</a></span>type Startup() = 
<span class="line-numbers"><a href="#n6" name="n6">6</a></span>  member x.Configuration(app : IAppBuilder) = 
<span class="line-numbers"><a href="#n7" name="n7">7</a></span>    app.MapSignalR() |&gt; ignore
<span class="line-numbers"><a href="#n8" name="n8">8</a></span>    ()
</pre></div>
</div>
</div>

<p>Then add an app setting in the <em>Web.config</em> file and configure the SignalR to use this <code>Startup</code> class</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"><a href="#n1" name="n1">1</a></span><span class="tag">&lt;configuration&gt;</span>
<span class="line-numbers"><a href="#n2" name="n2">2</a></span>  <span class="tag">&lt;appSettings&gt;</span>
<span class="line-numbers"><a href="#n3" name="n3">3</a></span>    <span class="comment">&lt;!-- Other keys.. --&gt;</span>
<span class="line-numbers"><a href="#n4" name="n4">4</a></span>    <span class="tag">&lt;add</span> <span class="attribute-name">key</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">owin:AppStartup</span><span class="delimiter">&quot;</span></span> <span class="attribute-name">value</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">PhoneCat.Web.Startup</span><span class="delimiter">&quot;</span></span> <span class="tag">/&gt;</span>
<span class="line-numbers"><a href="#n5" name="n5">5</a></span>  <span class="tag">&lt;/appSettings&gt;</span>
<span class="line-numbers"><a href="#n6" name="n6">6</a></span>  <span class="comment">&lt;!-- other configuration items.. --&gt;</span>
<span class="line-numbers"><a href="#n7" name="n7">7</a></span><span class="tag">&lt;/configuration&gt;</span>
</pre></div>
</div>
</div>

<p>With SignalR added to the system, the next step is to create <code>RecommendationHub</code>. Add a source file in <strong>Web</strong> project and name it as <code>Hubs</code>.</p>

<p>Then create a <code>RecommendationHub</code> class with a public method <code>GetRecommendation</code> which will be invoked by the SignalR client to initiate recommendation process.</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"><a href="#n1" name="n1">1</a></span>type RecommendationHub() =
<span class="line-numbers"><a href="#n2" name="n2">2</a></span>    inherit Hub ()
<span class="line-numbers"><a href="#n3" name="n3">3</a></span>    member this.GetRecommendation () =             
<span class="line-numbers"><a href="#n4" name="n4">4</a></span>      let encodedAnonymousId = this.Context.Request.Cookies.[&quot;.ASPXANONYMOUS&quot;].Value
<span class="line-numbers"><a href="#n5" name="n5">5</a></span>      let anonymousId = decode encodedAnonymousId
<span class="line-numbers"><a href="#n6" name="n6">6</a></span>      let connectionId = this.Context.ConnectionId
<span class="line-numbers"><a href="#n7" name="n7">7</a></span>      StorageAgent.Post (GetRecommendation(anonymousId, connectionId))
<span class="line-numbers"><a href="#n8" name="n8">8</a></span>      &quot;Recommendation initiated&quot;
</pre></div>
</div>
</div>

<p>Then anonymous id of the user session is actually persisted in the <a href="http://msdn.microsoft.com/en-in/library/91ka2e6a%28v=vs.85%29.aspx">request cookies by Asp.Net</a> in an encoded format. In the <code>GetRecommendation</code> method we will be retrieving this encoded anonymous id from the cookie and decode it. Then we need to get the SignalR connection id which available in the base class <code>Hub</code>. After getting both the anonymous id and the connection id, send a <code>GetRecommendation</code> message to the <code>StorageAgent</code> with these information. Finally send a response to the SignalR client as “Recommendation initiated”.</p>

<p>The <code>decode</code> function is not added yet so let’s add them. Thanks to <a href="http://stackoverflow.com/a/2481110/159850">this stackoverflow answer</a> we just need to convert the code from C# to F#</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"> <a href="#n1" name="n1">1</a></span>let private decode encodedAnonymousId =
<span class="line-numbers"> <a href="#n2" name="n2">2</a></span>    let decodeMethod = 
<span class="line-numbers"> <a href="#n3" name="n3">3</a></span>      typeof&lt;AnonymousIdentificationModule&gt;
<span class="line-numbers"> <a href="#n4" name="n4">4</a></span>        .GetMethod(&quot;GetDecodedValue&quot;, BindingFlags.Static ||| BindingFlags.NonPublic)
<span class="line-numbers"> <a href="#n5" name="n5">5</a></span>    let anonymousIdData = decodeMethod.Invoke(null, [| encodedAnonymousId |]);
<span class="line-numbers"> <a href="#n6" name="n6">6</a></span>    let field = 
<span class="line-numbers"> <a href="#n7" name="n7">7</a></span>      anonymousIdData.GetType()
<span class="line-numbers"> <a href="#n8" name="n8">8</a></span>        .GetField(&quot;AnonymousId&quot;, BindingFlags.Instance ||| BindingFlags.NonPublic);
<span class="line-numbers"> <a href="#n9" name="n9">9</a></span>    field.GetValue(anonymousIdData) :?&gt; string
</pre></div>
</div>
</div>

<p>We have used a special F# operator here <code>:?&gt;</code> which is a dynamic down cast operator which casts a base class to a sub-class of it. You can read <a href="http://msdn.microsoft.com/en-us/library/dd233220.aspx">this msdn documentation</a> to know more about F# casting and conversions.</p>

<p>The <code>GetRecommendation</code> message is not added yet, so let’s add them too. Modify <code>StorageAgentMessage</code> created before as below</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"><a href="#n1" name="n1">1</a></span>  type StorageAgentMessage =
<span class="line-numbers"><a href="#n2" name="n2">2</a></span>    | SavePhoneVisit of string * string
<span class="line-numbers"><a href="#n3" name="n3">3</a></span>    | GetRecommendation of string * string
</pre></div>
</div>
</div>

<p>The final step of this pipeline is to Update the <code>StorageAgent</code> to handle this <code>GetRecommendation</code> message. Modify the <code>storageAgentFunc</code> in the <code>UserNavigationHistory</code> as below</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"> <a href="#n1" name="n1">1</a></span> let private storageAgentFunc (agent : Agent&lt;StorageAgentMessage&gt;) =  
<span class="line-numbers"> <a href="#n2" name="n2">2</a></span>    let rec loop (dict : Dictionary&lt;string, list&lt;string&gt;&gt;) = async { 
<span class="line-numbers"> <a href="#n3" name="n3">3</a></span>      let! storageAgentMessage = agent.Receive()
<span class="line-numbers"> <a href="#n4" name="n4">4</a></span>      match storageAgentMessage with
<span class="line-numbers"> <a href="#n5" name="n5">5</a></span>      | SavePhoneVisit (anonymousId, phoneIdBeingVisited) -&gt; 
<span class="line-numbers"> <a href="#n6" name="n6">6</a></span>          // .. existing code ignored for brevity ..
<span class="line-numbers"> <a href="#n7" name="n7">7</a></span>      | GetRecommendation (anonymousId, connectionId) -&gt;
<span class="line-numbers"> <a href="#n8" name="n8">8</a></span>          if dict.ContainsKey(anonymousId) then
<span class="line-numbers"> <a href="#n9" name="n9">9</a></span>            let phoneIdsVisited = dict.[anonymousId]
<span class="line-numbers"><strong><a href="#n10" name="n10">10</a></strong></span>            RecommendationAgent.Post (connectionId,phoneIdsVisited)
<span class="line-numbers"><a href="#n11" name="n11">11</a></span>      return! loop dict
</pre></div>
</div>
</div>

<p>Handling of the <code>GetRecommendation</code> message is very straight forward. Just get the phone ids being visited by the given anonymous id from the in memory dictionary and send a message consists of connection id and this phone ids visited to the <code>RecommendationAgent</code> which we will be creating next.</p>

<p>Create a source file with the name <code>Recommendations</code> in the <strong>Domain</strong> project and add the <code>RecommendationAgent</code> below</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"> <a href="#n1" name="n1">1</a></span>[&lt;AutoOpen&gt;]
<span class="line-numbers"> <a href="#n2" name="n2">2</a></span>module Recommendation =
<span class="line-numbers"> <a href="#n3" name="n3">3</a></span>  let private recommendationAgentFunc (inbox : Agent&lt;string*List&lt;string&gt;&gt;) =
<span class="line-numbers"> <a href="#n4" name="n4">4</a></span>    let rec messageLoop () = async {
<span class="line-numbers"> <a href="#n5" name="n5">5</a></span>      let! connectionId, visitedPhoneIds = inbox.Receive()     
<span class="line-numbers"> <a href="#n6" name="n6">6</a></span>      if (Seq.length visitedPhoneIds) &gt;= 2 then
<span class="line-numbers"> <a href="#n7" name="n7">7</a></span>        suggestRecommendation connectionId (visitedPhoneIds |&gt; Seq.take 2 |&gt; Seq.toList)
<span class="line-numbers"> <a href="#n8" name="n8">8</a></span>      return! messageLoop()
<span class="line-numbers"> <a href="#n9" name="n9">9</a></span>    }
<span class="line-numbers"><strong><a href="#n10" name="n10">10</a></strong></span>    messageLoop ()
<span class="line-numbers"><a href="#n11" name="n11">11</a></span>
<span class="line-numbers"><a href="#n12" name="n12">12</a></span>  let RecommendationAgent = Agent.Start recommendationAgentFunc
</pre></div>
</div>
</div>

<p>In order to keep this blog post simple I’ve used my own ‘Hello World’ kind of algorithm which picks the latest two phone ids being visited and suggests recommendation based on it. In a real world you would be replacing this toddler algorithm with more sophisticated algorithms like <a href="http://en.wikipedia.org/wiki/Association_rule_learning">Association Rule Learning</a>. I am planning to implement this algorithm at later stages of this blog series.</p>

<p>Then the next step is to implement the <code>suggestRecommendation</code> function which picks a hardcoded recommendation and publish the result using Rx. To do this add the <a href="https://www.nuget.org/packages/Rx-Main/">Rx Nuget Package</a> in the <strong>Domain</strong> project and add the  <code>suggestRecommendation</code> function in the <code>Recommendation</code> module</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"><a href="#n1" name="n1">1</a></span>let RecommendationPipe = new Subject&lt;string*string option&gt;()
<span class="line-numbers"><a href="#n2" name="n2">2</a></span>
<span class="line-numbers"><a href="#n3" name="n3">3</a></span>  let private suggestRecommendation connectionId visitedPhoneIds = 
<span class="line-numbers"><a href="#n4" name="n4">4</a></span>    match visitedPhoneIds with
<span class="line-numbers"><a href="#n5" name="n5">5</a></span>    | [&quot;motorola-xoom-with-wi-fi&quot;; &quot;motorola-xoom&quot;] -&gt; RecommendationPipe.OnNext (connectionId, Some &quot;motorola-atrix-4g&quot;)
<span class="line-numbers"><a href="#n6" name="n6">6</a></span>    | [&quot;dell-streak-7&quot;; &quot;dell-venue&quot;] -&gt; RecommendationPipe.OnNext (connectionId, Some &quot;nexus-s&quot;)
<span class="line-numbers"><a href="#n7" name="n7">7</a></span>    | _ -&gt; RecommendationPipe.OnNext (connectionId, None)
</pre></div>
</div>
</div>

<p>The implementation is a very straight forward pattern matching. If last visited two items are (“motorola-xoom-with-wi-fi”, “motorola-xoom”), send the recommendation as “motorola-atrix-4g”, else if they are (“dell-streak-7”,”dell-venue”) then recommend “nexus-s”. If none of the condition matches then send none. Thanks to the <a href="http://fsharpforfunandprofit.com/posts/the-option-type/">option type</a> which expresses this result in type safe manner.</p>

<p>With all these infrastructure in place, all we need to do is to just subscribe to this <code>RecommendationPipe</code> and send the suggestion to the user via SignalR</p>

<p>Let’s add a observer for this pipe in the <strong>Web</strong> project. Open <code>Hubs</code> module in the <strong>Web</strong> project and add the following code</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"> <a href="#n1" name="n1">1</a></span>
<span class="line-numbers"> <a href="#n2" name="n2">2</a></span>let private getUrl (phoneId : string) httpContext =
<span class="line-numbers"> <a href="#n3" name="n3">3</a></span>    let routeValueDictionary = new RouteValueDictionary()
<span class="line-numbers"> <a href="#n4" name="n4">4</a></span>    routeValueDictionary.Add(&quot;controller&quot;, &quot;Phone&quot;)
<span class="line-numbers"> <a href="#n5" name="n5">5</a></span>    routeValueDictionary.Add(&quot;action&quot;, &quot;Show&quot;)
<span class="line-numbers"> <a href="#n6" name="n6">6</a></span>    routeValueDictionary.Add(&quot;id&quot;, phoneId)
<span class="line-numbers"> <a href="#n7" name="n7">7</a></span>    let requestContext = new RequestContext(new HttpContextWrapper(httpContext), new RouteData());
<span class="line-numbers"> <a href="#n8" name="n8">8</a></span>    let virtualPathData = RouteTable.Routes.GetVirtualPath(requestContext, routeValueDictionary);
<span class="line-numbers"> <a href="#n9" name="n9">9</a></span>    virtualPathData.VirtualPath
<span class="line-numbers"><strong><a href="#n10" name="n10">10</a></strong></span>
<span class="line-numbers"><a href="#n11" name="n11">11</a></span>let notifyRecommendation httpContext phones (connectionId, recommendedPhoneId) =
<span class="line-numbers"><a href="#n12" name="n12">12</a></span>    let phones' = phones |&gt; Seq.map TypeProviders.ToPhone
<span class="line-numbers"><a href="#n13" name="n13">13</a></span>    match recommendedPhoneId with 
<span class="line-numbers"><a href="#n14" name="n14">14</a></span>    | Some phoneId -&gt;
<span class="line-numbers"><a href="#n15" name="n15">15</a></span>      let recommendedPhone = Phones.getPhoneById phones' phoneId
<span class="line-numbers"><a href="#n16" name="n16">16</a></span>      let phoneUrl = getUrl phoneId httpContext
<span class="line-numbers"><a href="#n17" name="n17">17</a></span>      let hubContext = GlobalHost.ConnectionManager.GetHubContext&lt;RecommendationHub&gt;()
<span class="line-numbers"><a href="#n18" name="n18">18</a></span>      hubContext.Clients.Client(connectionId)?showRecommendation(recommendedPhone, phoneUrl) 
<span class="line-numbers"><a href="#n19" name="n19">19</a></span>    | None -&gt; ()
</pre></div>
</div>
</div>

<p>The <code>notifyRecommendation</code> function checks whether the incoming recommendedPhoneId has value or not. If it has value, it just picks the <code>Phone</code> record corresponding to the given phoneId and get the url for the recommended phone. With all these data in place, we just need to send the response to the using via SignalR.</p>

<p>You would have a noticed a weird <code>?</code> symbol which is actually part of the <a href="https://www.nuget.org/packages/ImpromptuInterface.FSharp/">ImpromptuInterface.FSharp</a>. This library adds provisions to use <a href="http://msdn.microsoft.com/en-IN/library/dd264736.aspx">C# dynamic types</a> in F#</p>

<p>They are two missing pieces. One is <code>Phones.getPhoneById</code> which we are not having. Let’s add them. Open <code>Phones</code> module in <strong>Domain</strong> project and add it as mentioned below</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"><a href="#n1" name="n1">1</a></span>let getPhoneById (phones : seq&lt;Phone&gt;) phoneId =
<span class="line-numbers"><a href="#n2" name="n2">2</a></span>    phones |&gt; Seq.find (fun p -&gt; p.Id = phoneId)
</pre></div>
</div>
</div>

<p>The final step is wiring the <code>RecommendationPipe</code> with the <code>notifyRecommendation</code>. Open <code>Global.asax.fs</code> and update it as below</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"><a href="#n1" name="n1">1</a></span>type Global() = 
<span class="line-numbers"><a href="#n2" name="n2">2</a></span>  // .. existing code ignore for brevity ..
<span class="line-numbers"><a href="#n3" name="n3">3</a></span> member x.Application_Start() =
<span class="line-numbers"><a href="#n4" name="n4">4</a></span>    let phones = GitHubRepository.getPhones()
<span class="line-numbers"><a href="#n5" name="n5">5</a></span>    // .. existing code ignore for brevity ..
<span class="line-numbers"><a href="#n6" name="n6">6</a></span>    let notificationObserver = Hubs.notifyRecommendation HttpContext.Current phones
<span class="line-numbers"><a href="#n7" name="n7">7</a></span>    Recommendation.RecommendationPipe.Subscribe notificationObserver |&gt; ignore
<span class="line-numbers"><a href="#n8" name="n8">8</a></span>    ()
</pre></div>
</div>
</div>

<p>Partial application of function is a very handy thing which actually replaces its counterpart Dependency Injection in the OOP. We just provided the first two arguments of <code>notifyRecommendation</code> and created a new function with the signature <code>string * string option -&gt; unit</code> which is the expected observer signature for the <code>RecommendationPipe</code>.</p>

<h4 id="the-front-end-ui">The Front End UI</h4>
<p>The front end for this is a typical SignalR-Javascript client code which you can find it the <a href="https://github.com/tamizhvendan/fsharp-phonecat/blob/3/Web/Scripts/recommendation.js">github repository</a>. I’ve intentionally leaving the front-end part of this application as it would be extends the scope of the blog post. Moreover if you go through the source code in the github repository you can easily understand</p>

<h3 id="summary">Summary</h3>
<p>F# is just so awesome with so much expressive functional programming features. Rx, Agents and SignalR add more powers to it and enable you to create a scalable functional reactive architecture. I’d like give credits two incredible resources on this subject Mark Seemann’s Pluralsight course on <a href="http://www.pluralsight.com/courses/functional-architecture-fsharp">Functional Architecture with F#</a> and Kevin Ashton’s excellent blog post on <a href="http://namelessinteractive.com/blog/Full_Stack_FSharp_%E2%80%93_The_Long_Version_(Part_1)">Full Stack F#</a> which helped me a lot in coming out with this blog post.</p>

<p>Last but not the least, Thanks to <a href="https://sergeytihon.wordpress.com">Sergey Tihon</a> for the words of encouragement to write the blog post on this topic.</p>

<p>You can find the source code of this step in <a href="https://github.com/tamizhvendan/fsharp-phonecat/tree/3">the github repository</a>. </p>
]]></content>
  </entry>
  
</feed>
