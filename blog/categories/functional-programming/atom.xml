<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: functional-programming | Tamizh's Thoughts]]></title>
  <link href="http://blog.tamizhvendan.in/blog/categories/functional-programming/atom.xml" rel="self"/>
  <link href="http://blog.tamizhvendan.in/"/>
  <updated>2014-12-04T20:16:37+05:30</updated>
  <id>http://blog.tamizhvendan.in/</id>
  <author>
    <name><![CDATA[Tamizhvendan S]]></name>
    <email><![CDATA[tamizh88@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Verbs - Buried abstraction in OO World]]></title>
    <link href="http://blog.tamizhvendan.in/blog/2014/09/26/verbs-buried-abstraction-in-oo-world/"/>
    <updated>2014-09-26T12:44:00+05:30</updated>
    <id>http://blog.tamizhvendan.in/blog/2014/09/26/verbs-buried-abstraction-in-oo-world</id>
    <content type="html"><![CDATA[<p>In Object Oriented Programming, the problem domain is being modeled as objects(nouns) which collaborate with one another in the form of messages(verbs). We are actually creating abstractions and through which we are solving the problems in an organized and cleaner way. But this way of creating abstractions does not scale in all the scenarios.</p>

<p>Let me share it through an example </p>

<p>Lets rewind the time machine to travel back to 2006 (.NET 2.0) which doesn’t have <code>LINQ</code> support. You are asked to solve the following problem statement</p>

<blockquote>
  <p>You are working on a Student Management Application. Each student is having a name and an age. You are asked to create module to sort the Students based on their name</p>
</blockquote>

<p><div><script src='https://gist.github.com/4fd1f5ea2b4e28658e81.js?file=Student.cs'></script>
<noscript><pre><code>public class Student
{
  public int Age { get; set; }
  public string Name { get; set; }
}</code></pre></noscript></div>
</p>

<p>To sort based on Name we need to write a comparer which compares two student names and return some integer</p>

<p><div><script src='https://gist.github.com/4fd1f5ea2b4e28658e81.js?file=StudentNameComparer.cs'></script>
<noscript><pre><code>public class StudentNameComparer : IComparer&lt;Student&gt;
{
  public int Compare(Student x, Student y)
  {
    return string.Compare(x.Name, y.Name, StringComparison.CurrentCulture);
  }
}</code></pre></noscript></div>
</p>

<p>Then in the main program we will be doing the sorting using <code>Array.Sort</code> method</p>

<p><div><script src='https://gist.github.com/4fd1f5ea2b4e28658e81.js?file=Program.cs'></script>
<noscript><pre><code>class Program
{
  static void Main(string[] args)
  {
    List&lt;Student&gt; students = new List&lt;Student&gt;();

    // Populate Students List here	

    Student[] studentsSortedByName = students.ToArray();       

    Array.Sort(studentsSortedByName, new StudentNameComparer());
  }
}</code></pre></noscript></div>
</p>

<p>Hmmm. You might think what is a big deal in it ? But there is! Let me complicate the scenario by adding a new requirement</p>

<blockquote>
  <p>You also asked to do sorting based on Age!</p>
</blockquote>

<p>How do you do it ?</p>

<p>Well! Just create yet another Comparer which compares the age</p>

<p><div><script src='https://gist.github.com/4fd1f5ea2b4e28658e81.js?file=StudentAgeComparer.cs'></script>
<noscript><pre><code>public class StudentAgeComparer : IComparer&lt;Student&gt;
{
  public int Compare(Student x, Student y)
  {
    if (x.Age == y.Age)
    {
      return 0;
    }
    if (x.Age &lt; y.Age)
    {
      return -1;
    }
      return 1;
  }
}</code></pre></noscript></div>
</p>

<p><div><script src='https://gist.github.com/4fd1f5ea2b4e28658e81.js?file=Program1.cs'></script>
<noscript><pre><code>class Program1
{
  static void Main(string[] args)
  {
    List&lt;Student&gt; students = new List&lt;Student&gt;();
	
    // Populate Students List here	

    Student[] studentsSortedByAge = students.ToArray();       

    Array.Sort(studentsSortedByAge, new StudentAgeComparer());
  }
}</code></pre></noscript></div>
</p>

<p>So much of code to do the trivial thing, isn’t it ?</p>

<p>Let us dig deep to figure out what is wrong here. First let us start with the comparers <code>StudentAgeComparer</code> and <code>StudentNameComparer</code>. These comparers (nouns) actually escorting the method <code>Compare</code> (verb) and not doing anything productive apart from this. In OO world a verb should always be associated with a noun and because of this way of abstraction, we are adding an unnecessary complexity to the code. </p>

<p>Just think of yet another scenario where want to sort the student by rank, customer by name, product by name. We need to write so much comparers!</p>

<h3 id="verbs-to-the-rescue">Verbs to the rescue</h3>

<p>Let us see the student sorting scenario from a different perspective. In this new pair of (functional)eyes we see the same scenario as</p>

<ul>
  <li><strong>Order</strong> <em>Student</em> by <strong>Name</strong>  </li>
  <li><strong>Order</strong> <em>Student</em> by <strong>Age</strong>  </li>
  <li><strong>Order</strong> <em>Customer</em> by <strong>Name</strong>  </li>
  <li><strong>Order</strong> <em>Product</em> by <strong>Name</strong>  </li>
</ul>

<p>i.e the verb <strong>Order</strong> is common across all the scenario. </p>

<p>The only thing which is changing is <em>what we are ordering</em> and <em>by which property</em>. Let us model things based on this verb abstraction.</p>

<p>PseudoCode</p>

<pre><code>    OrderBy&lt;Student&gt;(s -&gt; s.Name)
    OrderBy&lt;Student&gt;(s -&gt; s.Age)
    OrderBy&lt;Customer&gt;(c -&gt; c.Name)
    OrderBy&lt;Product&gt;(p -&gt; p.Name)
</code></pre>

<p>Here OrderBy is a function which models the verb (Order). Two things to note</p>

<ul>
  <li>OrderBy is generic and it can act on any types of objects (Student, Customer, Product,…)</li>
  <li>OrderBy doesn’t know which property to choose so, we need to tell explicitly.</li>
</ul>

<p>So, what we gained because of this ?</p>

<p>Let us go back to the initial requirement</p>

<blockquote>
  <p>You are working on a Student Management Application. Each student is having a name and an age. You are asked to create module to sort the Students based on their name and age</p>
</blockquote>

<p>Now change the time machine to land in 2014. We have <code>LINQ</code> support in <code>C#</code> now which supports verbs (functions) as first class citizens</p>

<p><div><script src='https://gist.github.com/4fd1f5ea2b4e28658e81.js?file=Program2.cs'></script>
<noscript><pre><code>class Program2
{
  static void Main(string[] args)
  {
    List&lt;Student&gt; students = new List&lt;Student&gt;();

    // Populate Students List here	

    var studentsSortedByName = Enumerable.OrderBy(students, s =&gt; s.Name);
    var studentsSortedByAge = Enumerable.OrderBy(students, s =&gt; s.Age);
  }
}</code></pre></noscript></div>
</p>

<p>Just two lines instead of two comparers. All we did is just changed the way we create abstractions. Let me explain it using some visuals.</p>

<p><img class="center" src="/images/VerbsInOoWorld/Students_Sorted_By_Name.png" title="" ></p>

<p>OrderBy is an abstraction which does only one thing, that is order the objects in an ascending order and does it to the perfection. But to use this abstraction we need to provide two inputs, the objects and a function which provides the propery by which the objects to be sorted </p>

<p>Does it closely resemble what we have seen earlier in the pseudocode ? Since it is generic, we can also use it for all other objects (Product, Customer, etc.,) too !</p>

<p><img class="center" src="/images/VerbsInOoWorld/Students_Sorted_By_Age.png" title="" ></p>

<h4 id="summary">Summary</h4>

<p>Verbs(functions) are not silver bullets and they are not the replacement of Nouns(objects). But by choosing our abstraction wisely we can achieve great things with lesser lines of code and in turn release the code with lesser bugs <i class='emoji smile'></i> </p>
]]></content>
  </entry>
  
</feed>
